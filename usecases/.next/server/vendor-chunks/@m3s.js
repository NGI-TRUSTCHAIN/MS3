"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@m3s";
exports.ids = ["vendor-chunks/@m3s"];
exports.modules = {

/***/ "(ssr)/./node_modules/@m3s/wallet/dist/index.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/@m3s/wallet/dist/index.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdapterError: () => (/* binding */ AdapterError),\n/* harmony export */   NetworkHelper: () => (/* binding */ NetworkHelper),\n/* harmony export */   NonceType: () => (/* binding */ NonceType),\n/* harmony export */   PrivateKeyHelper: () => (/* binding */ PrivateKeyHelper),\n/* harmony export */   RuntimeEnvironment: () => (/* binding */ RuntimeEnvironment),\n/* harmony export */   WalletErrorCode: () => (/* binding */ WalletErrorCode),\n/* harmony export */   WalletEvent: () => (/* binding */ WalletEvent),\n/* harmony export */   WalletType: () => (/* binding */ WalletType),\n/* harmony export */   createWallet: () => (/* binding */ createWallet),\n/* harmony export */   registry: () => (/* binding */ registry)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/wallet/wallet.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/wallet/mnemonic.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/wallet/hdwallet.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/hash/message.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var joi__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! joi */ \"(ssr)/./node_modules/joi/lib/index.js\");\n/* harmony import */ var _web3auth_no_modal__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @web3auth/no-modal */ \"(ssr)/./node_modules/@web3auth/no-modal/dist/lib.esm/noModal.js\");\n/* harmony import */ var _web3auth_base__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @web3auth/base */ \"(ssr)/./node_modules/@web3auth/base/dist/lib.esm/wallet/index.js\");\n/* harmony import */ var _web3auth_auth_adapter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @web3auth/auth-adapter */ \"(ssr)/./node_modules/@web3auth/auth-adapter/dist/lib.esm/authAdapter.js\");\n/* harmony import */ var _web3auth_ethereum_provider__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @web3auth/ethereum-provider */ \"(ssr)/./node_modules/@web3auth/ethereum-provider/dist/lib.esm/providers/privateKeyProviders/EthereumPrivateKeyProvider.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// packages/wallet/package.json\nvar package_default = {\n  name: \"@m3s/wallet\",\n  version: \"2.4.3\",\n  type: \"module\",\n  description: \"A flexible wallet interface supporting multiple blockchain wallet types, including EVM wallets and Web3Auth integration\",\n  license: \"MIT\",\n  keywords: [\n    \"wallet\",\n    \"ethereum\",\n    \"web3auth\",\n    \"blockchain\",\n    \"evm\",\n    \"oauth\",\n    \"crypto\",\n    \"web3\"\n  ],\n  repository: {\n    type: \"git\",\n    url: \"git@bitbucket.org:ctb-marisca/ms3-package.git\",\n    directory: \"packages/wallet\"\n  },\n  main: \"./dist/index.cjs.js\",\n  module: \"./dist/index.esm.js\",\n  types: \"./dist/index.d.ts\",\n  exports: {\n    \".\": {\n      types: \"./dist/index.d.ts\",\n      import: \"./dist/index.esm.js\",\n      require: \"./dist/index.cjs.js\"\n    }\n  },\n  scripts: {\n    build: \"tsc -b\",\n    prepublishOnly: \"npm run build\",\n    test: \"vitest run --sequence.sequential\"\n  },\n  dependencies: {\n    ethers: \"^6.13.5\",\n    joi: \"^17.13.3\"\n  },\n  devDependencies: {\n    \"@m3s/shared\": \"*\"\n  },\n  peerDependencies: {\n    \"@web3auth/auth-adapter\": \"9.7.0\",\n    \"@web3auth/base\": \"9.7.0\",\n    \"@web3auth/ethereum-provider\": \"9.7.0\",\n    \"@web3auth/no-modal\": \"9.7.0\"\n  },\n  peerDependenciesMeta: {\n    \"@web3auth/auth-adapter\": {\n      optional: true\n    },\n    \"@web3auth/base\": {\n      optional: true\n    },\n    \"@web3auth/ethereum-provider\": {\n      optional: true\n    },\n    \"@web3auth/no-modal\": {\n      optional: true\n    }\n  },\n  publishConfig: {\n    access: \"public\",\n    tag: \"latest\"\n  },\n  files: [\n    \"dist\"\n  ],\n  engines: {\n    node: \">=18.0.0\"\n  }\n};\n\n// packages/shared/dist/errors/AdapterError.js\nvar AdapterError = class extends Error {\n  // Add this line\n  constructor(message, options) {\n    super(message);\n    __publicField(this, \"code\");\n    __publicField(this, \"cause\");\n    __publicField(this, \"methodName\");\n    __publicField(this, \"details\");\n    this.name = this.constructor.name;\n    this.code = options?.code;\n    this.cause = options?.cause;\n    this.methodName = options?.methodName;\n    this.details = options?.details;\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n};\n\n// packages/shared/dist/registry/capability.js\nvar Capability;\n(function(Capability2) {\n  Capability2[\"CoreWallet\"] = \"ICoreWallet\";\n  Capability2[\"EventEmitter\"] = \"IEventEmitter\";\n  Capability2[\"MessageSigner\"] = \"IMessageSigner\";\n  Capability2[\"TransactionHandler\"] = \"ITransactionHandler\";\n  Capability2[\"TypedDataSigner\"] = \"ITypedDataSigner\";\n  Capability2[\"GasEstimation\"] = \"IGasEstimation\";\n  Capability2[\"TokenOperations\"] = \"ITokenOperations\";\n  Capability2[\"RPCHandler\"] = \"IRPCHandler\";\n  Capability2[\"TransactionStatus\"] = \"ITransactionStatus\";\n  Capability2[\"ContractGenerator\"] = \"IContractGenerator\";\n  Capability2[\"ContractCompiler\"] = \"IContractCompiler\";\n  Capability2[\"QuoteProvider\"] = \"IQuoteProvider\";\n  Capability2[\"OperationHandler\"] = \"IOperationHandler\";\n  Capability2[\"ChainDiscovery\"] = \"IChainDiscovery\";\n  Capability2[\"GasEstimator\"] = \"IGasEstimator\";\n  Capability2[\"OperationMaintenance\"] = \"IOperationMaintenance\";\n  Capability2[\"AdapterIdentity\"] = \"IAdapterIdentity\";\n  Capability2[\"AdapterLifecycle\"] = \"IAdapterLifecycle\";\n})(Capability || (Capability = {}));\nvar MethodToCapabilityMap = {\n  // --- ICoreWallet ---\n  \"getAccounts\": Capability.CoreWallet,\n  \"getBalance\": Capability.CoreWallet,\n  \"getNetwork\": Capability.CoreWallet,\n  \"setProvider\": Capability.CoreWallet,\n  \"disconnect\": Capability.CoreWallet,\n  \"isConnected\": Capability.CoreWallet,\n  // --- ITransactionHandler ---\n  \"sendTransaction\": Capability.TransactionHandler,\n  // --- IMessageSigner ---\n  \"signMessage\": Capability.MessageSigner,\n  // --- ITypedDataSigner ---\n  \"signTypedData\": Capability.TypedDataSigner,\n  // --- IGasEstimation ---\n  \"estimateGas\": Capability.GasEstimation,\n  // --- IEventEmitter ---\n  \"on\": Capability.EventEmitter,\n  \"off\": Capability.EventEmitter,\n  \"emit\": Capability.EventEmitter,\n  // --- ITokenOperations ---\n  \"callContract\": Capability.TokenOperations,\n  // --- IRPCHandler ---\n  \"getChainId\": Capability.RPCHandler,\n  \"getGasPrice\": Capability.RPCHandler,\n  \"getBlockNumber\": Capability.RPCHandler,\n  // --- ITransactionStatus ---\n  \"getTransaction\": Capability.TransactionStatus,\n  \"waitForTransaction\": Capability.TransactionStatus,\n  // --- IContractGenerator ---\n  \"generate\": Capability.ContractGenerator,\n  // --- IContractCompiler ---\n  \"compile\": Capability.ContractCompiler,\n  // --- IQuoteProvider ---\n  \"getOperationQuote\": Capability.QuoteProvider,\n  // --- IOperations ---\n  \"executeOperation\": Capability.OperationHandler,\n  \"getOperationStatus\": Capability.OperationHandler,\n  \"cancelOperation\": Capability.OperationHandler,\n  \"resumeOperation\": Capability.OperationHandler,\n  // --- IChainDiscovery ---\n  \"getSupportedChains\": Capability.ChainDiscovery,\n  \"getSupportedTokens\": Capability.ChainDiscovery,\n  // --- IGasEstimator ---\n  \"getGasOnDestination\": Capability.GasEstimator,\n  // --- IOperationMaintenance ---\n  \"checkForTimedOutOperations\": Capability.OperationMaintenance,\n  // --- IAdapterLifecycle ---\n  \"initialize\": Capability.AdapterLifecycle,\n  \"isInitialized\": Capability.AdapterLifecycle\n};\n\n// packages/shared/dist/errors/proxy.js\nfunction createErrorHandlingProxy(adapterInstance, capabilities, errorMap = {}, defaultErrorCode, contextName = \"UnknownAdapter\") {\n  return new Proxy(adapterInstance, {\n    get(target, prop, receiver) {\n      const originalValue = Reflect.get(target, prop, receiver);\n      const methodName = String(prop);\n      if (typeof originalValue === \"function\") {\n        const requiredCapability = MethodToCapabilityMap[methodName];\n        if (requiredCapability && !capabilities.includes(requiredCapability)) {\n          return () => {\n            throw new AdapterError(`Method '${methodName}' is not supported by ${contextName}. It lacks the required capability: '${requiredCapability}'.`, { code: \"METHOD_NOT_SUPPORTED\", methodName });\n          };\n        }\n        const isAsync = originalValue.constructor.name === \"AsyncFunction\";\n        const handleError = (error) => {\n          const originalErrorMessage = error instanceof Error ? error.message : String(error);\n          console.error(`[${contextName} Error] Method '${methodName}' failed: ${originalErrorMessage}`, error);\n          if (error instanceof AdapterError) {\n            throw error;\n          }\n          let mappedErrorCode = defaultErrorCode;\n          for (const key in errorMap) {\n            if (originalErrorMessage.includes(key)) {\n              mappedErrorCode = errorMap[key];\n              break;\n            }\n          }\n          throw new AdapterError(`${contextName} method '${methodName}' failed: ${originalErrorMessage}`, {\n            cause: error,\n            methodName,\n            code: mappedErrorCode\n          });\n        };\n        if (isAsync) {\n          return async function(...args) {\n            try {\n              return await originalValue.apply(target, args);\n            } catch (error) {\n              handleError(error);\n            }\n          };\n        } else {\n          return function(...args) {\n            try {\n              return originalValue.apply(target, args);\n            } catch (error) {\n              handleError(error);\n            }\n          };\n        }\n      }\n      return originalValue;\n    }\n  });\n}\n\n// packages/shared/dist/types/error.js\nvar WalletErrorCode;\n(function(WalletErrorCode2) {\n  WalletErrorCode2[\"Unknown\"] = \"UNKNOWN\";\n  WalletErrorCode2[\"environment\"] = \"ENVIRONMENT_MISMATCH\";\n  WalletErrorCode2[\"NotImplemented\"] = \"NOT_IMPLEMENTED\";\n  WalletErrorCode2[\"AdapterNotInitialized\"] = \"ADAPTER_NOT_INITIALIZED\";\n  WalletErrorCode2[\"WalletNotConnected\"] = \"WALLET_NOT_CONNECTED\";\n  WalletErrorCode2[\"ProviderNotFound\"] = \"PROVIDER_NOT_FOUND\";\n  WalletErrorCode2[\"NetworkError\"] = \"NETWORK_ERROR\";\n  WalletErrorCode2[\"UserRejected\"] = \"USER_REJECTED\";\n  WalletErrorCode2[\"InvalidInput\"] = \"INVALID_INPUT\";\n  WalletErrorCode2[\"TransactionFailed\"] = \"TRANSACTION_FAILED\";\n  WalletErrorCode2[\"SignatureFailed\"] = \"SIGNATURE_FAILED\";\n  WalletErrorCode2[\"MethodNotSupported\"] = \"METHOD_NOT_SUPPORTED\";\n  WalletErrorCode2[\"FeatureNotSupported\"] = \"FEATURE_NOT_SUPPORTED\";\n  WalletErrorCode2[\"AdapterNotFound\"] = \"ADAPTER_NOT_FOUND\";\n  WalletErrorCode2[\"MissingConfig\"] = \"MISSING_CONFIG\";\n  WalletErrorCode2[\"InitializationFailed\"] = \"INITIALIZATION_FAILED\";\n  WalletErrorCode2[\"ConnectionFailed\"] = \"CONNECTION_FAILED\";\n  WalletErrorCode2[\"AccountUnavailable\"] = \"ACCOUNT_UNAVAILABLE\";\n  WalletErrorCode2[\"GasEstimationFailed\"] = \"GAS_ESTIMATION_FAILED\";\n  WalletErrorCode2[\"InsufficientFunds\"] = \"INSUFFICIENT_FUNDS\";\n  WalletErrorCode2[\"TransactionReceiptFailed\"] = \"TRANSACTION_RECEIPT_FAILED\";\n  WalletErrorCode2[\"TokenBalanceFailed\"] = \"TOKEN_BALANCE_FAILED\";\n  WalletErrorCode2[\"SigningFailed\"] = \"INVALID_SIGNATURE\";\n  WalletErrorCode2[\"ContractCallFailed\"] = \"CONTRACT CALL FAILED\";\n})(WalletErrorCode || (WalletErrorCode = {}));\nvar CrossChainErrorCode;\n(function(CrossChainErrorCode2) {\n  CrossChainErrorCode2[\"RpcValidationFailed\"] = \"RPC_VALIDATION_FAILED\";\n  CrossChainErrorCode2[\"RpcReliabilityWarning\"] = \"RPC_RELIABILITY_WARNING\";\n  CrossChainErrorCode2[\"Unknown\"] = \"CC_UNKNOWN\";\n  CrossChainErrorCode2[\"AdapterNotInitialized\"] = \"CC_ADAPTER_NOT_INITIALIZED\";\n  CrossChainErrorCode2[\"NetworkError\"] = \"CC_NETWORK_ERROR\";\n  CrossChainErrorCode2[\"InvalidInput\"] = \"CC_INVALID_INPUT\";\n  CrossChainErrorCode2[\"QuoteFailed\"] = \"CC_QUOTE_FAILED\";\n  CrossChainErrorCode2[\"ExecutionFailed\"] = \"CC_EXECUTION_FAILED\";\n  CrossChainErrorCode2[\"ProviderSetFailed\"] = \"CC_PROVIDER_SETUP_FAILED\";\n  CrossChainErrorCode2[\"StatusCheckFailed\"] = \"CC_STATUS_CHECK_FAILED\";\n  CrossChainErrorCode2[\"UnsupportedChain\"] = \"CC_UNSUPPORTED_CHAIN\";\n  CrossChainErrorCode2[\"UnsupportedToken\"] = \"CC_UNSUPPORTED_TOKEN\";\n  CrossChainErrorCode2[\"OperationNotFound\"] = \"CC_OPERATION_NOT_FOUND\";\n})(CrossChainErrorCode || (CrossChainErrorCode = {}));\nvar SmartContractErrorCode;\n(function(SmartContractErrorCode2) {\n  SmartContractErrorCode2[\"Unknown\"] = \"SC_UNKNOWN\";\n  SmartContractErrorCode2[\"AdapterNotInitialized\"] = \"SC_ADAPTER_NOT_INITIALIZED\";\n  SmartContractErrorCode2[\"NetworkError\"] = \"SC_NETWORK_ERROR\";\n  SmartContractErrorCode2[\"InvalidInput\"] = \"SC_INVALID_INPUT\";\n  SmartContractErrorCode2[\"CompilationFailed\"] = \"SC_COMPILATION_FAILED\";\n  SmartContractErrorCode2[\"DeploymentFailed\"] = \"SC_DEPLOYMENT_FAILED\";\n  SmartContractErrorCode2[\"MethodCallFailed\"] = \"SC_METHOD_CALL_FAILED\";\n  SmartContractErrorCode2[\"ReadCallFailed\"] = \"SC_READ_CALL_FAILED\";\n  SmartContractErrorCode2[\"WriteCallFailed\"] = \"SC_WRITE_CALL_FAILED\";\n  SmartContractErrorCode2[\"InvalidAbi\"] = \"SC_INVALID_ABI\";\n  SmartContractErrorCode2[\"ContractNotFound\"] = \"SC_CONTRACT_NOT_FOUND\";\n  SmartContractErrorCode2[\"WalletRequired\"] = \"SC_WALLET_REQUIRED\";\n})(SmartContractErrorCode || (SmartContractErrorCode = {}));\n\n// packages/shared/dist/types/registry.js\nvar Ms3Modules;\n(function(Ms3Modules2) {\n  Ms3Modules2[\"wallet\"] = \"wallet\";\n  Ms3Modules2[\"smartcontract\"] = \"smart-contract\";\n  Ms3Modules2[\"crosschain\"] = \"crosschain\";\n})(Ms3Modules || (Ms3Modules = {}));\nvar RuntimeEnvironment;\n(function(RuntimeEnvironment2) {\n  RuntimeEnvironment2[\"BROWSER\"] = \"browser\";\n  RuntimeEnvironment2[\"SERVER\"] = \"server\";\n})(RuntimeEnvironment || (RuntimeEnvironment = {}));\n\n// packages/shared/dist/helpers/environment.js\nfunction detectRuntimeEnvironment() {\n  const result = [];\n  if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n    result.push(RuntimeEnvironment.SERVER);\n  }\n  if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n    result.push(RuntimeEnvironment.BROWSER);\n  }\n  return result;\n}\nfunction validateEnvironment(adapterName, requirements) {\n  const currentEnvs = detectRuntimeEnvironment();\n  const isSupported = currentEnvs.some((env) => requirements.supportedEnvironments.includes(env));\n  if (!isSupported) {\n    const supportedList = requirements.supportedEnvironments.join(\", \");\n    const detectedList = currentEnvs.join(\", \");\n    let errorMessage = `Adapter '${adapterName}' requires ${supportedList} environment but detected ${detectedList}.`;\n    if (requirements.limitations) {\n      errorMessage += \"\\n\" + requirements.limitations.join(\"\\n\");\n    }\n    throw new AdapterError(errorMessage, {\n      code: WalletErrorCode.environment,\n      methodName: \"validateEnvironment\",\n      details: {\n        adapterName,\n        currentEnvironment: currentEnvs,\n        // ✅ Now array\n        supportedEnvironments: requirements.supportedEnvironments,\n        limitations: requirements.limitations\n      }\n    });\n  }\n  if (requirements.securityNotes && requirements.securityNotes.length > 0) {\n    requirements.securityNotes.forEach((note) => {\n      console.warn(`[${adapterName}] Security Note: ${note}`);\n    });\n  }\n}\n\n// packages/shared/dist/registry/compatibility.js\nvar WALLET_COMPATIBILITY = {\n  \"ethers@1.0.0\": {\n    adapterName: \"ethers\",\n    version: \"1.0.0\",\n    compatibleVersions: [\"1.0.0\"],\n    breakingChanges: [],\n    crossModuleCompatibility: [\n      {\n        moduleName: \"smart-contract\",\n        // ✅ This wallet can work with any smart-contract adapter that can generate contracts.\n        requiresCapabilities: [Capability.ContractGenerator]\n      },\n      {\n        moduleName: \"crosschain\",\n        // ✅ This wallet can work with any crosschain adapter that can execute operations.\n        requiresCapabilities: [Capability.OperationHandler]\n      }\n    ]\n  },\n  \"web3auth@1.0.0\": {\n    adapterName: \"web3auth\",\n    version: \"1.0.0\",\n    compatibleVersions: [\"1.0.0\"],\n    breakingChanges: [],\n    crossModuleCompatibility: [\n      {\n        moduleName: \"smart-contract\",\n        // ✅ This wallet can work with any smart-contract adapter that can generate contracts.\n        requiresCapabilities: [Capability.ContractGenerator]\n      },\n      {\n        moduleName: \"crosschain\",\n        // ✅ This wallet can work with any crosschain adapter that can execute operations.\n        requiresCapabilities: [Capability.OperationHandler]\n      }\n    ]\n  }\n};\nvar SMART_CONTRACT_COMPATIBILITY = {\n  \"openZeppelin@1.0.0\": {\n    adapterName: \"openZeppelin\",\n    version: \"1.0.0\",\n    compatibleVersions: [\"1.0.0\"],\n    breakingChanges: [],\n    crossModuleCompatibility: [\n      {\n        moduleName: \"wallet\",\n        // ✅ This smart-contract adapter needs a wallet that can handle transactions.\n        requiresCapabilities: [Capability.TransactionHandler, Capability.RPCHandler]\n      }\n    ]\n  }\n};\nvar CROSSCHAIN_COMPATIBILITY = {\n  \"lifi@1.0.0\": {\n    adapterName: \"lifi\",\n    version: \"1.0.0\",\n    compatibleVersions: [\"1.0.0\"],\n    breakingChanges: [],\n    crossModuleCompatibility: [\n      {\n        moduleName: \"wallet\",\n        // ✅ This crosschain adapter needs a wallet that can handle transactions and RPC calls.\n        requiresCapabilities: [Capability.TransactionHandler, Capability.RPCHandler]\n      }\n    ]\n  }\n};\nfunction getStaticCompatibilityMatrix(moduleName, adapterName, version) {\n  const key = `${adapterName}@${version}`;\n  switch (moduleName) {\n    case \"wallet\":\n      return WALLET_COMPATIBILITY[key];\n    case \"smart-contract\":\n      return SMART_CONTRACT_COMPATIBILITY[key];\n    case \"crosschain\":\n      return CROSSCHAIN_COMPATIBILITY[key];\n    default:\n      return void 0;\n  }\n}\nfunction checkCrossPackageCompatibility(sourceModule, sourceAdapter, sourceVersion, targetModule, targetAdapter, targetVersion) {\n  const sourceMatrix = getStaticCompatibilityMatrix(sourceModule, sourceAdapter, sourceVersion);\n  if (!sourceMatrix)\n    return false;\n  const targetModuleCompatRule = sourceMatrix.crossModuleCompatibility.find((cmc) => cmc.moduleName === targetModule);\n  if (!targetModuleCompatRule)\n    return false;\n  const targetAdapterInfo = registry.getAdapter(targetModule, targetAdapter, targetVersion);\n  if (!targetAdapterInfo?.capabilities)\n    return false;\n  const sourceAdapterInfo = registry.getAdapter(sourceModule, sourceAdapter, sourceVersion);\n  const currentEnvironments = detectRuntimeEnvironment();\n  if (sourceAdapterInfo?.environment && !sourceAdapterInfo.environment.supportedEnvironments.some((env) => currentEnvironments.includes(env))) {\n    return false;\n  }\n  if (targetAdapterInfo.environment && !targetAdapterInfo.environment.supportedEnvironments.some((env) => currentEnvironments.includes(env))) {\n    return false;\n  }\n  return targetModuleCompatRule.requiresCapabilities.every((requiredCap) => targetAdapterInfo.capabilities.includes(requiredCap));\n}\n\n// packages/shared/dist/registry/registry.js\nfunction getPropertyByPath(obj, path) {\n  return path.split(\".\").reduce((currentObject, key) => {\n    return currentObject && typeof currentObject === \"object\" && Object.prototype.hasOwnProperty.call(currentObject, key) ? currentObject[key] : void 0;\n  }, obj);\n}\nvar UniversalRegistry = class {\n  constructor() {\n    __publicField(this, \"modules\", /* @__PURE__ */ new Map());\n    __publicField(this, \"adapters\", /* @__PURE__ */ new Map());\n    __publicField(this, \"compatibilityMatrices\", /* @__PURE__ */ new Map());\n    __publicField(this, \"interfaceShapes\", /* @__PURE__ */ new Map());\n  }\n  // ✅ ADD: The missing map\n  /**\n  * ✅ NEW: Register the shape of a convenience alias.\n  * This is called by modules (e.g., wallet/index.ts) to define their aliases.\n  * @param interfaceName The name of the alias (e.g., 'IEVMWallet').\n  * @param requiredCapabilities An array of base capability names it requires.\n  */\n  registerInterfaceShape(interfaceName, requiredCapabilities) {\n    this.interfaceShapes.set(interfaceName, requiredCapabilities);\n  }\n  /**\n   * ✅ NEW: Get the shape of a convenience alias.\n   * This is called by the validator to verify an adapter meets an interface's requirements.\n   */\n  getInterfaceShape(interfaceName) {\n    return this.interfaceShapes.get(interfaceName);\n  }\n  /**\n  * ✅ NEW: A modern replacement for findAdaptersWithFeature that uses our new architecture.\n  * Finds all adapters that have a specific capability.\n  */\n  findAdaptersWithCapability(capability) {\n    const result = [];\n    for (const moduleAdapters of this.adapters.values()) {\n      for (const metadata of moduleAdapters.values()) {\n        if (metadata.capabilities?.includes(capability)) {\n          result.push(metadata);\n        }\n      }\n    }\n    return result;\n  }\n  /**\n  * Get compatibility matrix for an adapter\n  */\n  getCompatibilityMatrix(moduleName, name, version) {\n    const moduleMatrices = this.compatibilityMatrices.get(moduleName);\n    if (!moduleMatrices)\n      return void 0;\n    const key = `${name}@${version}`;\n    return moduleMatrices.get(key);\n  }\n  /**\n  * Get latest version of an adapter\n  */\n  getLatestVersion(moduleName, name) {\n    const latest = this.getLatestAdapter(moduleName, name);\n    return latest?.version;\n  }\n  /**\n     * Register a compatibility matrix for an adapter\n     */\n  registerCompatibilityMatrix(moduleName, matrix) {\n    if (!this.compatibilityMatrices.has(moduleName)) {\n      this.compatibilityMatrices.set(moduleName, /* @__PURE__ */ new Map());\n    }\n    const moduleMatrices = this.compatibilityMatrices.get(moduleName);\n    const key = `${matrix.adapterName}@${matrix.version}`;\n    moduleMatrices.set(key, matrix);\n  }\n  /**\n   * Check compatibility between adapter versions\n   */\n  checkAdapterCompatibility(moduleName, name, versions) {\n    const report = {\n      compatible: true,\n      conflicts: [],\n      recommendations: [],\n      supportedVersions: []\n    };\n    const moduleAdapters = this.adapters.get(moduleName);\n    if (!moduleAdapters) {\n      report.compatible = false;\n      report.conflicts.push({\n        type: \"version\",\n        severity: \"error\",\n        description: `Module '${moduleName}' not found`,\n        affectedVersions: versions\n      });\n      return report;\n    }\n    for (const version of versions) {\n      const adapter = this.getAdapter(moduleName, name, version);\n      if (!adapter) {\n        report.compatible = false;\n        report.conflicts.push({\n          type: \"version\",\n          severity: \"error\",\n          description: `Adapter '${name}' version '${version}' not found`,\n          affectedVersions: [version]\n        });\n        continue;\n      }\n      report.supportedVersions.push(version);\n      const matrix = this.getCompatibilityMatrix(moduleName, name, version);\n      if (matrix) {\n        for (const otherVersion of versions) {\n          if (version !== otherVersion) {\n            const breakingChange = matrix.breakingChanges.find((bc) => bc.fromVersion === otherVersion || bc.toVersion === otherVersion);\n            if (breakingChange) {\n              report.conflicts.push({\n                type: \"breaking-change\",\n                severity: \"warning\",\n                description: `Breaking changes between ${breakingChange.fromVersion} and ${breakingChange.toVersion}: ${breakingChange.changes.join(\", \")}`,\n                affectedVersions: [breakingChange.fromVersion, breakingChange.toVersion],\n                suggestedAction: breakingChange.migrationPath\n              });\n            }\n          }\n        }\n      }\n    }\n    if (report.conflicts.length === 0) {\n      report.recommendations.push(\"All specified versions are compatible\");\n    } else {\n      const latestVersion = this.getLatestVersion(moduleName, name);\n      if (latestVersion) {\n        report.recommendations.push(`Consider using latest version: ${latestVersion}`);\n      }\n    }\n    return report;\n  }\n  /**\n  * Get adapters compatible with a specific adapter instance\n  */\n  getCompatibleAdapters(currentAdapter, targetModuleName) {\n    const compatibleAdapters = [];\n    const modulesToCheck = targetModuleName ? [targetModuleName] : Array.from(this.adapters.keys());\n    for (const moduleName of modulesToCheck) {\n      if (moduleName === currentAdapter.moduleName)\n        continue;\n      const moduleAdapters = this.adapters.get(moduleName);\n      if (!moduleAdapters)\n        continue;\n      for (const [, targetAdapterMetadata] of moduleAdapters) {\n        const isCompatible = checkCrossPackageCompatibility(currentAdapter.moduleName, currentAdapter.name, currentAdapter.version, targetAdapterMetadata.module, targetAdapterMetadata.name, targetAdapterMetadata.version);\n        if (isCompatible) {\n          compatibleAdapters.push(targetAdapterMetadata);\n        }\n      }\n    }\n    return compatibleAdapters;\n  }\n  /**\n   * Batch register adapters with atomic rollback\n   */\n  registerAdapters(adapters) {\n    const originalState = new Map(this.adapters);\n    try {\n      for (const adapter of adapters) {\n        this.registerAdapter(adapter.module, adapter);\n      }\n    } catch (error) {\n      this.adapters = originalState;\n      throw new Error(`Batch registration failed: ${error}. State rolled back.`);\n    }\n  }\n  /**\n   * Register a module in the registry\n   */\n  registerModule(metadata) {\n    this.modules.set(metadata.name, metadata);\n    if (!this.adapters.has(metadata.name)) {\n      this.adapters.set(metadata.name, /* @__PURE__ */ new Map());\n    }\n  }\n  /**\n   * Register an adapter for a specific module\n   */\n  registerAdapter(moduleName, metadata) {\n    if (!this.modules.has(moduleName)) {\n      const moduleMetadata = {\n        name: moduleName,\n        version: metadata.version\n        // Use adapter's version as default module version\n      };\n      this.registerModule(moduleMetadata);\n    }\n    const moduleAdapters = this.adapters.get(moduleName);\n    if (!moduleAdapters) {\n      throw new Error(`Module ${moduleName} not properly initialized in registry`);\n    }\n    const adapterKey = `${metadata.name}@${metadata.version}`;\n    moduleAdapters.set(adapterKey, metadata);\n  }\n  /**\n   * Get an adapter by module and adapter name\n   */\n  getAdapter(moduleName, name, version) {\n    const moduleAdapters = this.adapters.get(moduleName);\n    if (!moduleAdapters)\n      return void 0;\n    const adapterKey = `${name}@${version}`;\n    return moduleAdapters.get(adapterKey);\n  }\n  /**\n   * Get the latest version of an adapter by name\n   */\n  getLatestAdapter(moduleName, name) {\n    const moduleAdapters = this.adapters.get(moduleName);\n    if (!moduleAdapters)\n      return void 0;\n    const matchingAdapters = [];\n    for (const [, metadata] of moduleAdapters.entries()) {\n      if (metadata.name === name) {\n        matchingAdapters.push(metadata);\n      }\n    }\n    if (matchingAdapters.length === 0)\n      return void 0;\n    matchingAdapters.sort((a, b) => b.version.localeCompare(a.version));\n    return matchingAdapters[0];\n  }\n  /**\n   * Get all adapters for a module\n   */\n  getModuleAdapters(moduleName) {\n    const moduleAdapters = this.adapters.get(moduleName);\n    if (!moduleAdapters)\n      return [];\n    return Array.from(moduleAdapters.values());\n  }\n  /**\n   * Get all available versions of a specific adapter\n   */\n  getAdapterVersions(moduleName, name) {\n    const moduleAdapters = this.adapters.get(moduleName);\n    if (!moduleAdapters)\n      return [];\n    const versions = [];\n    for (const [, metadata] of moduleAdapters.entries()) {\n      if (metadata.name === name) {\n        versions.push(metadata.version);\n      }\n    }\n    return versions.sort((a, b) => b.localeCompare(a));\n  }\n  /**\n   * Get all modules\n   */\n  getAllModules() {\n    return Array.from(this.modules.values());\n  }\n  /**\n     * Get environment requirements for an adapter\n     */\n  getEnvironmentRequirements(moduleName, name, version) {\n    const adapter = this.getAdapter(moduleName, name, version);\n    return adapter?.environment;\n  }\n  /**\n  * Check if an adapter supports a specific environment\n  */\n  supportsEnvironment(moduleName, name, version, environment) {\n    const adapter = this.getAdapter(moduleName, name, version);\n    if (!adapter || !adapter.environment)\n      return true;\n    return adapter.environment.supportedEnvironments.includes(environment);\n  }\n  /**\n   * Get adapters that support a specific environment\n   */\n  getAdaptersByEnvironment(moduleName, environment) {\n    const moduleAdapters = this.adapters.get(moduleName);\n    if (!moduleAdapters)\n      return [];\n    const result = [];\n    for (const [, metadata] of moduleAdapters.entries()) {\n      if (!metadata.environment || metadata.environment.supportedEnvironments.includes(environment)) {\n        result.push(metadata);\n      }\n    }\n    return result;\n  }\n};\nvar registry = new UniversalRegistry();\n\n// packages/shared/dist/helpers/network.js\n\nvar staticChainList = [\n  {\n    name: \"Ethereum Mainnet\",\n    chainId: 1,\n    shortName: \"eth\",\n    nativeCurrency: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\n    rpc: [\n      \"https://eth.llamarpc.com\",\n      \"https://ethereum-rpc.publicnode.com\",\n      \"https://1rpc.io/eth\",\n      \"https://cloudflare-eth.com\"\n    ],\n    blockExplorerUrl: \"https://etherscan.io\",\n    isTestnet: false,\n    isStatic: true\n  },\n  {\n    name: \"Polygon Mainnet\",\n    chainId: 137,\n    shortName: \"matic\",\n    nativeCurrency: { name: \"MATIC\", symbol: \"MATIC\", decimals: 18 },\n    rpc: [\n      \"https://polygon-rpc.com\",\n      \"https://polygon.llamarpc.com\",\n      \"https://polygon.drpc.org\"\n    ],\n    blockExplorerUrl: \"https://polygonscan.com\",\n    isTestnet: false,\n    isStatic: true\n  },\n  {\n    name: \"Optimism\",\n    chainId: 10,\n    shortName: \"oeth\",\n    nativeCurrency: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\n    rpc: [\n      \"https://mainnet.optimism.io\",\n      \"https://optimism.llamarpc.com\",\n      \"https://optimism.publicnode.com\"\n    ],\n    blockExplorerUrl: \"https://optimistic.etherscan.io\",\n    isTestnet: false,\n    isStatic: true\n  },\n  {\n    name: \"Arbitrum One\",\n    chainId: 42161,\n    shortName: \"arb1\",\n    nativeCurrency: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\n    rpc: [\n      \"https://arb1.arbitrum.io/rpc\",\n      \"https://arbitrum.llamarpc.com\",\n      \"https://arbitrum-one.public.blastapi.io\"\n    ],\n    blockExplorerUrl: \"https://arbiscan.io\",\n    isTestnet: false,\n    isStatic: true\n  },\n  {\n    name: \"Holesky\",\n    chainId: 17e3,\n    shortName: \"holesky\",\n    nativeCurrency: { name: \"Holesky Ether\", symbol: \"ETH\", decimals: 18 },\n    rpc: [\"https://ethereum-holesky.publicnode.com\"],\n    blockExplorerUrl: \"https://holesky.etherscan.io\",\n    isTestnet: true,\n    isStatic: true\n  },\n  {\n    name: \"Sepolia\",\n    chainId: 11155111,\n    shortName: \"sep\",\n    nativeCurrency: { name: \"Sepolia Ether\", symbol: \"ETH\", decimals: 18 },\n    rpc: [\n      \"https://rpc.sepolia.org\",\n      \"https://ethereum-sepolia-rpc.publicnode.com\",\n      \"https://endpoints.omniatech.io/v1/eth/sepolia/public\",\n      \"https://eth-sepolia.public.blastapi.io\"\n    ],\n    blockExplorerUrl: \"https://sepolia.etherscan.io\",\n    isTestnet: true,\n    isStatic: true\n  }\n];\nvar _NetworkHelper = class _NetworkHelper {\n  constructor() {\n    __publicField(this, \"networkCache\", {});\n    __publicField(this, \"initializationPromise\", null);\n    for (const chain of staticChainList) {\n      this.addChainToCache(chain);\n    }\n  }\n  static getInstance() {\n    if (!_NetworkHelper.instance) {\n      _NetworkHelper.instance = new _NetworkHelper();\n    }\n    return _NetworkHelper.instance;\n  }\n  /**\n   * Ensures that the initial loading of networks has attempted to complete.\n   */\n  async ensureInitialized() {\n    if (!this.initializationPromise) {\n      this.initializationPromise = this.fetchAndMergeExternalChainList();\n    }\n    await this.initializationPromise;\n  }\n  async fetchAndMergeExternalChainList() {\n    try {\n      const response = await fetch(\"https://chainid.network/chains.json\");\n      if (!response.ok) {\n        throw new Error(`Failed to fetch chain list: ${response.statusText}`);\n      }\n      const externalChains = await response.json();\n      for (const chain of externalChains) {\n        const normalizedId = _NetworkHelper.normalizeChainId(chain.chainId);\n        if (!this.networkCache[normalizedId] || !this.networkCache[normalizedId].isStatic) {\n          this.addChainToCache(chain, false);\n        }\n      }\n    } catch (error) {\n      console.warn(\"[NetworkHelper] Could not fetch external chain list. Using embedded static list only.\", error);\n    }\n  }\n  addChainToCache(chain, isStatic = true) {\n    if (!chain || !chain.chainId)\n      return;\n    const normalizedId = _NetworkHelper.normalizeChainId(chain.chainId);\n    const rpcUrls = (chain.rpc || []).filter((url) => url && url.startsWith(\"http\") && !url.includes(\"${\"));\n    if (rpcUrls.length === 0 && !isStatic)\n      return;\n    const config = {\n      name: chain.name,\n      chainId: normalizedId,\n      shortName: chain.shortName,\n      nativeCurrency: chain.nativeCurrency,\n      rpcUrls,\n      blockExplorerUrl: chain.explorers?.[0]?.url || chain.blockExplorerUrl,\n      // isTestnet: chain.isTestnet ?? (chain.networkId !== 1), // Simple heuristic\n      isStatic,\n      displayName: chain.name,\n      decimals: chain.nativeCurrency?.decimals || 18,\n      ticker: chain.nativeCurrency?.symbol,\n      tickerName: chain.nativeCurrency?.name\n    };\n    this.networkCache[normalizedId] = config;\n    this.networkCache[chain.chainId.toString()] = config;\n    if (chain.shortName) {\n      this.networkCache[chain.shortName.toLowerCase()] = config;\n    }\n    if (chain.name) {\n      this.networkCache[chain.name.toLowerCase().replace(/\\s+/g, \"\")] = config;\n    }\n  }\n  async getNetworkConfig(networkIdentifier, preferredRpcUrls = [], useOnlyPreferredRpc = false) {\n    await this.ensureInitialized();\n    const identifierStr = String(networkIdentifier).toLowerCase().replace(/\\s+/g, \"\");\n    const baseConfig = this.networkCache[identifierStr];\n    if (!baseConfig || !baseConfig.chainId) {\n      return null;\n    }\n    const uniquePreferred = [...new Set(preferredRpcUrls.filter((url) => url))];\n    const baseRpcUrls = Array.isArray(baseConfig.rpcUrls) ? baseConfig.rpcUrls : [];\n    let urlsToTest = [];\n    if (useOnlyPreferredRpc) {\n      if (uniquePreferred.length === 0) {\n        console.warn(`[NetworkHelper] getNetworkConfig called with useOnlyPreferredRpc=true but no preferredRpcUrls were provided for ${networkIdentifier}.`);\n        return null;\n      }\n      urlsToTest = uniquePreferred;\n    } else {\n      urlsToTest = [...uniquePreferred, ...baseRpcUrls.filter((url) => !uniquePreferred.includes(url))];\n    }\n    if (urlsToTest.length === 0) {\n      return null;\n    }\n    const workingUrl = await this.findFirstWorkingRpc(urlsToTest, baseConfig.chainId);\n    if (!workingUrl) {\n      return null;\n    }\n    if (!useOnlyPreferredRpc && uniquePreferred.length > 0 && !uniquePreferred.includes(workingUrl)) {\n      console.warn(`[NetworkHelper] None of the preferred RPCs worked for ${baseConfig.name}. Using a public RPC: ${workingUrl}. For critical operations, ensure your preferred RPCs are operational.`);\n    }\n    const orderedRpcUrls = [workingUrl, ...urlsToTest.filter((url) => url !== workingUrl)];\n    return {\n      chainId: baseConfig.chainId,\n      name: baseConfig.name,\n      displayName: baseConfig.displayName || baseConfig.name,\n      rpcUrls: orderedRpcUrls,\n      decimals: baseConfig.decimals,\n      blockExplorerUrl: baseConfig.blockExplorerUrl,\n      ticker: baseConfig.ticker,\n      tickerName: baseConfig.tickerName,\n      shortName: baseConfig.shortName\n    };\n  }\n  async testRpcConnection(url, expectedChainId, timeoutMs = 5e3) {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), timeoutMs);\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ jsonrpc: \"2.0\", method: \"eth_chainId\", params: [], id: 1 }),\n        signal: controller.signal\n      });\n      if (!response.ok) {\n        return false;\n      }\n      const data = await response.json();\n      if (data.error) {\n        return false;\n      }\n      const receivedChainId = _NetworkHelper.normalizeChainId(data.result);\n      const expectedNormalized = _NetworkHelper.normalizeChainId(expectedChainId);\n      if (receivedChainId !== expectedNormalized) {\n        console.warn(`[testRpcConnection] Chain ID mismatch for ${url}: Got ${receivedChainId}, Expected ${expectedNormalized}`);\n        return false;\n      }\n      return true;\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n      } else {\n      }\n      return false;\n    } finally {\n      clearTimeout(timeout);\n    }\n  }\n  async findFirstWorkingRpc(urls, expectedChainId, timeoutMs = 3e3) {\n    for (const url of urls) {\n      if (await this.testRpcConnection(url, expectedChainId, timeoutMs)) {\n        return url;\n      }\n    }\n    return null;\n  }\n  async getProvider(input, preferredRpcUrls = [], chainId) {\n    if (input instanceof ethers__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider || input instanceof ethers__WEBPACK_IMPORTED_MODULE_1__.BrowserProvider) {\n      return input;\n    }\n    if (input && typeof input.request === \"function\") {\n      return new ethers__WEBPACK_IMPORTED_MODULE_1__.BrowserProvider(input, \"any\");\n    }\n    if (typeof input === \"string\") {\n      return new ethers__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(input);\n    }\n    if (input && typeof input === \"object\" && Array.isArray(input.rpcUrls) && input.rpcUrls.length > 0) {\n      return new ethers__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(input.rpcUrls[0]);\n    }\n    if (!chainId) {\n      throw new AdapterError(\"No chainId available to pick a public RPC. Supply your own in options.provider.\", { code: WalletErrorCode.InvalidInput, methodName: \"getProvider\" });\n    }\n    const net = await this.getNetworkConfig(chainId, preferredRpcUrls);\n    if (!net || !net.rpcUrls || net.rpcUrls.length === 0) {\n      throw new AdapterError(`No RPC could be reached for chainId=${chainId}. Please supply at least one working URL in options.provider.rpcUrls.`, { code: WalletErrorCode.ConnectionFailed, methodName: \"getProvider\" });\n    }\n    return new ethers__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(net.rpcUrls[0]);\n  }\n  static normalizeChainId(chainId) {\n    if (typeof chainId === \"number\") {\n      return `0x${chainId.toString(16).toLowerCase()}`;\n    }\n    if (typeof chainId === \"string\") {\n      if (chainId.toLowerCase().startsWith(\"0x\")) {\n        return chainId.toLowerCase();\n      }\n      const num = parseInt(chainId, 10);\n      if (!isNaN(num)) {\n        return `0x${num.toString(16).toLowerCase()}`;\n      }\n    }\n    throw new AdapterError(`Invalid chainId format: ${chainId}`, { code: WalletErrorCode.InvalidInput });\n  }\n  static assertConfigIsValid(config, context = \"NetworkConfiguration\") {\n    if (!config) {\n      throw new Error(`[NetworkHelper] ${context}: Configuration is null or undefined.`);\n    }\n    if (!config.chainId) {\n      throw new Error(`[NetworkHelper] ${context} (Name: ${config.name || \"N/A\"}): Missing chainId.`);\n    }\n    if (!config.rpcUrls || config.rpcUrls.length === 0) {\n      throw new Error(`[NetworkHelper] ${context} (Name: ${config.name || \"N/A\"}, ChainID: ${config.chainId}): Missing or empty rpcUrls.`);\n    }\n    return config;\n  }\n  static filterValidConfigs(configs) {\n    const isValid = (config) => !!config && !!config.chainId && Array.isArray(config.rpcUrls) && config.rpcUrls.length > 0;\n    if (Array.isArray(configs)) {\n      return configs.filter(isValid);\n    } else {\n      const result = {};\n      for (const key in configs) {\n        if (Object.prototype.hasOwnProperty.call(configs, key)) {\n          const config = configs[key];\n          if (isValid(config)) {\n            result[key] = config;\n          }\n        }\n      }\n      return result;\n    }\n  }\n  validatePrivateRpcsForChains(chainIds, walletRpcs) {\n    const missingChains = [];\n    for (const chainId of chainIds) {\n      const normalizedId = _NetworkHelper.normalizeChainId(chainId);\n      const decimalId = parseInt(normalizedId, 16).toString();\n      const hasRpcs = walletRpcs[normalizedId]?.length > 0 || walletRpcs[decimalId]?.length > 0;\n      if (!hasRpcs) {\n        missingChains.push(decimalId);\n      }\n    }\n    return {\n      hasAllPrivateRpcs: missingChains.length === 0,\n      missingChains\n    };\n  }\n};\n__publicField(_NetworkHelper, \"instance\");\nvar NetworkHelper = _NetworkHelper;\n\n// packages/shared/dist/helpers/keys.js\n\nvar PrivateKeyHelper = class {\n  /**\n   * Generates a new random EVM-compatible private key.\n   * @returns A string representing the private key (hexadecimal, 0x-prefixed).\n   */\n  generatePrivateKey() {\n    try {\n      const wallet = ethers__WEBPACK_IMPORTED_MODULE_2__.Wallet.createRandom();\n      return wallet.privateKey;\n    } catch (error) {\n      throw new Error(`[PrivateKeyHelper.generatePrivateKey] Failed: ${error.message}`);\n    }\n  }\n  /**\n   * Encrypts an EVM private key into a JSON keystore (EIP-2335 format) using a password.\n   * @param privateKey The EVM private key string (hexadecimal, 0x-prefixed).\n   * @param password The password for encryption.\n   * @returns A promise resolving to the JSON keystore string.\n   * @throws Error if the private key is invalid or encryption fails.\n   */\n  async encryptPrivateKey(privateKey, password) {\n    if (!this.isValidEvmPrivateKey(privateKey)) {\n      throw new Error(\"[PrivateKeyHelper.encryptPrivateKey] Invalid private key format.\");\n    }\n    try {\n      const wallet = new ethers__WEBPACK_IMPORTED_MODULE_2__.Wallet(privateKey);\n      const jsonKeystore = await wallet.encrypt(password);\n      return jsonKeystore;\n    } catch (error) {\n      throw new Error(`[PrivateKeyHelper.encryptPrivateKey] Encryption failed: ${error.message}`);\n    }\n  }\n  /**\n   * Decrypts an EVM JSON keystore using a password.\n   * @param encryptedJsonKeystore The JSON keystore string.\n   * @param password The password for decryption.\n   * @returns A promise resolving to the decrypted EVM private key string.\n   * @throws Error if decryption fails (e.g., invalid keystore, incorrect password).\n   */\n  async decryptPrivateKey(encryptedJsonKeystore, password) {\n    try {\n      const wallet = await ethers__WEBPACK_IMPORTED_MODULE_2__.Wallet.fromEncryptedJson(encryptedJsonKeystore, password);\n      return wallet.privateKey;\n    } catch (error) {\n      throw new Error(`[PrivateKeyHelper.decryptPrivateKey] Decryption failed: ${error.message}`);\n    }\n  }\n  /**\n   * Derives the public Ethereum address from an EVM private key.\n   * @param privateKey The EVM private key string (hexadecimal, 0x-prefixed).\n   * @returns The corresponding public address string.\n   * @throws Error if the private key is invalid.\n   */\n  getAddressFromPrivateKey(privateKey) {\n    if (!this.isValidEvmPrivateKey(privateKey)) {\n      throw new Error(\"[PrivateKeyHelper.getAddressFromPrivateKey] Invalid private key format.\");\n    }\n    try {\n      const wallet = new ethers__WEBPACK_IMPORTED_MODULE_2__.Wallet(privateKey);\n      return wallet.address;\n    } catch (error) {\n      throw new Error(`[PrivateKeyHelper.getAddressFromPrivateKey] Failed to derive address: ${error.message}`);\n    }\n  }\n  /**\n  * Generates a new random BIP39 mnemonic phrase.\n  * Uses ethers.Wallet.createRandom() for robust generation.\n  * @returns A randomly generated mnemonic phrase (typically 12 words).\n  * @throws Error if mnemonic generation fails.\n  */\n  generateMnemonic() {\n    try {\n      const randomWallet = ethers__WEBPACK_IMPORTED_MODULE_2__.Wallet.createRandom();\n      if (!randomWallet.mnemonic || !randomWallet.mnemonic.phrase) {\n        throw new Error(\"Failed to generate mnemonic phrase from random wallet.\");\n      }\n      return randomWallet.mnemonic.phrase;\n    } catch (error) {\n      const wrappedError = new Error(`[PrivateKeyHelper.generateMnemonic] Failed during mnemonic generation: ${error.message}`);\n      if (error.stack) {\n        wrappedError.stack = error.stack;\n      }\n      wrappedError.cause = error;\n      throw wrappedError;\n    }\n  }\n  /**\n   * Derives an EVM private key from a mnemonic phrase and an optional HD path.\n   * @param mnemonic The BIP-39 mnemonic phrase.\n   * @param path The HD path (e.g., \"m/44'/60'/0'/0/0\"). Defaults to the standard Ethereum path.\n   * @returns The derived private key string.\n   * @throws Error if the mnemonic is invalid or derivation fails.\n   */\n  getPrivateKeyFromMnemonic(mnemonic, path) {\n    const hdPath = path || \"m/44'/60'/0'/0/0\";\n    try {\n      if (!ethers__WEBPACK_IMPORTED_MODULE_3__.Mnemonic.isValidMnemonic(mnemonic)) {\n        throw new Error(\"Invalid mnemonic phrase provided.\");\n      }\n      const mnemonicInstance = ethers__WEBPACK_IMPORTED_MODULE_3__.Mnemonic.fromPhrase(mnemonic);\n      const hdNode = ethers__WEBPACK_IMPORTED_MODULE_4__.HDNodeWallet.fromMnemonic(mnemonicInstance, hdPath);\n      return hdNode.privateKey;\n    } catch (error) {\n      throw new Error(`[PrivateKeyHelper.getPrivateKeyFromMnemonic] Failed: ${error.message}`);\n    }\n  }\n  /**\n   * Validates if the given string is a plausible EVM private key format.\n   * (Basic check for 0x prefix and 64 hex characters).\n   * @param privateKey The string to validate.\n   * @returns True if it matches the basic format, false otherwise.\n   */\n  isValidEvmPrivateKey(privateKey) {\n    return typeof privateKey === \"string\" && (0,ethers__WEBPACK_IMPORTED_MODULE_5__.isHexString)(privateKey, 32);\n  }\n};\n\n// packages/shared/dist/helpers/validator.js\nfunction validateAdapterParameters(args) {\n  const { name, version, params, adapterInfo, registry: registry2, factoryMethodName } = args;\n  const { expectedInterface } = params;\n  console.log(\"Validator - arguments, \", args);\n  if (expectedInterface) {\n    const requiredCapabilities = registry2.getInterfaceShape(expectedInterface);\n    if (!requiredCapabilities) {\n      throw new AdapterError(`Unknown interface shape requested: '${expectedInterface}'. Ensure it is registered in the registry.`, { code: \"INTERNAL_ERROR\" });\n    }\n    const adapterCapabilities = adapterInfo.capabilities || [];\n    for (const req of requiredCapabilities) {\n      if (!adapterCapabilities.includes(req)) {\n        throw new AdapterError(`Adapter '${name}@${version}' does not fully implement the '${expectedInterface}' interface. Missing capability: '${req}'.`, { code: \"INCOMPATIBLE_ADAPTER\", methodName: factoryMethodName });\n      }\n    }\n  }\n  if (adapterInfo.requirements && adapterInfo.requirements.length > 0) {\n    console.log(\"Validator - adapterInfo, \", adapterInfo);\n    for (const req of adapterInfo.requirements) {\n      const value = getPropertyByPath(params, req.path);\n      if (value === void 0 && !req.allowUndefined) {\n        const errorMessage = req.message || `Required option '${req.path}' is missing for adapter '${name}'.`;\n        throw new AdapterError(errorMessage, {\n          methodName: factoryMethodName,\n          code: \"MISSING_ADAPTER_REQUIREMENT\",\n          details: { path: req.path, message: req.message }\n        });\n      }\n      if (req.type && value !== void 0) {\n        const valueType = Array.isArray(value) ? \"array\" : typeof value;\n        if (valueType !== req.type) {\n          const errorMessage = req.message || `Required option '${req.path}' for adapter '${name}' must be of type '${req.type}', but received '${valueType}'.`;\n          throw new AdapterError(errorMessage, {\n            methodName: factoryMethodName,\n            code: \"INVALID_ADAPTER_REQUIREMENT_TYPE\",\n            details: { path: req.path, message: req.message, expectedType: req.type, actualType: valueType }\n          });\n        }\n      }\n    }\n  }\n}\n\n// packages/shared/dist/helpers/devtool.js\nfunction analyzeJoiSchema(schema, basePath) {\n  console.log(`\\u{1F52C} [analyzeJoiSchema] Analyzing schema at path: ${basePath}`);\n  const requirements = [];\n  try {\n    const description = schema.describe();\n    console.log(`\\u{1F4CB} [analyzeJoiSchema] Schema description type:`, description.type);\n    console.log(`\\u{1F4CB} [analyzeJoiSchema] Schema keys:`, description.keys ? Object.keys(description.keys) : \"NO KEYS\");\n    if (description.type === \"object\" && description.keys) {\n      console.log(`\\u2705 [analyzeJoiSchema] Processing object schema with ${Object.keys(description.keys).length} keys`);\n      for (const [key, fieldDesc] of Object.entries(description.keys)) {\n        console.log(`\\u{1F511} [analyzeJoiSchema] Processing field: ${key}`);\n        console.log(`\\u{1F4DD} [analyzeJoiSchema] Field description:`, fieldDesc);\n        const fieldSchema = fieldDesc;\n        const fieldPath = `${basePath}.${key}`;\n        const hasPresenceFlag = fieldSchema.flags?.presence;\n        const isRequired = hasPresenceFlag === \"required\" || !hasPresenceFlag && !fieldSchema.flags?.optional;\n        let fieldType = fieldSchema.type || \"any\";\n        if (fieldType === \"alternatives\" && fieldSchema.matches) {\n          fieldType = fieldSchema.matches[0]?.schema?.type || \"any\";\n        }\n        let message = fieldSchema.flags?.description || \"\";\n        if (!message) {\n          const mandatory = isRequired ? \"required\" : \"optional\";\n          message = `${key} is ${mandatory} and must be of type: ${fieldType}`;\n        }\n        console.log(`\\u{1F4CA} [analyzeJoiSchema] Field ${key}: type=${fieldType}, required=${isRequired}, message=\"${message}\"`);\n        requirements.push({\n          path: fieldPath,\n          type: fieldType,\n          allowUndefined: !isRequired,\n          message\n        });\n        if (fieldSchema.type === \"object\" && fieldSchema.keys) {\n          console.log(`\\u{1F504} [analyzeJoiSchema] Recursing into nested object: ${key}`);\n          const nestedRequirements = analyzeJoiSchemaFromDescription(fieldSchema, fieldPath);\n          requirements.push(...nestedRequirements);\n        }\n      }\n    } else {\n      console.warn(`\\u26A0\\uFE0F [analyzeJoiSchema] Expected object schema but got type: ${description.type}`);\n    }\n  } catch (error) {\n    console.error(`\\u274C [analyzeJoiSchema] Failed to analyze schema at ${basePath}:`, error);\n  }\n  console.log(`\\u{1F4CA} [analyzeJoiSchema] Generated ${requirements.length} requirements for ${basePath}`);\n  return requirements;\n}\nfunction analyzeJoiSchemaFromDescription(description, basePath) {\n  const requirements = [];\n  if (description.keys) {\n    for (const [key, fieldDesc] of Object.entries(description.keys)) {\n      const fieldSchema = fieldDesc;\n      const fieldPath = `${basePath}.${key}`;\n      const isRequired = fieldSchema.flags?.presence === \"required\" || !fieldSchema.flags?.presence && !fieldSchema.flags?.optional && !fieldSchema.flags?.default;\n      let fieldType = fieldSchema.type || \"any\";\n      if (fieldType === \"alternatives\" && fieldSchema.matches) {\n        fieldType = fieldSchema.matches[0]?.schema?.type || \"any\";\n      }\n      let message = fieldSchema.flags?.description || \"\";\n      if (!message) {\n        const mandatory = isRequired ? \"required\" : \"optional\";\n        message = `${key} is ${mandatory} and must be of type: ${fieldType}`;\n      }\n      requirements.push({\n        path: fieldPath,\n        type: fieldType,\n        allowUndefined: !isRequired,\n        message\n      });\n      if (fieldSchema.type === \"object\" && fieldSchema.keys) {\n        const nestedRequirements = analyzeJoiSchemaFromDescription(fieldSchema, fieldPath);\n        requirements.push(...nestedRequirements);\n      }\n    }\n  }\n  return requirements;\n}\nfunction generateFallbackRequirements(adapterName) {\n  console.log(`[getRequirements] No requirements found for ${adapterName} interface - using fallback.`);\n  console.warn(`[getRequirements] Using fallback requirements for ${adapterName}`);\n  if (adapterName === \"ethers\") {\n    return [\n      {\n        path: \"options.privateKey\",\n        type: \"string\",\n        allowUndefined: true,\n        message: \"Private key for wallet (generates random if not provided)\"\n      },\n      {\n        path: \"options.provider\",\n        type: \"object\",\n        allowUndefined: true,\n        message: \"Optional provider configuration\"\n      }\n    ];\n  }\n  if (adapterName === \"web3auth\") {\n    return [\n      {\n        path: \"options.web3authConfig\",\n        type: \"object\",\n        allowUndefined: false,\n        message: \"Web3Auth configuration object is required\"\n      },\n      {\n        path: \"options.web3authConfig.clientId\",\n        type: \"string\",\n        allowUndefined: false,\n        message: \"Your Web3Auth Client ID is required\"\n      }\n    ];\n  }\n  return [];\n}\nfunction analyzeMethodSignature(method, methodName) {\n  try {\n    const funcString = method.toString();\n    const paramMatch = funcString.match(/\\(([^)]*)\\)/);\n    const paramString = paramMatch ? paramMatch[1].trim() : \"\";\n    const parameters = paramString ? paramString.split(\",\").map((param) => {\n      const cleanParam = param.trim();\n      const name = cleanParam.split(/[=:]/)[0].trim().replace(/[{}[\\]]/g, \"\");\n      return {\n        name: name || \"param\",\n        type: \"any\",\n        // We can't reliably extract types from compiled JS\n        optional: cleanParam.includes(\"=\") || cleanParam.includes(\"?\")\n      };\n    }) : [];\n    const isAsync = funcString.includes(\"async \") || funcString.includes(\"Promise\") || funcString.includes(\"await \");\n    let returnType = \"any\";\n    if (methodName.startsWith(\"is\") || methodName.startsWith(\"has\")) {\n      returnType = \"boolean\";\n    } else if (methodName === \"initialize\" || methodName === \"disconnect\") {\n      returnType = \"void\";\n    }\n    if (isAsync && !returnType.includes(\"Promise\")) {\n      returnType = returnType === \"void\" ? \"Promise<void>\" : `Promise<${returnType}>`;\n    }\n    console.log(`\\u2705 [analyzeMethodSignature] ${methodName}(${parameters.length} params) -> ${returnType}, async: ${isAsync}`);\n    return {\n      name: methodName,\n      parameters,\n      returnType,\n      isAsync\n    };\n  } catch (error) {\n    console.warn(`\\u274C [analyzeMethodSignature] Failed to analyze ${methodName}:`, error);\n    return {\n      name: methodName,\n      parameters: [],\n      returnType: \"any\",\n      isAsync: false\n    };\n  }\n}\nfunction getEnvironments(adapterName, supportedEnvs, customLimitations, customSecurityNotes) {\n  const requirements = {\n    supportedEnvironments: [...supportedEnvs],\n    limitations: [...customLimitations || []],\n    securityNotes: [...customSecurityNotes || []]\n  };\n  for (const env of supportedEnvs) {\n    switch (env) {\n      case RuntimeEnvironment.BROWSER:\n        requirements.limitations.push(\"Requires browser environment with window and document objects\", \"Cannot be used in Node.js server environments\", \"May require user interaction for authentication flows\");\n        requirements.securityNotes.push(\"Ensure secure handling of private keys in browser environment\", \"Consider using hardware wallets for enhanced security\");\n        break;\n      case RuntimeEnvironment.SERVER:\n        requirements.limitations.push(\"Requires Node.js server environment\", \"Cannot be used in browser environments\");\n        requirements.securityNotes.push(\"Server environments provide better security for sensitive operations\", \"Ensure proper private key management and storage\");\n        break;\n    }\n  }\n  requirements.securityNotes.push(`${adapterName} adapter follows standard security practices`);\n  requirements.limitations = [...new Set(requirements.limitations)];\n  requirements.securityNotes = [...new Set(requirements.securityNotes)];\n  return requirements;\n}\nfunction getFeatures(adapterClass) {\n  if (!adapterClass || typeof adapterClass !== \"function\") {\n    console.warn(`[getFeatures] Invalid adapter class provided:`, typeof adapterClass);\n    return [];\n  }\n  console.log(`\\u{1F527} [getFeatures] Analyzing ${adapterClass.name} for method signatures by walking prototype chain.`);\n  const signatures = [];\n  const seenMethods = /* @__PURE__ */ new Set();\n  let currentProto = adapterClass.prototype;\n  while (currentProto && currentProto !== Object.prototype) {\n    const methodNames = Object.getOwnPropertyNames(currentProto).filter((name) => {\n      return name !== \"constructor\" && !name.startsWith(\"_\") && !seenMethods.has(name) && typeof currentProto[name] === \"function\";\n    });\n    console.log(`\\u{1F50D} [getFeatures] Found ${methodNames.length} methods on ${currentProto.constructor.name}:`, methodNames);\n    for (const methodName of methodNames) {\n      seenMethods.add(methodName);\n      const method = currentProto[methodName];\n      const signature = analyzeMethodSignature(method, methodName);\n      signatures.push(signature);\n    }\n    currentProto = Object.getPrototypeOf(currentProto);\n  }\n  console.log(`\\u2705 [getFeatures] Generated ${signatures.length} total method signatures for ${adapterClass.name}`);\n  return signatures;\n}\nfunction getRequirements(joiSchema, adapterName) {\n  console.log(`\\u{1F50D} [getRequirements] Starting analysis for ${adapterName}`);\n  if (adapterName.toLowerCase() === \"ethers\") {\n    console.log(`[getRequirements] Using fallback requirements for ${adapterName}`);\n    return generateFallbackRequirements(adapterName);\n  }\n  if (typeof window !== \"undefined\") {\n    console.log(`\\u{1F310} [getRequirements] Browser environment - using fallback for ${adapterName}`);\n    return generateFallbackRequirements(adapterName);\n  }\n  if (joiSchema && typeof joiSchema.describe === \"function\") {\n    try {\n      return analyzeJoiSchema(joiSchema, \"options\");\n    } catch (error) {\n      console.error(`\\u274C [getRequirements] JOI validation failed:`, error);\n    }\n  }\n  return generateFallbackRequirements(adapterName);\n}\n\n// packages/wallet/dist/adapters/ethers/ethersWallet.js\n\n\n// packages/wallet/dist/types/enums/index.js\nvar WalletEvent;\n(function(WalletEvent2) {\n  WalletEvent2[\"connect\"] = \"connect\";\n  WalletEvent2[\"disconnect\"] = \"disconnect\";\n  WalletEvent2[\"accountsChanged\"] = \"accountsChanged\";\n  WalletEvent2[\"chainChanged\"] = \"chainChanged\";\n  WalletEvent2[\"balanceChanged\"] = \"balanceChanged\";\n  WalletEvent2[\"message\"] = \"message\";\n  WalletEvent2[\"error\"] = \"error\";\n})(WalletEvent || (WalletEvent = {}));\nvar WalletType;\n(function(WalletType2) {\n  WalletType2[\"core\"] = \"core\";\n  WalletType2[\"evm\"] = \"evm\";\n  WalletType2[\"web3auth\"] = \"web3auth\";\n})(WalletType || (WalletType = {}));\nvar NonceType;\n(function(NonceType2) {\n  NonceType2[\"latest\"] = \"latest\";\n  NonceType2[\"pending\"] = \"pending\";\n})(NonceType || (NonceType = {}));\n\n// packages/wallet/dist/helpers/signatures.js\n\nvar EIP712Validator = class _EIP712Validator {\n  /**\n   * Validates the basic structure of EIP-712 typed data\n   * @param data The typed data to validate\n   * @throws AdapterError if structure is invalid\n   */\n  static validateStructure(data) {\n    if (!data || typeof data !== \"object\") {\n      throw new AdapterError(\"Invalid EIP-712 structure: data must be an object\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"signTypedData\"\n      });\n    }\n    if (!data.domain) {\n      throw new AdapterError(\"Invalid EIP-712 structure: must have domain object\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"signTypedData\"\n      });\n    }\n    if (typeof data.domain !== \"object\") {\n      throw new AdapterError(\"Invalid EIP-712 structure: domain must be an object\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"signTypedData\"\n      });\n    }\n    if (!data.types) {\n      throw new AdapterError(\"Invalid EIP-712 structure: must have types object\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"signTypedData\"\n      });\n    }\n    if (typeof data.types !== \"object\") {\n      throw new AdapterError(\"Invalid EIP-712 structure: types must be an object\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"signTypedData\"\n      });\n    }\n    if (data.value === void 0 || data.value === null) {\n      throw new AdapterError(\"Invalid EIP-712 structure: must have value\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"signTypedData\"\n      });\n    }\n  }\n  /**\n   * Validates the EIP-712 domain against the current network\n   * @param domain The domain object from typed data\n   * @param currentChainId The current network's chain ID\n   * @throws AdapterError if domain is invalid or doesn't match network\n   */\n  static validateDomain(domain, currentChainId) {\n    if (!domain.chainId && domain.chainId !== 0) {\n      throw new AdapterError(\"EIP-712 domain missing chainId\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"signTypedData\"\n      });\n    }\n    const domainChainId = domain.chainId.toString();\n    const networkChainId = currentChainId.toString();\n    const domainChainIdHex = domainChainId.startsWith(\"0x\") ? domainChainId : `0x${parseInt(domainChainId, 10).toString(16)}`;\n    const networkChainIdHex = networkChainId.startsWith(\"0x\") ? networkChainId : `0x${parseInt(networkChainId, 10).toString(16)}`;\n    if (domainChainIdHex.toLowerCase() !== networkChainIdHex.toLowerCase()) {\n      throw new AdapterError(`EIP-712 domain chainId (${domainChainId}) doesn't match current network (${currentChainId})`, {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"signTypedData\"\n      });\n    }\n    if (domain.verifyingContract && !ethers__WEBPACK_IMPORTED_MODULE_6__.isAddress(domain.verifyingContract)) {\n      throw new AdapterError(\"EIP-712 domain verifyingContract must be a valid address\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"signTypedData\"\n      });\n    }\n  }\n  /**\n   * Validates the types structure of EIP-712 typed data\n   * @param types The types object from typed data\n   * @throws AdapterError if types structure is invalid\n   */\n  static validateTypes(types) {\n    for (const [typeName, fields] of Object.entries(types)) {\n      if (!Array.isArray(fields)) {\n        throw new AdapterError(`EIP-712 type '${typeName}' must be an array of field definitions`, {\n          code: WalletErrorCode.InvalidInput,\n          methodName: \"signTypedData\"\n        });\n      }\n      for (const field of fields) {\n        if (!field.name || !field.type) {\n          throw new AdapterError(`EIP-712 field in '${typeName}' missing name or type`, {\n            code: WalletErrorCode.InvalidInput,\n            methodName: \"signTypedData\"\n          });\n        }\n        if (!_EIP712Validator.isValidEIP712Type(field.type)) {\n          console.warn(`[EIP712Validator] Warning: EIP-712 field type '${field.type}' may not be standard`);\n        }\n      }\n    }\n  }\n  /**\n   * Validates if a type string conforms to EIP-712 standards\n   * @param type The type string to validate\n   * @returns true if the type is valid, false otherwise\n   */\n  static isValidEIP712Type(type) {\n    const basicTypes = [\"bool\", \"address\", \"string\", \"bytes\"];\n    const dynamicTypes = /^(bytes\\d+|uint\\d+|int\\d+)$/;\n    const arrayTypes = /^(.+)\\[\\d*\\]$/;\n    if (basicTypes.includes(type)) {\n      return true;\n    }\n    if (dynamicTypes.test(type)) {\n      return true;\n    }\n    if (arrayTypes.test(type)) {\n      const match = type.match(arrayTypes);\n      if (match && match[1]) {\n        const baseType = match[1];\n        if (!baseType.includes(\"[\")) {\n          return _EIP712Validator.isValidEIP712Type(baseType);\n        }\n      }\n    }\n    if (type === \"bytes\") {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Performs comprehensive EIP-712 validation\n   * @param data The typed data to validate\n   * @param currentChainId The current network's chain ID\n   * @throws AdapterError if any validation fails\n   */\n  static validateAll(data, currentChainId) {\n    _EIP712Validator.validateStructure(data);\n    _EIP712Validator.validateDomain(data.domain, currentChainId);\n    _EIP712Validator.validateTypes(data.types);\n  }\n  /**\n   * Verifies a signature immediately after signing for additional security\n   * @param data The typed data that was signed\n   * @param signature The signature to verify\n   * @param expectedAddress The expected signer address\n   * @returns true if signature is valid, false otherwise\n   */\n  static verifySignature(data, signature, expectedAddress) {\n    try {\n      const recoveredAddress = ethers__WEBPACK_IMPORTED_MODULE_7__.verifyTypedData(data.domain, data.types, data.value, signature);\n      return recoveredAddress.toLowerCase() === expectedAddress.toLowerCase();\n    } catch (error) {\n      console.error(\"[EIP712Validator] Signature verification failed:\", error);\n      return false;\n    }\n  }\n  /**\n   * Validates signature format for EIP-712\n   * @param signature The signature to validate\n   * @returns true if format is valid, false otherwise\n   */\n  static isValidSignatureFormat(signature) {\n    return signature.startsWith(\"0x\") && signature.length === 132;\n  }\n};\n\n// packages/wallet/dist/helpers/units.js\n\nfunction toWei(value, decimals) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n  const s = String(value).trim();\n  if (!s || s === \"0\") {\n    return \"0\";\n  }\n  try {\n    return ethers__WEBPACK_IMPORTED_MODULE_8__.parseUnits(s, decimals).toString();\n  } catch (err) {\n    throw new AdapterError(`Invalid value format: ${value}`, {\n      methodName: \"toWei\",\n      code: WalletErrorCode.InvalidInput,\n      cause: err\n    });\n  }\n}\nfunction toBigInt(value) {\n  try {\n    if (typeof value === \"bigint\")\n      return value;\n    if (typeof value === \"number\")\n      return BigInt(value);\n    return BigInt(value.trim());\n  } catch (err) {\n    throw new AdapterError(`Invalid BigInt value: ${value}`, {\n      methodName: \"toBigInt\",\n      code: WalletErrorCode.InvalidInput,\n      cause: err\n    });\n  }\n}\n\n// packages/wallet/dist/adapters/ethers/ethersWallet.js\nvar EvmWalletAdapter = class _EvmWalletAdapter {\n  // NEW: Add local network state\n  constructor(args) {\n    __publicField(this, \"name\");\n    __publicField(this, \"version\");\n    __publicField(this, \"wallet\");\n    __publicField(this, \"provider\");\n    __publicField(this, \"config\");\n    __publicField(this, \"_connected\", false);\n    __publicField(this, \"initialized\", false);\n    __publicField(this, \"decimals\", 18);\n    __publicField(this, \"eventListeners\", /* @__PURE__ */ new Map());\n    __publicField(this, \"multiChainRpcs\", {});\n    __publicField(this, \"network\", null);\n    this.name = args.name;\n    this.version = args.version;\n    this.config = args;\n    this.multiChainRpcs = args.options.multiChainRpcs || {};\n  }\n  /**\n   * Factory method to create and initialize an instance of EvmWalletAdapter.\n   */\n  static async create(args) {\n    const instance = new _EvmWalletAdapter(args);\n    await instance.initialize();\n    return instance;\n  }\n  // --- Core Lifecycle & Connection Methods ---\n  async initialize() {\n    if (this.initialized)\n      return;\n    const { privateKey, provider: providerConfig } = this.config.options;\n    if (!privateKey) {\n      throw new AdapterError(\"privateKey is required in options.\", {\n        code: WalletErrorCode.MissingConfig,\n        methodName: \"initialize\"\n      });\n    }\n    this.wallet = new ethers__WEBPACK_IMPORTED_MODULE_2__.Wallet(privateKey);\n    if (providerConfig) {\n      await this.setProvider(providerConfig);\n    }\n    this.initialized = true;\n  }\n  async disconnect() {\n    this.provider = void 0;\n    this._connected = false;\n    this.initialized = false;\n    this.eventListeners.clear();\n    this.emitEvent(\"disconnect\", void 0);\n  }\n  isConnected() {\n    return this._connected && !!this.provider && !!this.wallet;\n  }\n  isInitialized() {\n    return this.initialized;\n  }\n  /**\n  * Get ALL configured RPC URLs for ALL chains\n  */\n  getAllChainRpcs() {\n    return { ...this.multiChainRpcs };\n  }\n  /**\n   * Update ALL RPC configurations at once\n   */\n  async updateAllChainRpcs(multiChainRpcs) {\n    if (!multiChainRpcs || typeof multiChainRpcs !== \"object\") {\n      throw new AdapterError(\"Invalid RPC configuration - must be an object\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"updateAllChainRpcs\"\n      });\n    }\n    for (const [chainId, rpcUrls] of Object.entries(multiChainRpcs)) {\n      if (!Array.isArray(rpcUrls)) {\n        throw new AdapterError(`Invalid RPC URLs for chain ${chainId} - must be array`, {\n          code: WalletErrorCode.InvalidInput,\n          methodName: \"updateAllChainRpcs\"\n        });\n      }\n      if (rpcUrls.length === 0) {\n        throw new AdapterError(`Invalid RPC URLs for chain ${chainId} - array cannot be empty`, {\n          code: WalletErrorCode.InvalidInput,\n          methodName: \"updateAllChainRpcs\"\n        });\n      }\n      for (const url of rpcUrls) {\n        if (typeof url !== \"string\" || !url.startsWith(\"http://\") && !url.startsWith(\"https://\")) {\n          throw new AdapterError(`Invalid RPC URL for chain ${chainId}: ${url} - must be HTTP/HTTPS URL`, {\n            code: WalletErrorCode.InvalidInput,\n            methodName: \"updateAllChainRpcs\"\n          });\n        }\n      }\n    }\n    this.multiChainRpcs = { ...multiChainRpcs };\n    console.log(`[EvmWalletAdapter] Updated all chain RPCs for ${Object.keys(multiChainRpcs).length} chains`);\n  }\n  async setProvider(config) {\n    if (!config.chainId) {\n      throw new AdapterError(\"chainId is required in NetworkConfig\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"setProvider\"\n      });\n    }\n    const cid = config.chainId;\n    const preferred = this.multiChainRpcs[cid] || this.multiChainRpcs[String(cid)] || [];\n    const networkHelper = NetworkHelper.getInstance();\n    await networkHelper.ensureInitialized();\n    const netConf = await networkHelper.getNetworkConfig(cid, preferred, false);\n    if (!netConf) {\n      throw new AdapterError(`Failed to connect to any provided RPC URL for chain ${cid}`, { code: WalletErrorCode.ConnectionFailed, methodName: \"setProvider\" });\n    }\n    this.network = null;\n    this.network = netConf;\n    this.provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(netConf.rpcUrls[0]);\n    if (this.wallet) {\n      this.wallet = this.wallet.connect(this.provider);\n    }\n    this._connected = true;\n    this.emitEvent(WalletEvent.chainChanged, netConf.chainId);\n  }\n  on(event, callback) {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, /* @__PURE__ */ new Set());\n    }\n    this.eventListeners.get(event).add(callback);\n  }\n  off(event, callback) {\n    if (this.eventListeners.has(event)) {\n      this.eventListeners.get(event).delete(callback);\n    }\n  }\n  emitEvent(eventName, payload) {\n    const listeners = this.eventListeners.get(eventName);\n    if (listeners && listeners.size > 0) {\n      listeners.forEach((callback) => {\n        try {\n          callback(payload);\n        } catch (error) {\n          console.error(`[${this.name}] Error in ${eventName} event handler:`, error);\n        }\n      });\n    }\n  }\n  // --- Wallet Information & State ---\n  async getAccounts() {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected });\n    }\n    const accounts = [this.wallet.address];\n    this.emitEvent(\"accountsChanged\", accounts);\n    return accounts;\n  }\n  async getNetwork() {\n    if (!this.network) {\n      throw new AdapterError(\"No network configured.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"getNetwork\" });\n    }\n    return this.network;\n  }\n  async getBalance(account) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"getBalance\" });\n    }\n    try {\n      const provider = await this.getProvider();\n      const address = account || (await this.getAccounts())[0];\n      if (!address) {\n        throw new AdapterError(\"No account available.\", { code: WalletErrorCode.AccountUnavailable, methodName: \"getBalance\" });\n      }\n      const balanceWei = await provider.getBalance(address);\n      const networkConfig = await this.getNetwork();\n      this.decimals = networkConfig.decimals || 18;\n      return {\n        amount: balanceWei.toString(),\n        decimals: this.decimals,\n        symbol: networkConfig.ticker || \"ETH\",\n        formattedAmount: ethers__WEBPACK_IMPORTED_MODULE_8__.formatUnits(balanceWei, this.decimals)\n      };\n    } catch (error) {\n      throw new AdapterError(`Failed to get balance: ${error.message}`, { cause: error, code: WalletErrorCode.NetworkError, methodName: \"getBalance\" });\n    }\n  }\n  // --- Signing Methods ---\n  async signMessage(message) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"signMessage\" });\n    }\n    try {\n      const signer = await this.getSigner();\n      return await signer.signMessage(message);\n    } catch (error) {\n      const messageText = error.shortMessage || error.message || String(error);\n      let code = WalletErrorCode.SigningFailed;\n      if (messageText.toLowerCase().includes(\"user denied\"))\n        code = WalletErrorCode.UserRejected;\n      throw new AdapterError(`Failed to sign message: ${messageText}`, { cause: error, code, methodName: \"signMessage\" });\n    }\n  }\n  async signTransaction(tx) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"signTransaction\" });\n    }\n    try {\n      const signer = await this.getSigner();\n      const preparedTx = await this.prepareTransactionRequest(tx);\n      return await signer.signTransaction(preparedTx);\n    } catch (error) {\n      const message = error.shortMessage || error.message || String(error);\n      throw new AdapterError(`Failed to sign transaction: ${message}`, { cause: error, code: WalletErrorCode.SignatureFailed, methodName: \"signTransaction\" });\n    }\n  }\n  async signTypedData(data) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"signTypedData\" });\n    }\n    try {\n      const network = await this.getNetwork();\n      if (!network) {\n        throw new AdapterError(\"Network not found.\", { code: WalletErrorCode.NetworkError, methodName: \"signTypedData\" });\n      }\n      EIP712Validator.validateStructure(data);\n      EIP712Validator.validateTypes(data.types);\n      EIP712Validator.validateDomain(data.domain, network.chainId.toString());\n      const signer = await this.getSigner();\n      const signature = await signer.signTypedData(data.domain, data.types, data.value);\n      return signature;\n    } catch (error) {\n      const message = error.shortMessage || error.message || String(error);\n      let code = WalletErrorCode.SigningFailed;\n      if (message.toLowerCase().includes(\"user denied\"))\n        code = WalletErrorCode.UserRejected;\n      throw new AdapterError(`Failed to sign typed data: ${message}`, { cause: error, code, methodName: \"signTypedData\" });\n    }\n  }\n  async verifySignature(message, signature, address) {\n    if (!ethers__WEBPACK_IMPORTED_MODULE_6__.isAddress(address)) {\n      throw new AdapterError(\"Invalid address format.\", { code: WalletErrorCode.InvalidInput, methodName: \"verifySignature\" });\n    }\n    try {\n      if (typeof message === \"object\" && \"domain\" in message) {\n        return EIP712Validator.verifySignature(message, signature, address);\n      } else {\n        const recoveredAddress = ethers__WEBPACK_IMPORTED_MODULE_9__.verifyMessage(message, signature);\n        return recoveredAddress.toLowerCase() === address.toLowerCase();\n      }\n    } catch (error) {\n      console.error(`[${this.name}] Signature verification failed:`, error);\n      return false;\n    }\n  }\n  // --- Transaction Methods ---\n  async getNonce(type = \"pending\") {\n    const signer = await this.getSigner();\n    return signer.getNonce(type);\n  }\n  async sendTransaction(tx) {\n    console.log(\"SENDING THIS TX FROM THE CLIENT ...\", tx);\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"sendTransaction\" });\n    }\n    try {\n      const signer = await this.getSigner();\n      const txRequest = await this.prepareTransactionRequest(tx);\n      console.log(\"SENDING THIS TX FROM prepareTransactionRequest ...\", txRequest);\n      const response = await signer.sendTransaction(txRequest);\n      return response.hash;\n    } catch (error) {\n      const message = error.shortMessage || error.message || String(error);\n      let code = WalletErrorCode.TransactionFailed;\n      if (message.toLowerCase().includes(\"user denied\"))\n        code = WalletErrorCode.UserRejected;\n      throw new AdapterError(`Failed to send transaction: ${message}`, { cause: error, code, methodName: \"sendTransaction\" });\n    }\n  }\n  async getTransactionReceipt(txHash) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"getTransactionReceipt\" });\n    }\n    const provider = await this.getProvider();\n    return provider.getTransactionReceipt(txHash);\n  }\n  async callContract(options) {\n    if (!this.isConnected())\n      throw new AdapterError(\"Wallet not connected.\");\n    const provider = await this.getProvider();\n    const iface = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(options.abi);\n    const data = iface.encodeFunctionData(options.method, options.args || []);\n    const rawResult = await provider.call({\n      to: options.contractAddress,\n      data\n    });\n    return iface.decodeFunctionResult(options.method, rawResult);\n  }\n  async writeContract(options) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"writeContract\" });\n    }\n    const iface = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(options.abi);\n    const data = iface.encodeFunctionData(options.method, options.args || []);\n    const tx = {\n      to: options.contractAddress,\n      data,\n      value: options.value?.toString(),\n      options: options.overrides\n    };\n    return this.sendTransaction(tx);\n  }\n  // --- Gas & Fee Methods ---\n  async estimateGas(tx) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"estimateGas\" });\n    }\n    try {\n      const provider = await this.getProvider();\n      const signer = await this.getSigner();\n      const fromAddress = await signer.getAddress();\n      const txRequest = {\n        to: tx.to,\n        value: tx.value ? toWei(tx.value, this.decimals) : void 0,\n        data: tx.data ? typeof tx.data === \"string\" ? tx.data : ethers__WEBPACK_IMPORTED_MODULE_5__.hexlify(tx.data) : void 0,\n        from: fromAddress\n      };\n      const gasLimit = await provider.estimateGas(txRequest);\n      const feeData = await provider.getFeeData();\n      return {\n        gasLimit,\n        gasPrice: feeData.gasPrice?.toString(),\n        maxFeePerGas: feeData.maxFeePerGas?.toString(),\n        maxPriorityFeePerGas: feeData.maxPriorityFeePerGas?.toString()\n      };\n    } catch (error) {\n      throw new AdapterError(`Failed to estimate gas: ${error.message}`, {\n        cause: error,\n        code: WalletErrorCode.GasEstimationFailed,\n        methodName: \"estimateGas\"\n      });\n    }\n  }\n  async getGasPrice() {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"getGasPrice\" });\n    }\n    try {\n      const provider = await this.getProvider();\n      const feeData = await provider.getFeeData();\n      if (feeData.gasPrice) {\n        return feeData.gasPrice;\n      } else if (feeData.maxFeePerGas) {\n        return feeData.maxFeePerGas;\n      } else {\n        throw new AdapterError(\"Gas price not available from any source.\");\n      }\n    } catch (error) {\n      throw new AdapterError(`Failed to get gas price: ${error.message}`, {\n        cause: error,\n        code: WalletErrorCode.GasEstimationFailed,\n        methodName: \"getGasPrice\"\n      });\n    }\n  }\n  // --- Protected Helper Methods ---\n  async getProvider() {\n    if (!this.provider) {\n      throw new AdapterError(\"Provider not set.\", { code: WalletErrorCode.ProviderNotFound });\n    }\n    return this.provider;\n  }\n  async getSigner() {\n    if (!this.isConnected() || !this.wallet) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected });\n    }\n    return this.wallet;\n  }\n  async prepareTransactionRequest(tx) {\n    const signer = await this.getSigner();\n    const provider = await this.getProvider();\n    const txRequest = {\n      to: tx.to,\n      value: tx.value ? toWei(tx.value, this.decimals) : void 0,\n      data: tx.data ? typeof tx.data === \"string\" ? tx.data : ethers__WEBPACK_IMPORTED_MODULE_5__.hexlify(tx.data) : void 0,\n      nonce: tx.options?.nonce,\n      chainId: tx.options?.chainId ? toBigInt(tx.options.chainId) : void 0\n    };\n    if (tx.options?.gasLimit)\n      txRequest.gasLimit = BigInt(tx.options.gasLimit);\n    if (tx.options?.gasPrice)\n      txRequest.gasPrice = BigInt(tx.options.gasPrice);\n    if (tx.options?.maxFeePerGas)\n      txRequest.maxFeePerGas = BigInt(tx.options.maxFeePerGas);\n    if (tx.options?.maxPriorityFeePerGas)\n      txRequest.maxPriorityFeePerGas = BigInt(tx.options.maxPriorityFeePerGas);\n    if (!txRequest.gasLimit) {\n      txRequest.gasLimit = await provider.estimateGas(txRequest);\n    }\n    if (txRequest.nonce === void 0) {\n      txRequest.nonce = await signer.getNonce(\"pending\");\n    }\n    Object.keys(txRequest).forEach((key) => txRequest[key] === void 0 && delete txRequest[key]);\n    return txRequest;\n  }\n};\n\n// packages/wallet/dist/adapters/ethers/ethersWallet.registration.js\n\nvar ethersOptionsSchema = joi__WEBPACK_IMPORTED_MODULE_11__.object({\n  privateKey: joi__WEBPACK_IMPORTED_MODULE_11__.string().pattern(/^0x[a-fA-F0-9]{64}$/).description(\"Private key for wallet (generates random if not provided)\"),\n  provider: joi__WEBPACK_IMPORTED_MODULE_11__.object({\n    name: joi__WEBPACK_IMPORTED_MODULE_11__.string().required().description(\"Real Chain name\"),\n    chainId: joi__WEBPACK_IMPORTED_MODULE_11__.string().pattern(/^0x[0-9a-fA-F]+$/).required().description(\"Hex chain ID (e.g., 0xaa36a7)\"),\n    rpcUrls: joi__WEBPACK_IMPORTED_MODULE_11__.array().items(joi__WEBPACK_IMPORTED_MODULE_11__.string().uri({ scheme: [\"https\"] }).required()).min(1).required().description(\"Array of HTTPS RPC URLs\"),\n    displayName: joi__WEBPACK_IMPORTED_MODULE_11__.string().required().description(\"Wallet display label for the chain\")\n  }).optional().description(\"Optional provider configuration\"),\n  multiChainRpcs: joi__WEBPACK_IMPORTED_MODULE_11__.object().pattern(joi__WEBPACK_IMPORTED_MODULE_11__.alternatives().try(\n    joi__WEBPACK_IMPORTED_MODULE_11__.string().pattern(/^0x[0-9a-fA-F]+$/),\n    // Hex chain ID\n    joi__WEBPACK_IMPORTED_MODULE_11__.string().pattern(/^\\d+$/)\n    // Decimal chain ID\n  ), joi__WEBPACK_IMPORTED_MODULE_11__.array().items(joi__WEBPACK_IMPORTED_MODULE_11__.string().uri({ scheme: [\"https\", \"http\"] })).min(1).description(\"Array of RPC URLs for this chain\")).optional().description(\"Multi-chain RPC configuration - maps chain IDs to RPC URL arrays\")\n});\nvar ethersRequirements = getRequirements(ethersOptionsSchema, \"ethers\");\nvar ethersEnvironment = getEnvironments(\"ethers\", [RuntimeEnvironment.SERVER, RuntimeEnvironment.BROWSER], [\n  \"Browser environments should use secure key sources (hardware wallets, secure storage)\",\n  \"Consider Web3Auth adapter for OAuth-based browser authentication flows\"\n], [\n  \"Private keys are processed during wallet creation but not stored persistently\",\n  \"Server environments provide better security for sensitive private key operations\",\n  \"Browser usage requires secure private key handling by the application\"\n]);\nvar ethersFeatures = getFeatures(EvmWalletAdapter);\nvar adapterMetadata = {\n  name: \"ethers\",\n  version: \"1.0.0\",\n  module: \"wallet\",\n  adapterType: WalletType.evm,\n  adapterClass: EvmWalletAdapter,\n  capabilities: [\n    Capability.CoreWallet,\n    Capability.EventEmitter,\n    Capability.MessageSigner,\n    Capability.TransactionHandler,\n    Capability.TypedDataSigner,\n    Capability.GasEstimation,\n    Capability.TokenOperations,\n    Capability.RPCHandler,\n    Capability.TransactionStatus,\n    Capability.AdapterLifecycle\n  ],\n  requirements: ethersRequirements,\n  environment: ethersEnvironment,\n  features: ethersFeatures\n};\nregistry.registerAdapter(\"wallet\", adapterMetadata);\nvar compatibilityMatrix = getStaticCompatibilityMatrix(\"wallet\", \"ethers\", \"1.0.0\");\nif (compatibilityMatrix) {\n  registry.registerCompatibilityMatrix(\"wallet\", compatibilityMatrix);\n}\nconsole.log(\"\\u2705 Ethers wallet adapter registered with static compatibility matrix\");\nconsole.log(\"\\u{1F4CB} Generated requirements:\", ethersRequirements);\nconsole.log(\"\\u{1F30D} Generated environment:\", ethersEnvironment);\nconsole.log(\"\\u{1F527} Generated features:\", ethersFeatures.map((f) => f.name));\n\n// packages/wallet/dist/adapters/web3auth/web3authWallet.js\n\n\n\n\n\nvar Web3AuthWalletAdapter = class _Web3AuthWalletAdapter {\n  // NEW: Add local network state\n  constructor(args) {\n    __publicField(this, \"name\");\n    __publicField(this, \"version\");\n    __publicField(this, \"web3auth\", null);\n    __publicField(this, \"config\");\n    __publicField(this, \"initialized\", false);\n    __publicField(this, \"decimals\", 18);\n    __publicField(this, \"eventListeners\", /* @__PURE__ */ new Map());\n    __publicField(this, \"multiChainRpcs\", {});\n    __publicField(this, \"network\", null);\n    this.name = args.name;\n    this.version = args.version;\n    this.config = args;\n    this.multiChainRpcs = args.options.multiChainRpcs || {};\n  }\n  /**\n   * Factory method to create and initialize an instance of Web3AuthWalletAdapter.\n   */\n  static async create(args) {\n    const instance = new _Web3AuthWalletAdapter(args);\n    await instance.initialize();\n    return instance;\n  }\n  // --- Core Lifecycle & Connection Methods ---\n  async initialize() {\n    if (this.initialized)\n      return;\n    const opts = this.config.options.web3authConfig;\n    if (!opts) {\n      throw new AdapterError(\"web3authConfig is missing.\", { code: WalletErrorCode.MissingConfig });\n    }\n    try {\n      const privateKeyProvider = opts.privateKeyProvider || new _web3auth_ethereum_provider__WEBPACK_IMPORTED_MODULE_12__.EthereumPrivateKeyProvider({ config: { chainConfig: opts.chainConfig } });\n      this.web3auth = new _web3auth_no_modal__WEBPACK_IMPORTED_MODULE_13__.Web3AuthNoModal({\n        clientId: opts.clientId,\n        web3AuthNetwork: opts.web3AuthNetwork,\n        chainConfig: opts.chainConfig,\n        privateKeyProvider\n      });\n      const authAdapter = new _web3auth_auth_adapter__WEBPACK_IMPORTED_MODULE_14__.AuthAdapter({ adapterSettings: { loginConfig: opts.loginConfig } });\n      this.web3auth.configureAdapter(authAdapter);\n      await this.web3auth.init();\n      this.initialized = true;\n    } catch (error) {\n      throw new AdapterError(\"Web3Auth initialization failed.\", { cause: error, code: WalletErrorCode.InitializationFailed });\n    }\n  }\n  async disconnect() {\n    if (this.web3auth && this.web3auth.connected) {\n      await this.web3auth.logout();\n    }\n    this.web3auth = null;\n    this.initialized = false;\n    this.eventListeners.clear();\n    this.emitEvent(\"disconnect\", void 0);\n  }\n  isConnected() {\n    return this.initialized && !!this.web3auth?.connected;\n  }\n  isInitialized() {\n    return this.initialized;\n  }\n  /**\n  * Get ALL configured RPC URLs for ALL chains\n  */\n  getAllChainRpcs() {\n    return { ...this.multiChainRpcs };\n  }\n  /**\n   * Update ALL RPC configurations at once\n   */\n  async updateAllChainRpcs(multiChainRpcs) {\n    if (!multiChainRpcs || typeof multiChainRpcs !== \"object\") {\n      throw new AdapterError(\"Invalid RPC configuration - must be an object\", {\n        code: WalletErrorCode.InvalidInput,\n        methodName: \"updateAllChainRpcs\"\n      });\n    }\n    for (const [chainId, rpcUrls] of Object.entries(multiChainRpcs)) {\n      if (!Array.isArray(rpcUrls)) {\n        throw new AdapterError(`Invalid RPC URLs for chain ${chainId} - must be array`, {\n          code: WalletErrorCode.InvalidInput,\n          methodName: \"updateAllChainRpcs\"\n        });\n      }\n      if (rpcUrls.length === 0) {\n        throw new AdapterError(`Invalid RPC URLs for chain ${chainId} - array cannot be empty`, {\n          code: WalletErrorCode.InvalidInput,\n          methodName: \"updateAllChainRpcs\"\n        });\n      }\n      for (const url of rpcUrls) {\n        if (typeof url !== \"string\" || !url.startsWith(\"http://\") && !url.startsWith(\"https://\")) {\n          throw new AdapterError(`Invalid RPC URL for chain ${chainId}: ${url} - must be HTTP/HTTPS URL`, {\n            code: WalletErrorCode.InvalidInput,\n            methodName: \"updateAllChainRpcs\"\n          });\n        }\n      }\n    }\n    this.multiChainRpcs = { ...multiChainRpcs };\n    console.log(`[Web3AuthWalletAdapter] Updated all chain RPCs for ${Object.keys(multiChainRpcs).length} chains`);\n  }\n  async setProvider(config) {\n    if (!this.isConnected() || !this.web3auth) {\n      throw new AdapterError(\"Not connected.\", { code: WalletErrorCode.WalletNotConnected });\n    }\n    const newChainIdHex = config.chainId.startsWith(\"0x\") ? config.chainId : `0x${parseInt(config.chainId, 10).toString(16)}`;\n    const cid = config.chainId;\n    const cidDecimal = parseInt(newChainIdHex, 16).toString();\n    const preferred = this.multiChainRpcs[cid] || this.multiChainRpcs[cidDecimal] || this.multiChainRpcs[newChainIdHex] || [];\n    const networkHelper = NetworkHelper.getInstance();\n    await networkHelper.ensureInitialized();\n    let finalConfig;\n    try {\n      const enhancedConfig = await networkHelper.getNetworkConfig(cid, preferred, false);\n      finalConfig = enhancedConfig || config;\n    } catch (error) {\n      console.warn(`[Web3AuthWalletAdapter] NetworkHelper failed, using original config:`, error);\n      finalConfig = config;\n    }\n    if (!finalConfig.rpcUrls || finalConfig.rpcUrls.length === 0) {\n      if (preferred.length > 0) {\n        finalConfig = { ...finalConfig, rpcUrls: preferred };\n      } else {\n        throw new AdapterError(`No RPC URLs available for chain ${newChainIdHex}`, {\n          code: WalletErrorCode.ConnectionFailed,\n          methodName: \"setProvider\"\n        });\n      }\n    }\n    try {\n      await this.web3auth.switchChain({ chainId: newChainIdHex });\n    } catch (switchError) {\n      if (switchError.code === 4902 || switchError.message?.includes(\"Unrecognized chain ID\") || switchError.message?.includes(\"Chain config has not been added\")) {\n        try {\n          console.log(`[Web3AuthWalletAdapter] Adding chain ${newChainIdHex} to Web3Auth`);\n          const chainToAdd = {\n            chainId: newChainIdHex,\n            chainNamespace: \"eip155\",\n            displayName: finalConfig.displayName || finalConfig.name,\n            rpcTarget: finalConfig.rpcUrls[0],\n            // ✅ Use the proper RPC URL\n            blockExplorerUrl: finalConfig.blockExplorerUrl,\n            ticker: finalConfig.ticker || \"ETH\",\n            tickerName: finalConfig.tickerName || \"Ethereum\"\n          };\n          await this.web3auth.addChain(chainToAdd);\n          console.log(`[Web3AuthWalletAdapter] \\u2705 Successfully added chain ${newChainIdHex}`);\n          await this.web3auth.switchChain({ chainId: newChainIdHex });\n          console.log(`[Web3AuthWalletAdapter] \\u2705 Successfully switched to chain ${newChainIdHex}`);\n        } catch (addError) {\n          throw new AdapterError(`Failed to add or switch to chain ${newChainIdHex}: ${addError.message}`, {\n            cause: addError,\n            code: WalletErrorCode.ConnectionFailed,\n            methodName: \"setProvider\"\n          });\n        }\n      } else {\n        throw new AdapterError(`Failed to switch chain ${newChainIdHex}: ${switchError.message}`, {\n          cause: switchError,\n          code: WalletErrorCode.ConnectionFailed,\n          methodName: \"setProvider\"\n        });\n      }\n    }\n    this.network = null;\n    const network = await this.getNetwork();\n    this.network = network;\n    this.decimals = network.decimals || 18;\n    this.emitEvent(\"chainChanged\", network.chainId);\n  }\n  // --- Event Handling ---\n  on(event, callback) {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, /* @__PURE__ */ new Set());\n    }\n    this.eventListeners.get(event).add(callback);\n  }\n  off(event, callback) {\n    if (this.eventListeners.has(event)) {\n      this.eventListeners.get(event).delete(callback);\n    }\n  }\n  emitEvent(eventName, payload) {\n    const listeners = this.eventListeners.get(eventName);\n    if (listeners && listeners.size > 0) {\n      listeners.forEach((callback) => {\n        try {\n          callback(payload);\n        } catch (error) {\n          console.error(`[${this.name}] Error in ${eventName} event handler:`, error);\n        }\n      });\n    }\n  }\n  // --- Wallet Information & State ---\n  async getAccounts() {\n    if (!this.isConnected()) {\n      const loginProvider = Object.keys(this.config.options.web3authConfig.loginConfig)[0];\n      if (!loginProvider) {\n        throw new AdapterError(\"No login providers configured.\", { code: WalletErrorCode.MissingConfig });\n      }\n      await this.web3auth?.connectTo(_web3auth_base__WEBPACK_IMPORTED_MODULE_15__.WALLET_ADAPTERS.AUTH, { loginProvider });\n      if (!this.web3auth?.connected || !this.web3auth.provider) {\n        throw new AdapterError(\"Failed to connect to Web3Auth.\", { code: WalletErrorCode.ConnectionFailed });\n      }\n      const network = await this.getNetwork();\n      this.network = network;\n      this.emitEvent(\"connect\", { chainId: network.chainId });\n    }\n    const accounts = await this.web3auth?.provider?.request({ method: \"eth_accounts\" });\n    this.emitEvent(\"accountsChanged\", accounts);\n    return accounts;\n  }\n  async getNetwork() {\n    if (!this.isConnected() || !this.web3auth?.provider) {\n      throw new AdapterError(\"Not connected.\", { code: WalletErrorCode.WalletNotConnected });\n    }\n    if (this.network) {\n      return this.network;\n    }\n    const provider = await this.getProvider();\n    const network = await provider.getNetwork();\n    const chainId = `0x${network.chainId.toString(16)}`;\n    const networkHelper = NetworkHelper.getInstance();\n    await networkHelper.ensureInitialized();\n    const config = await networkHelper.getNetworkConfig(chainId);\n    const finalConfig = config ?? {\n      chainId,\n      name: network.name,\n      displayName: network.name,\n      rpcUrls: [provider?.connection?.url || \"\"].filter(Boolean),\n      decimals: 18,\n      ticker: \"ETH\",\n      tickerName: \"Ethereum\"\n    };\n    this.network = finalConfig;\n    return finalConfig;\n  }\n  async getBalance(account) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"getBalance\" });\n    }\n    try {\n      const provider = await this.getProvider();\n      const address = account || (await this.getAccounts())[0];\n      if (!address) {\n        throw new AdapterError(\"No account available.\", { code: WalletErrorCode.AccountUnavailable, methodName: \"getBalance\" });\n      }\n      const balanceWei = await provider.getBalance(address);\n      const networkConfig = await this.getNetwork();\n      this.decimals = networkConfig.decimals || 18;\n      return {\n        amount: balanceWei.toString(),\n        decimals: this.decimals,\n        symbol: networkConfig.ticker || \"ETH\",\n        formattedAmount: ethers__WEBPACK_IMPORTED_MODULE_8__.formatUnits(balanceWei, this.decimals)\n      };\n    } catch (error) {\n      throw new AdapterError(`Failed to get balance: ${error.message}`, { cause: error, code: WalletErrorCode.NetworkError, methodName: \"getBalance\" });\n    }\n  }\n  // --- Signing Methods ---\n  async signMessage(message) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"signMessage\" });\n    }\n    try {\n      const signer = await this.getSigner();\n      return await signer.signMessage(message);\n    } catch (error) {\n      const messageText = error.shortMessage || error.message || String(error);\n      let code = WalletErrorCode.SigningFailed;\n      if (messageText.toLowerCase().includes(\"user denied\"))\n        code = WalletErrorCode.UserRejected;\n      throw new AdapterError(`Failed to sign message: ${messageText}`, { cause: error, code, methodName: \"signMessage\" });\n    }\n  }\n  async signTransaction(tx) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"signTransaction\" });\n    }\n    try {\n      const signer = await this.getSigner();\n      const preparedTx = await this.prepareTransactionRequest(tx);\n      return await signer.signTransaction(preparedTx);\n    } catch (error) {\n      const message = error.shortMessage || error.message || String(error);\n      throw new AdapterError(`Failed to sign transaction: ${message}`, { cause: error, code: WalletErrorCode.SignatureFailed, methodName: \"signTransaction\" });\n    }\n  }\n  async signTypedData(data) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"signTypedData\" });\n    }\n    try {\n      EIP712Validator.validateStructure(data);\n      EIP712Validator.validateTypes(data.types);\n      const network = await this.getNetwork();\n      EIP712Validator.validateDomain(data.domain, network.chainId.toString());\n      const signer = await this.getSigner();\n      const signature = await signer.signTypedData(data.domain, data.types, data.value);\n      return signature;\n    } catch (error) {\n      if (error instanceof AdapterError) {\n        throw error;\n      }\n      const message = error.shortMessage || error.message || String(error);\n      let code = WalletErrorCode.SigningFailed;\n      if (message.toLowerCase().includes(\"user denied\"))\n        code = WalletErrorCode.UserRejected;\n      throw new AdapterError(`Failed to sign typed data: ${message}`, { cause: error, code, methodName: \"signTypedData\" });\n    }\n  }\n  async verifySignature(message, signature, address) {\n    if (!ethers__WEBPACK_IMPORTED_MODULE_6__.isAddress(address)) {\n      throw new AdapterError(\"Invalid address format.\", { code: WalletErrorCode.InvalidInput, methodName: \"verifySignature\" });\n    }\n    try {\n      if (typeof message === \"object\" && \"domain\" in message) {\n        return EIP712Validator.verifySignature(message, signature, address);\n      } else {\n        const recoveredAddress = ethers__WEBPACK_IMPORTED_MODULE_9__.verifyMessage(message, signature);\n        return recoveredAddress.toLowerCase() === address.toLowerCase();\n      }\n    } catch (error) {\n      console.error(`[${this.name}] Signature verification failed:`, error);\n      return false;\n    }\n  }\n  // --- Transaction Methods ---\n  async getNonce(type = \"pending\") {\n    const signer = await this.getSigner();\n    return signer.getNonce(type);\n  }\n  async sendTransaction(tx) {\n    console.log(\"SENDING THIS TX FROM THE CLIENT ...\", tx);\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"sendTransaction\" });\n    }\n    try {\n      const signer = await this.getSigner();\n      const txRequest = await this.prepareTransactionRequest(tx);\n      console.log(\"SENDING THIS TX FROM prepareTransactionRequest ...\", txRequest);\n      const response = await signer.sendTransaction(txRequest);\n      return response.hash;\n    } catch (error) {\n      const message = error.shortMessage || error.message || String(error);\n      let code = WalletErrorCode.TransactionFailed;\n      if (message.toLowerCase().includes(\"user denied\"))\n        code = WalletErrorCode.UserRejected;\n      throw new AdapterError(`Failed to send transaction: ${message}`, { cause: error, code, methodName: \"sendTransaction\" });\n    }\n  }\n  async getTransactionReceipt(txHash) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"getTransactionReceipt\" });\n    }\n    const provider = await this.getProvider();\n    return provider.getTransactionReceipt(txHash);\n  }\n  async callContract(options) {\n    if (!this.isConnected())\n      throw new AdapterError(\"Wallet not connected.\");\n    const provider = await this.getProvider();\n    const iface = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(options.abi);\n    const data = iface.encodeFunctionData(options.method, options.args || []);\n    const rawResult = await provider.call({\n      to: options.contractAddress,\n      data\n    });\n    return iface.decodeFunctionResult(options.method, rawResult);\n  }\n  async writeContract(options) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"writeContract\" });\n    }\n    const iface = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(options.abi);\n    const data = iface.encodeFunctionData(options.method, options.args || []);\n    const tx = {\n      to: options.contractAddress,\n      data,\n      value: options.value?.toString(),\n      options: options.overrides\n    };\n    return this.sendTransaction(tx);\n  }\n  // --- Gas & Fee Methods ---\n  async estimateGas(tx) {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"estimateGas\" });\n    }\n    try {\n      const provider = await this.getProvider();\n      const signer = await this.getSigner();\n      const fromAddress = await signer.getAddress();\n      const txRequest = {\n        to: tx.to,\n        value: tx.value ? toWei(tx.value, this.decimals) : void 0,\n        data: tx.data ? typeof tx.data === \"string\" ? tx.data : ethers__WEBPACK_IMPORTED_MODULE_5__.hexlify(tx.data) : void 0,\n        from: fromAddress\n      };\n      const gasLimit = await provider.estimateGas(txRequest);\n      const feeData = await provider.getFeeData();\n      return {\n        gasLimit,\n        gasPrice: feeData.gasPrice?.toString(),\n        maxFeePerGas: feeData.maxFeePerGas?.toString(),\n        maxPriorityFeePerGas: feeData.maxPriorityFeePerGas?.toString()\n      };\n    } catch (error) {\n      throw new AdapterError(`Failed to estimate gas: ${error.message}`, {\n        cause: error,\n        code: WalletErrorCode.GasEstimationFailed,\n        methodName: \"estimateGas\"\n      });\n    }\n  }\n  async getGasPrice() {\n    if (!this.isConnected()) {\n      throw new AdapterError(\"Wallet not connected.\", { code: WalletErrorCode.WalletNotConnected, methodName: \"getGasPrice\" });\n    }\n    try {\n      const provider = await this.getProvider();\n      const feeData = await provider.getFeeData();\n      if (feeData.gasPrice) {\n        return feeData.gasPrice;\n      } else if (feeData.maxFeePerGas) {\n        return feeData.maxFeePerGas;\n      } else {\n        throw new AdapterError(\"Gas price not available from any source.\");\n      }\n    } catch (error) {\n      throw new AdapterError(`Failed to get gas price: ${error.message}`, {\n        cause: error,\n        code: WalletErrorCode.GasEstimationFailed,\n        methodName: \"getGasPrice\"\n      });\n    }\n  }\n  // --- Protected Helper Methods ---\n  async getProvider() {\n    if (!this.web3auth?.provider) {\n      throw new AdapterError(\"Provider not available from Web3Auth.\", { code: WalletErrorCode.ProviderNotFound });\n    }\n    return new ethers__WEBPACK_IMPORTED_MODULE_1__.BrowserProvider(this.web3auth.provider);\n  }\n  async getSigner() {\n    const provider = await this.getProvider();\n    const accounts = await this.getAccounts();\n    if (accounts.length === 0) {\n      throw new AdapterError(\"No accounts available to create signer.\", { code: WalletErrorCode.AccountUnavailable });\n    }\n    return provider.getSigner(accounts[0]);\n  }\n  async prepareTransactionRequest(tx) {\n    const signer = await this.getSigner();\n    const provider = await this.getProvider();\n    const txRequest = {\n      to: tx.to,\n      value: tx.value ? toWei(tx.value, this.decimals) : void 0,\n      data: tx.data ? typeof tx.data === \"string\" ? tx.data : ethers__WEBPACK_IMPORTED_MODULE_5__.hexlify(tx.data) : void 0,\n      nonce: tx.options?.nonce,\n      chainId: tx.options?.chainId ? toBigInt(tx.options.chainId) : void 0\n    };\n    if (tx.options?.gasLimit)\n      txRequest.gasLimit = BigInt(tx.options.gasLimit);\n    if (tx.options?.gasPrice)\n      txRequest.gasPrice = BigInt(tx.options.gasPrice);\n    if (tx.options?.maxFeePerGas)\n      txRequest.maxFeePerGas = BigInt(tx.options.maxFeePerGas);\n    if (tx.options?.maxPriorityFeePerGas)\n      txRequest.maxPriorityFeePerGas = BigInt(tx.options.maxPriorityFeePerGas);\n    if (!txRequest.gasLimit) {\n      txRequest.gasLimit = await provider.estimateGas(txRequest);\n    }\n    if (txRequest.nonce === void 0) {\n      txRequest.nonce = await signer.getNonce(\"pending\");\n    }\n    Object.keys(txRequest).forEach((key) => txRequest[key] === void 0 && delete txRequest[key]);\n    return txRequest;\n  }\n};\n\n// packages/wallet/dist/adapters/web3auth/web3authWallet.registration.js\n\nvar web3AuthOptionsSchema = joi__WEBPACK_IMPORTED_MODULE_11__.object({\n  web3authConfig: joi__WEBPACK_IMPORTED_MODULE_11__.object({\n    clientId: joi__WEBPACK_IMPORTED_MODULE_11__.string().required().description(\"Your Web3Auth Client ID\"),\n    web3AuthNetwork: joi__WEBPACK_IMPORTED_MODULE_11__.string().valid(\"sapphire_mainnet\", \"sapphire_devnet\", \"testnet\").required().description(\"Web3Auth Network environment\"),\n    chainConfig: joi__WEBPACK_IMPORTED_MODULE_11__.object({\n      chainNamespace: joi__WEBPACK_IMPORTED_MODULE_11__.string().default(\"eip155\"),\n      chainId: joi__WEBPACK_IMPORTED_MODULE_11__.string().required().description(\"Blockchain chain ID (hexadecimal)\"),\n      rpcTarget: joi__WEBPACK_IMPORTED_MODULE_11__.string().uri().required().description(\"RPC endpoint URL\"),\n      displayName: joi__WEBPACK_IMPORTED_MODULE_11__.string().required().description(\"Network display name\"),\n      blockExplorerUrl: joi__WEBPACK_IMPORTED_MODULE_11__.string().uri().required().description(\"Block explorer URL\"),\n      ticker: joi__WEBPACK_IMPORTED_MODULE_11__.string().required().description(\"Native token ticker (e.g., ETH)\"),\n      tickerName: joi__WEBPACK_IMPORTED_MODULE_11__.string().required().description(\"Native token name (e.g., Ethereum)\")\n    }).required().description(\"Blockchain configuration\"),\n    loginConfig: joi__WEBPACK_IMPORTED_MODULE_11__.object().required().description(\"OAuth provider configuration\"),\n    privateKeyProvider: joi__WEBPACK_IMPORTED_MODULE_11__.any().optional().description(\"Optional private key provider\")\n  }).required().description(\"Web3Auth configuration object\"),\n  // ✅ NEW: Add multiChainRpcs option (same as ethers)\n  multiChainRpcs: joi__WEBPACK_IMPORTED_MODULE_11__.object().pattern(joi__WEBPACK_IMPORTED_MODULE_11__.alternatives().try(\n    joi__WEBPACK_IMPORTED_MODULE_11__.string().pattern(/^0x[0-9a-fA-F]+$/),\n    // Hex chain ID\n    joi__WEBPACK_IMPORTED_MODULE_11__.string().pattern(/^\\d+$/)\n    // Decimal chain ID\n  ), joi__WEBPACK_IMPORTED_MODULE_11__.array().items(joi__WEBPACK_IMPORTED_MODULE_11__.string().uri({ scheme: [\"https\", \"http\"] })).min(1).description(\"Array of RPC URLs for this chain\")).optional().description(\"Multi-chain RPC configuration - maps chain IDs to RPC URL arrays\")\n});\nvar web3authRequirements = getRequirements(web3AuthOptionsSchema, \"web3auth\");\nvar web3authEnvironment = getEnvironments(\n  \"web3auth\",\n  [RuntimeEnvironment.BROWSER],\n  // Browser only\n  [\n    \"Requires browser environment with Web3Auth SDK\",\n    \"Cannot be used in Node.js server environments\",\n    \"Requires user interaction for OAuth flows\"\n  ],\n  [\n    \"Web3Auth handles private key generation securely\",\n    \"OAuth-based authentication provides better UX\",\n    \"Private keys reconstructed in memory only\"\n  ]\n);\nvar web3authFeatures = getFeatures(Web3AuthWalletAdapter);\nvar adapterMetadata2 = {\n  name: \"web3auth\",\n  version: \"1.0.0\",\n  module: \"wallet\",\n  adapterType: WalletType.web3auth,\n  adapterClass: Web3AuthWalletAdapter,\n  /** ✅ ADD: Define the capabilities this adapter implements. */\n  capabilities: [\n    Capability.CoreWallet,\n    Capability.EventEmitter,\n    Capability.MessageSigner,\n    Capability.TransactionHandler,\n    Capability.TypedDataSigner,\n    Capability.GasEstimation,\n    Capability.TokenOperations,\n    Capability.RPCHandler,\n    Capability.TransactionStatus,\n    Capability.AdapterLifecycle\n  ],\n  requirements: web3authRequirements,\n  environment: web3authEnvironment,\n  features: web3authFeatures\n};\nregistry.registerAdapter(\"wallet\", adapterMetadata2);\nvar compatibilityMatrix2 = getStaticCompatibilityMatrix(\"wallet\", \"web3auth\", \"1.0.0\");\nif (compatibilityMatrix2) {\n  registry.registerCompatibilityMatrix(\"wallet\", compatibilityMatrix2);\n}\nconsole.log(\"\\u2705 Web3Auth wallet adapter registered with static compatibility matrix\");\nconsole.log(\"\\u{1F4CB} Generated requirements:\", web3authRequirements);\nconsole.log(\"\\u{1F30D} Generated environment:\", web3authEnvironment);\nconsole.log(\"\\u{1F527} Generated features:\", web3authFeatures.map((f) => f.name));\n\n// packages/wallet/dist/index.js\nregistry.registerModule({ name: \"wallet\", version: package_default.version });\nregistry.registerInterfaceShape(\"IEVMWallet\", [\n  Capability.CoreWallet,\n  Capability.EventEmitter,\n  Capability.MessageSigner,\n  Capability.TransactionHandler,\n  Capability.TypedDataSigner,\n  Capability.GasEstimation,\n  Capability.TokenOperations,\n  Capability.RPCHandler,\n  Capability.TransactionStatus\n]);\nasync function createWallet(params) {\n  const { name, version } = params;\n  try {\n    const adapterInfo = registry.getAdapter(Ms3Modules.wallet, name, version);\n    if (!adapterInfo) {\n      const availableVersions = registry.getAdapterVersions(Ms3Modules.wallet, name);\n      const versionsText = availableVersions.length > 0 ? ` Available versions: ${availableVersions.join(\", \")}` : \"\";\n      throw new AdapterError(`Adapter '${name}' version '${version}' not found for wallet module.${versionsText}`);\n    }\n    if (adapterInfo.environment) {\n      console.log(adapterInfo.environment);\n      validateEnvironment(name, adapterInfo.environment);\n    }\n    const validatorArgs = {\n      moduleName: Ms3Modules.wallet,\n      name,\n      version,\n      // ✅ Add version\n      params,\n      adapterInfo,\n      registry,\n      factoryMethodName: \"createWallet\"\n    };\n    validateAdapterParameters(validatorArgs);\n    const AdapterClass = adapterInfo.adapterClass;\n    if (!AdapterClass || typeof AdapterClass.create !== \"function\") {\n      throw new AdapterError(`Adapter class or its static 'create' method is invalid for '${name}'.`);\n    }\n    const adapter = await AdapterClass.create({\n      name,\n      version,\n      options: params.options\n    });\n    if (!adapter) {\n    }\n    return createErrorHandlingProxy(\n      adapter,\n      adapterInfo.capabilities,\n      // Pass the capabilities\n      adapterInfo.errorMap || {},\n      void 0,\n      `WalletAdapter(${name})`\n    );\n  } catch (error) {\n    if (error instanceof AdapterError) {\n      throw error;\n    }\n    throw new AdapterError(`Adapter '${name}' failed to be created: ${error}`);\n  }\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG0zcy93YWxsZXQvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBLDBCQUEwQixjQUFjLEdBQUcsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLLEdBQUcsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4Q0FBOEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBNEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBNEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBb0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQW9EO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxvQkFBb0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLEtBQUs7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSx1QkFBdUIsS0FBSztBQUM1QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSywwQkFBMEIsTUFBTTtBQUM1RTtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2FuZ2VsYWhlcnJhZG9ybG9wZXovRGVza3RvcC9DVEIvTVMzL3VzZWNhc2VzL25vZGVfbW9kdWxlcy9AbTNzL3dhbGxldC9kaXN0L2luZGV4LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuXG4vLyBwYWNrYWdlcy93YWxsZXQvcGFja2FnZS5qc29uXG52YXIgcGFja2FnZV9kZWZhdWx0ID0ge1xuICBuYW1lOiBcIkBtM3Mvd2FsbGV0XCIsXG4gIHZlcnNpb246IFwiMi40LjNcIixcbiAgdHlwZTogXCJtb2R1bGVcIixcbiAgZGVzY3JpcHRpb246IFwiQSBmbGV4aWJsZSB3YWxsZXQgaW50ZXJmYWNlIHN1cHBvcnRpbmcgbXVsdGlwbGUgYmxvY2tjaGFpbiB3YWxsZXQgdHlwZXMsIGluY2x1ZGluZyBFVk0gd2FsbGV0cyBhbmQgV2ViM0F1dGggaW50ZWdyYXRpb25cIixcbiAgbGljZW5zZTogXCJNSVRcIixcbiAga2V5d29yZHM6IFtcbiAgICBcIndhbGxldFwiLFxuICAgIFwiZXRoZXJldW1cIixcbiAgICBcIndlYjNhdXRoXCIsXG4gICAgXCJibG9ja2NoYWluXCIsXG4gICAgXCJldm1cIixcbiAgICBcIm9hdXRoXCIsXG4gICAgXCJjcnlwdG9cIixcbiAgICBcIndlYjNcIlxuICBdLFxuICByZXBvc2l0b3J5OiB7XG4gICAgdHlwZTogXCJnaXRcIixcbiAgICB1cmw6IFwiZ2l0QGJpdGJ1Y2tldC5vcmc6Y3RiLW1hcmlzY2EvbXMzLXBhY2thZ2UuZ2l0XCIsXG4gICAgZGlyZWN0b3J5OiBcInBhY2thZ2VzL3dhbGxldFwiXG4gIH0sXG4gIG1haW46IFwiLi9kaXN0L2luZGV4LmNqcy5qc1wiLFxuICBtb2R1bGU6IFwiLi9kaXN0L2luZGV4LmVzbS5qc1wiLFxuICB0eXBlczogXCIuL2Rpc3QvaW5kZXguZC50c1wiLFxuICBleHBvcnRzOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIHR5cGVzOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gICAgICBpbXBvcnQ6IFwiLi9kaXN0L2luZGV4LmVzbS5qc1wiLFxuICAgICAgcmVxdWlyZTogXCIuL2Rpc3QvaW5kZXguY2pzLmpzXCJcbiAgICB9XG4gIH0sXG4gIHNjcmlwdHM6IHtcbiAgICBidWlsZDogXCJ0c2MgLWJcIixcbiAgICBwcmVwdWJsaXNoT25seTogXCJucG0gcnVuIGJ1aWxkXCIsXG4gICAgdGVzdDogXCJ2aXRlc3QgcnVuIC0tc2VxdWVuY2Uuc2VxdWVudGlhbFwiXG4gIH0sXG4gIGRlcGVuZGVuY2llczoge1xuICAgIGV0aGVyczogXCJeNi4xMy41XCIsXG4gICAgam9pOiBcIl4xNy4xMy4zXCJcbiAgfSxcbiAgZGV2RGVwZW5kZW5jaWVzOiB7XG4gICAgXCJAbTNzL3NoYXJlZFwiOiBcIipcIlxuICB9LFxuICBwZWVyRGVwZW5kZW5jaWVzOiB7XG4gICAgXCJAd2ViM2F1dGgvYXV0aC1hZGFwdGVyXCI6IFwiOS43LjBcIixcbiAgICBcIkB3ZWIzYXV0aC9iYXNlXCI6IFwiOS43LjBcIixcbiAgICBcIkB3ZWIzYXV0aC9ldGhlcmV1bS1wcm92aWRlclwiOiBcIjkuNy4wXCIsXG4gICAgXCJAd2ViM2F1dGgvbm8tbW9kYWxcIjogXCI5LjcuMFwiXG4gIH0sXG4gIHBlZXJEZXBlbmRlbmNpZXNNZXRhOiB7XG4gICAgXCJAd2ViM2F1dGgvYXV0aC1hZGFwdGVyXCI6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBcIkB3ZWIzYXV0aC9iYXNlXCI6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBcIkB3ZWIzYXV0aC9ldGhlcmV1bS1wcm92aWRlclwiOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgXCJAd2ViM2F1dGgvbm8tbW9kYWxcIjoge1xuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIHB1Ymxpc2hDb25maWc6IHtcbiAgICBhY2Nlc3M6IFwicHVibGljXCIsXG4gICAgdGFnOiBcImxhdGVzdFwiXG4gIH0sXG4gIGZpbGVzOiBbXG4gICAgXCJkaXN0XCJcbiAgXSxcbiAgZW5naW5lczoge1xuICAgIG5vZGU6IFwiPj0xOC4wLjBcIlxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9zaGFyZWQvZGlzdC9lcnJvcnMvQWRhcHRlckVycm9yLmpzXG52YXIgQWRhcHRlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIC8vIEFkZCB0aGlzIGxpbmVcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb2RlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjYXVzZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWV0aG9kTmFtZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGV0YWlsc1wiKTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgdGhpcy5jb2RlID0gb3B0aW9ucz8uY29kZTtcbiAgICB0aGlzLmNhdXNlID0gb3B0aW9ucz8uY2F1c2U7XG4gICAgdGhpcy5tZXRob2ROYW1lID0gb3B0aW9ucz8ubWV0aG9kTmFtZTtcbiAgICB0aGlzLmRldGFpbHMgPSBvcHRpb25zPy5kZXRhaWxzO1xuICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9zaGFyZWQvZGlzdC9yZWdpc3RyeS9jYXBhYmlsaXR5LmpzXG52YXIgQ2FwYWJpbGl0eTtcbihmdW5jdGlvbihDYXBhYmlsaXR5Mikge1xuICBDYXBhYmlsaXR5MltcIkNvcmVXYWxsZXRcIl0gPSBcIklDb3JlV2FsbGV0XCI7XG4gIENhcGFiaWxpdHkyW1wiRXZlbnRFbWl0dGVyXCJdID0gXCJJRXZlbnRFbWl0dGVyXCI7XG4gIENhcGFiaWxpdHkyW1wiTWVzc2FnZVNpZ25lclwiXSA9IFwiSU1lc3NhZ2VTaWduZXJcIjtcbiAgQ2FwYWJpbGl0eTJbXCJUcmFuc2FjdGlvbkhhbmRsZXJcIl0gPSBcIklUcmFuc2FjdGlvbkhhbmRsZXJcIjtcbiAgQ2FwYWJpbGl0eTJbXCJUeXBlZERhdGFTaWduZXJcIl0gPSBcIklUeXBlZERhdGFTaWduZXJcIjtcbiAgQ2FwYWJpbGl0eTJbXCJHYXNFc3RpbWF0aW9uXCJdID0gXCJJR2FzRXN0aW1hdGlvblwiO1xuICBDYXBhYmlsaXR5MltcIlRva2VuT3BlcmF0aW9uc1wiXSA9IFwiSVRva2VuT3BlcmF0aW9uc1wiO1xuICBDYXBhYmlsaXR5MltcIlJQQ0hhbmRsZXJcIl0gPSBcIklSUENIYW5kbGVyXCI7XG4gIENhcGFiaWxpdHkyW1wiVHJhbnNhY3Rpb25TdGF0dXNcIl0gPSBcIklUcmFuc2FjdGlvblN0YXR1c1wiO1xuICBDYXBhYmlsaXR5MltcIkNvbnRyYWN0R2VuZXJhdG9yXCJdID0gXCJJQ29udHJhY3RHZW5lcmF0b3JcIjtcbiAgQ2FwYWJpbGl0eTJbXCJDb250cmFjdENvbXBpbGVyXCJdID0gXCJJQ29udHJhY3RDb21waWxlclwiO1xuICBDYXBhYmlsaXR5MltcIlF1b3RlUHJvdmlkZXJcIl0gPSBcIklRdW90ZVByb3ZpZGVyXCI7XG4gIENhcGFiaWxpdHkyW1wiT3BlcmF0aW9uSGFuZGxlclwiXSA9IFwiSU9wZXJhdGlvbkhhbmRsZXJcIjtcbiAgQ2FwYWJpbGl0eTJbXCJDaGFpbkRpc2NvdmVyeVwiXSA9IFwiSUNoYWluRGlzY292ZXJ5XCI7XG4gIENhcGFiaWxpdHkyW1wiR2FzRXN0aW1hdG9yXCJdID0gXCJJR2FzRXN0aW1hdG9yXCI7XG4gIENhcGFiaWxpdHkyW1wiT3BlcmF0aW9uTWFpbnRlbmFuY2VcIl0gPSBcIklPcGVyYXRpb25NYWludGVuYW5jZVwiO1xuICBDYXBhYmlsaXR5MltcIkFkYXB0ZXJJZGVudGl0eVwiXSA9IFwiSUFkYXB0ZXJJZGVudGl0eVwiO1xuICBDYXBhYmlsaXR5MltcIkFkYXB0ZXJMaWZlY3ljbGVcIl0gPSBcIklBZGFwdGVyTGlmZWN5Y2xlXCI7XG59KShDYXBhYmlsaXR5IHx8IChDYXBhYmlsaXR5ID0ge30pKTtcbnZhciBNZXRob2RUb0NhcGFiaWxpdHlNYXAgPSB7XG4gIC8vIC0tLSBJQ29yZVdhbGxldCAtLS1cbiAgXCJnZXRBY2NvdW50c1wiOiBDYXBhYmlsaXR5LkNvcmVXYWxsZXQsXG4gIFwiZ2V0QmFsYW5jZVwiOiBDYXBhYmlsaXR5LkNvcmVXYWxsZXQsXG4gIFwiZ2V0TmV0d29ya1wiOiBDYXBhYmlsaXR5LkNvcmVXYWxsZXQsXG4gIFwic2V0UHJvdmlkZXJcIjogQ2FwYWJpbGl0eS5Db3JlV2FsbGV0LFxuICBcImRpc2Nvbm5lY3RcIjogQ2FwYWJpbGl0eS5Db3JlV2FsbGV0LFxuICBcImlzQ29ubmVjdGVkXCI6IENhcGFiaWxpdHkuQ29yZVdhbGxldCxcbiAgLy8gLS0tIElUcmFuc2FjdGlvbkhhbmRsZXIgLS0tXG4gIFwic2VuZFRyYW5zYWN0aW9uXCI6IENhcGFiaWxpdHkuVHJhbnNhY3Rpb25IYW5kbGVyLFxuICAvLyAtLS0gSU1lc3NhZ2VTaWduZXIgLS0tXG4gIFwic2lnbk1lc3NhZ2VcIjogQ2FwYWJpbGl0eS5NZXNzYWdlU2lnbmVyLFxuICAvLyAtLS0gSVR5cGVkRGF0YVNpZ25lciAtLS1cbiAgXCJzaWduVHlwZWREYXRhXCI6IENhcGFiaWxpdHkuVHlwZWREYXRhU2lnbmVyLFxuICAvLyAtLS0gSUdhc0VzdGltYXRpb24gLS0tXG4gIFwiZXN0aW1hdGVHYXNcIjogQ2FwYWJpbGl0eS5HYXNFc3RpbWF0aW9uLFxuICAvLyAtLS0gSUV2ZW50RW1pdHRlciAtLS1cbiAgXCJvblwiOiBDYXBhYmlsaXR5LkV2ZW50RW1pdHRlcixcbiAgXCJvZmZcIjogQ2FwYWJpbGl0eS5FdmVudEVtaXR0ZXIsXG4gIFwiZW1pdFwiOiBDYXBhYmlsaXR5LkV2ZW50RW1pdHRlcixcbiAgLy8gLS0tIElUb2tlbk9wZXJhdGlvbnMgLS0tXG4gIFwiY2FsbENvbnRyYWN0XCI6IENhcGFiaWxpdHkuVG9rZW5PcGVyYXRpb25zLFxuICAvLyAtLS0gSVJQQ0hhbmRsZXIgLS0tXG4gIFwiZ2V0Q2hhaW5JZFwiOiBDYXBhYmlsaXR5LlJQQ0hhbmRsZXIsXG4gIFwiZ2V0R2FzUHJpY2VcIjogQ2FwYWJpbGl0eS5SUENIYW5kbGVyLFxuICBcImdldEJsb2NrTnVtYmVyXCI6IENhcGFiaWxpdHkuUlBDSGFuZGxlcixcbiAgLy8gLS0tIElUcmFuc2FjdGlvblN0YXR1cyAtLS1cbiAgXCJnZXRUcmFuc2FjdGlvblwiOiBDYXBhYmlsaXR5LlRyYW5zYWN0aW9uU3RhdHVzLFxuICBcIndhaXRGb3JUcmFuc2FjdGlvblwiOiBDYXBhYmlsaXR5LlRyYW5zYWN0aW9uU3RhdHVzLFxuICAvLyAtLS0gSUNvbnRyYWN0R2VuZXJhdG9yIC0tLVxuICBcImdlbmVyYXRlXCI6IENhcGFiaWxpdHkuQ29udHJhY3RHZW5lcmF0b3IsXG4gIC8vIC0tLSBJQ29udHJhY3RDb21waWxlciAtLS1cbiAgXCJjb21waWxlXCI6IENhcGFiaWxpdHkuQ29udHJhY3RDb21waWxlcixcbiAgLy8gLS0tIElRdW90ZVByb3ZpZGVyIC0tLVxuICBcImdldE9wZXJhdGlvblF1b3RlXCI6IENhcGFiaWxpdHkuUXVvdGVQcm92aWRlcixcbiAgLy8gLS0tIElPcGVyYXRpb25zIC0tLVxuICBcImV4ZWN1dGVPcGVyYXRpb25cIjogQ2FwYWJpbGl0eS5PcGVyYXRpb25IYW5kbGVyLFxuICBcImdldE9wZXJhdGlvblN0YXR1c1wiOiBDYXBhYmlsaXR5Lk9wZXJhdGlvbkhhbmRsZXIsXG4gIFwiY2FuY2VsT3BlcmF0aW9uXCI6IENhcGFiaWxpdHkuT3BlcmF0aW9uSGFuZGxlcixcbiAgXCJyZXN1bWVPcGVyYXRpb25cIjogQ2FwYWJpbGl0eS5PcGVyYXRpb25IYW5kbGVyLFxuICAvLyAtLS0gSUNoYWluRGlzY292ZXJ5IC0tLVxuICBcImdldFN1cHBvcnRlZENoYWluc1wiOiBDYXBhYmlsaXR5LkNoYWluRGlzY292ZXJ5LFxuICBcImdldFN1cHBvcnRlZFRva2Vuc1wiOiBDYXBhYmlsaXR5LkNoYWluRGlzY292ZXJ5LFxuICAvLyAtLS0gSUdhc0VzdGltYXRvciAtLS1cbiAgXCJnZXRHYXNPbkRlc3RpbmF0aW9uXCI6IENhcGFiaWxpdHkuR2FzRXN0aW1hdG9yLFxuICAvLyAtLS0gSU9wZXJhdGlvbk1haW50ZW5hbmNlIC0tLVxuICBcImNoZWNrRm9yVGltZWRPdXRPcGVyYXRpb25zXCI6IENhcGFiaWxpdHkuT3BlcmF0aW9uTWFpbnRlbmFuY2UsXG4gIC8vIC0tLSBJQWRhcHRlckxpZmVjeWNsZSAtLS1cbiAgXCJpbml0aWFsaXplXCI6IENhcGFiaWxpdHkuQWRhcHRlckxpZmVjeWNsZSxcbiAgXCJpc0luaXRpYWxpemVkXCI6IENhcGFiaWxpdHkuQWRhcHRlckxpZmVjeWNsZVxufTtcblxuLy8gcGFja2FnZXMvc2hhcmVkL2Rpc3QvZXJyb3JzL3Byb3h5LmpzXG5mdW5jdGlvbiBjcmVhdGVFcnJvckhhbmRsaW5nUHJveHkoYWRhcHRlckluc3RhbmNlLCBjYXBhYmlsaXRpZXMsIGVycm9yTWFwID0ge30sIGRlZmF1bHRFcnJvckNvZGUsIGNvbnRleHROYW1lID0gXCJVbmtub3duQWRhcHRlclwiKSB7XG4gIHJldHVybiBuZXcgUHJveHkoYWRhcHRlckluc3RhbmNlLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBTdHJpbmcocHJvcCk7XG4gICAgICBpZiAodHlwZW9mIG9yaWdpbmFsVmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCByZXF1aXJlZENhcGFiaWxpdHkgPSBNZXRob2RUb0NhcGFiaWxpdHlNYXBbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmIChyZXF1aXJlZENhcGFiaWxpdHkgJiYgIWNhcGFiaWxpdGllcy5pbmNsdWRlcyhyZXF1aXJlZENhcGFiaWxpdHkpKSB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYE1ldGhvZCAnJHttZXRob2ROYW1lfScgaXMgbm90IHN1cHBvcnRlZCBieSAke2NvbnRleHROYW1lfS4gSXQgbGFja3MgdGhlIHJlcXVpcmVkIGNhcGFiaWxpdHk6ICcke3JlcXVpcmVkQ2FwYWJpbGl0eX0nLmAsIHsgY29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLCBtZXRob2ROYW1lIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBc3luYyA9IG9yaWdpbmFsVmFsdWUuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCI7XG4gICAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxFcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7Y29udGV4dE5hbWV9IEVycm9yXSBNZXRob2QgJyR7bWV0aG9kTmFtZX0nIGZhaWxlZDogJHtvcmlnaW5hbEVycm9yTWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQWRhcHRlckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG1hcHBlZEVycm9yQ29kZSA9IGRlZmF1bHRFcnJvckNvZGU7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZXJyb3JNYXApIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEVycm9yTWVzc2FnZS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgIG1hcHBlZEVycm9yQ29kZSA9IGVycm9yTWFwW2tleV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGAke2NvbnRleHROYW1lfSBtZXRob2QgJyR7bWV0aG9kTmFtZX0nIGZhaWxlZDogJHtvcmlnaW5hbEVycm9yTWVzc2FnZX1gLCB7XG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgY29kZTogbWFwcGVkRXJyb3JDb2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBvcmlnaW5hbFZhbHVlLmFwcGx5KHRhcmdldCwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsVmFsdWUuYXBwbHkodGFyZ2V0LCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9zaGFyZWQvZGlzdC90eXBlcy9lcnJvci5qc1xudmFyIFdhbGxldEVycm9yQ29kZTtcbihmdW5jdGlvbihXYWxsZXRFcnJvckNvZGUyKSB7XG4gIFdhbGxldEVycm9yQ29kZTJbXCJVbmtub3duXCJdID0gXCJVTktOT1dOXCI7XG4gIFdhbGxldEVycm9yQ29kZTJbXCJlbnZpcm9ubWVudFwiXSA9IFwiRU5WSVJPTk1FTlRfTUlTTUFUQ0hcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIk5vdEltcGxlbWVudGVkXCJdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIkFkYXB0ZXJOb3RJbml0aWFsaXplZFwiXSA9IFwiQURBUFRFUl9OT1RfSU5JVElBTElaRURcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIldhbGxldE5vdENvbm5lY3RlZFwiXSA9IFwiV0FMTEVUX05PVF9DT05ORUNURURcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIlByb3ZpZGVyTm90Rm91bmRcIl0gPSBcIlBST1ZJREVSX05PVF9GT1VORFwiO1xuICBXYWxsZXRFcnJvckNvZGUyW1wiTmV0d29ya0Vycm9yXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gIFdhbGxldEVycm9yQ29kZTJbXCJVc2VyUmVqZWN0ZWRcIl0gPSBcIlVTRVJfUkVKRUNURURcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIkludmFsaWRJbnB1dFwiXSA9IFwiSU5WQUxJRF9JTlBVVFwiO1xuICBXYWxsZXRFcnJvckNvZGUyW1wiVHJhbnNhY3Rpb25GYWlsZWRcIl0gPSBcIlRSQU5TQUNUSU9OX0ZBSUxFRFwiO1xuICBXYWxsZXRFcnJvckNvZGUyW1wiU2lnbmF0dXJlRmFpbGVkXCJdID0gXCJTSUdOQVRVUkVfRkFJTEVEXCI7XG4gIFdhbGxldEVycm9yQ29kZTJbXCJNZXRob2ROb3RTdXBwb3J0ZWRcIl0gPSBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCI7XG4gIFdhbGxldEVycm9yQ29kZTJbXCJGZWF0dXJlTm90U3VwcG9ydGVkXCJdID0gXCJGRUFUVVJFX05PVF9TVVBQT1JURURcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIkFkYXB0ZXJOb3RGb3VuZFwiXSA9IFwiQURBUFRFUl9OT1RfRk9VTkRcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIk1pc3NpbmdDb25maWdcIl0gPSBcIk1JU1NJTkdfQ09ORklHXCI7XG4gIFdhbGxldEVycm9yQ29kZTJbXCJJbml0aWFsaXphdGlvbkZhaWxlZFwiXSA9IFwiSU5JVElBTElaQVRJT05fRkFJTEVEXCI7XG4gIFdhbGxldEVycm9yQ29kZTJbXCJDb25uZWN0aW9uRmFpbGVkXCJdID0gXCJDT05ORUNUSU9OX0ZBSUxFRFwiO1xuICBXYWxsZXRFcnJvckNvZGUyW1wiQWNjb3VudFVuYXZhaWxhYmxlXCJdID0gXCJBQ0NPVU5UX1VOQVZBSUxBQkxFXCI7XG4gIFdhbGxldEVycm9yQ29kZTJbXCJHYXNFc3RpbWF0aW9uRmFpbGVkXCJdID0gXCJHQVNfRVNUSU1BVElPTl9GQUlMRURcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIkluc3VmZmljaWVudEZ1bmRzXCJdID0gXCJJTlNVRkZJQ0lFTlRfRlVORFNcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIlRyYW5zYWN0aW9uUmVjZWlwdEZhaWxlZFwiXSA9IFwiVFJBTlNBQ1RJT05fUkVDRUlQVF9GQUlMRURcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIlRva2VuQmFsYW5jZUZhaWxlZFwiXSA9IFwiVE9LRU5fQkFMQU5DRV9GQUlMRURcIjtcbiAgV2FsbGV0RXJyb3JDb2RlMltcIlNpZ25pbmdGYWlsZWRcIl0gPSBcIklOVkFMSURfU0lHTkFUVVJFXCI7XG4gIFdhbGxldEVycm9yQ29kZTJbXCJDb250cmFjdENhbGxGYWlsZWRcIl0gPSBcIkNPTlRSQUNUIENBTEwgRkFJTEVEXCI7XG59KShXYWxsZXRFcnJvckNvZGUgfHwgKFdhbGxldEVycm9yQ29kZSA9IHt9KSk7XG52YXIgQ3Jvc3NDaGFpbkVycm9yQ29kZTtcbihmdW5jdGlvbihDcm9zc0NoYWluRXJyb3JDb2RlMikge1xuICBDcm9zc0NoYWluRXJyb3JDb2RlMltcIlJwY1ZhbGlkYXRpb25GYWlsZWRcIl0gPSBcIlJQQ19WQUxJREFUSU9OX0ZBSUxFRFwiO1xuICBDcm9zc0NoYWluRXJyb3JDb2RlMltcIlJwY1JlbGlhYmlsaXR5V2FybmluZ1wiXSA9IFwiUlBDX1JFTElBQklMSVRZX1dBUk5JTkdcIjtcbiAgQ3Jvc3NDaGFpbkVycm9yQ29kZTJbXCJVbmtub3duXCJdID0gXCJDQ19VTktOT1dOXCI7XG4gIENyb3NzQ2hhaW5FcnJvckNvZGUyW1wiQWRhcHRlck5vdEluaXRpYWxpemVkXCJdID0gXCJDQ19BREFQVEVSX05PVF9JTklUSUFMSVpFRFwiO1xuICBDcm9zc0NoYWluRXJyb3JDb2RlMltcIk5ldHdvcmtFcnJvclwiXSA9IFwiQ0NfTkVUV09SS19FUlJPUlwiO1xuICBDcm9zc0NoYWluRXJyb3JDb2RlMltcIkludmFsaWRJbnB1dFwiXSA9IFwiQ0NfSU5WQUxJRF9JTlBVVFwiO1xuICBDcm9zc0NoYWluRXJyb3JDb2RlMltcIlF1b3RlRmFpbGVkXCJdID0gXCJDQ19RVU9URV9GQUlMRURcIjtcbiAgQ3Jvc3NDaGFpbkVycm9yQ29kZTJbXCJFeGVjdXRpb25GYWlsZWRcIl0gPSBcIkNDX0VYRUNVVElPTl9GQUlMRURcIjtcbiAgQ3Jvc3NDaGFpbkVycm9yQ29kZTJbXCJQcm92aWRlclNldEZhaWxlZFwiXSA9IFwiQ0NfUFJPVklERVJfU0VUVVBfRkFJTEVEXCI7XG4gIENyb3NzQ2hhaW5FcnJvckNvZGUyW1wiU3RhdHVzQ2hlY2tGYWlsZWRcIl0gPSBcIkNDX1NUQVRVU19DSEVDS19GQUlMRURcIjtcbiAgQ3Jvc3NDaGFpbkVycm9yQ29kZTJbXCJVbnN1cHBvcnRlZENoYWluXCJdID0gXCJDQ19VTlNVUFBPUlRFRF9DSEFJTlwiO1xuICBDcm9zc0NoYWluRXJyb3JDb2RlMltcIlVuc3VwcG9ydGVkVG9rZW5cIl0gPSBcIkNDX1VOU1VQUE9SVEVEX1RPS0VOXCI7XG4gIENyb3NzQ2hhaW5FcnJvckNvZGUyW1wiT3BlcmF0aW9uTm90Rm91bmRcIl0gPSBcIkNDX09QRVJBVElPTl9OT1RfRk9VTkRcIjtcbn0pKENyb3NzQ2hhaW5FcnJvckNvZGUgfHwgKENyb3NzQ2hhaW5FcnJvckNvZGUgPSB7fSkpO1xudmFyIFNtYXJ0Q29udHJhY3RFcnJvckNvZGU7XG4oZnVuY3Rpb24oU21hcnRDb250cmFjdEVycm9yQ29kZTIpIHtcbiAgU21hcnRDb250cmFjdEVycm9yQ29kZTJbXCJVbmtub3duXCJdID0gXCJTQ19VTktOT1dOXCI7XG4gIFNtYXJ0Q29udHJhY3RFcnJvckNvZGUyW1wiQWRhcHRlck5vdEluaXRpYWxpemVkXCJdID0gXCJTQ19BREFQVEVSX05PVF9JTklUSUFMSVpFRFwiO1xuICBTbWFydENvbnRyYWN0RXJyb3JDb2RlMltcIk5ldHdvcmtFcnJvclwiXSA9IFwiU0NfTkVUV09SS19FUlJPUlwiO1xuICBTbWFydENvbnRyYWN0RXJyb3JDb2RlMltcIkludmFsaWRJbnB1dFwiXSA9IFwiU0NfSU5WQUxJRF9JTlBVVFwiO1xuICBTbWFydENvbnRyYWN0RXJyb3JDb2RlMltcIkNvbXBpbGF0aW9uRmFpbGVkXCJdID0gXCJTQ19DT01QSUxBVElPTl9GQUlMRURcIjtcbiAgU21hcnRDb250cmFjdEVycm9yQ29kZTJbXCJEZXBsb3ltZW50RmFpbGVkXCJdID0gXCJTQ19ERVBMT1lNRU5UX0ZBSUxFRFwiO1xuICBTbWFydENvbnRyYWN0RXJyb3JDb2RlMltcIk1ldGhvZENhbGxGYWlsZWRcIl0gPSBcIlNDX01FVEhPRF9DQUxMX0ZBSUxFRFwiO1xuICBTbWFydENvbnRyYWN0RXJyb3JDb2RlMltcIlJlYWRDYWxsRmFpbGVkXCJdID0gXCJTQ19SRUFEX0NBTExfRkFJTEVEXCI7XG4gIFNtYXJ0Q29udHJhY3RFcnJvckNvZGUyW1wiV3JpdGVDYWxsRmFpbGVkXCJdID0gXCJTQ19XUklURV9DQUxMX0ZBSUxFRFwiO1xuICBTbWFydENvbnRyYWN0RXJyb3JDb2RlMltcIkludmFsaWRBYmlcIl0gPSBcIlNDX0lOVkFMSURfQUJJXCI7XG4gIFNtYXJ0Q29udHJhY3RFcnJvckNvZGUyW1wiQ29udHJhY3ROb3RGb3VuZFwiXSA9IFwiU0NfQ09OVFJBQ1RfTk9UX0ZPVU5EXCI7XG4gIFNtYXJ0Q29udHJhY3RFcnJvckNvZGUyW1wiV2FsbGV0UmVxdWlyZWRcIl0gPSBcIlNDX1dBTExFVF9SRVFVSVJFRFwiO1xufSkoU21hcnRDb250cmFjdEVycm9yQ29kZSB8fCAoU21hcnRDb250cmFjdEVycm9yQ29kZSA9IHt9KSk7XG5cbi8vIHBhY2thZ2VzL3NoYXJlZC9kaXN0L3R5cGVzL3JlZ2lzdHJ5LmpzXG52YXIgTXMzTW9kdWxlcztcbihmdW5jdGlvbihNczNNb2R1bGVzMikge1xuICBNczNNb2R1bGVzMltcIndhbGxldFwiXSA9IFwid2FsbGV0XCI7XG4gIE1zM01vZHVsZXMyW1wic21hcnRjb250cmFjdFwiXSA9IFwic21hcnQtY29udHJhY3RcIjtcbiAgTXMzTW9kdWxlczJbXCJjcm9zc2NoYWluXCJdID0gXCJjcm9zc2NoYWluXCI7XG59KShNczNNb2R1bGVzIHx8IChNczNNb2R1bGVzID0ge30pKTtcbnZhciBSdW50aW1lRW52aXJvbm1lbnQ7XG4oZnVuY3Rpb24oUnVudGltZUVudmlyb25tZW50Mikge1xuICBSdW50aW1lRW52aXJvbm1lbnQyW1wiQlJPV1NFUlwiXSA9IFwiYnJvd3NlclwiO1xuICBSdW50aW1lRW52aXJvbm1lbnQyW1wiU0VSVkVSXCJdID0gXCJzZXJ2ZXJcIjtcbn0pKFJ1bnRpbWVFbnZpcm9ubWVudCB8fCAoUnVudGltZUVudmlyb25tZW50ID0ge30pKTtcblxuLy8gcGFja2FnZXMvc2hhcmVkL2Rpc3QvaGVscGVycy9lbnZpcm9ubWVudC5qc1xuZnVuY3Rpb24gZGV0ZWN0UnVudGltZUVudmlyb25tZW50KCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSB7XG4gICAgcmVzdWx0LnB1c2goUnVudGltZUVudmlyb25tZW50LlNFUlZFUik7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzdWx0LnB1c2goUnVudGltZUVudmlyb25tZW50LkJST1dTRVIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUVudmlyb25tZW50KGFkYXB0ZXJOYW1lLCByZXF1aXJlbWVudHMpIHtcbiAgY29uc3QgY3VycmVudEVudnMgPSBkZXRlY3RSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSBjdXJyZW50RW52cy5zb21lKChlbnYpID0+IHJlcXVpcmVtZW50cy5zdXBwb3J0ZWRFbnZpcm9ubWVudHMuaW5jbHVkZXMoZW52KSk7XG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICBjb25zdCBzdXBwb3J0ZWRMaXN0ID0gcmVxdWlyZW1lbnRzLnN1cHBvcnRlZEVudmlyb25tZW50cy5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgZGV0ZWN0ZWRMaXN0ID0gY3VycmVudEVudnMuam9pbihcIiwgXCIpO1xuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgQWRhcHRlciAnJHthZGFwdGVyTmFtZX0nIHJlcXVpcmVzICR7c3VwcG9ydGVkTGlzdH0gZW52aXJvbm1lbnQgYnV0IGRldGVjdGVkICR7ZGV0ZWN0ZWRMaXN0fS5gO1xuICAgIGlmIChyZXF1aXJlbWVudHMubGltaXRhdGlvbnMpIHtcbiAgICAgIGVycm9yTWVzc2FnZSArPSBcIlxcblwiICsgcmVxdWlyZW1lbnRzLmxpbWl0YXRpb25zLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoZXJyb3JNZXNzYWdlLCB7XG4gICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuZW52aXJvbm1lbnQsXG4gICAgICBtZXRob2ROYW1lOiBcInZhbGlkYXRlRW52aXJvbm1lbnRcIixcbiAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgYWRhcHRlck5hbWUsXG4gICAgICAgIGN1cnJlbnRFbnZpcm9ubWVudDogY3VycmVudEVudnMsXG4gICAgICAgIC8vIOKchSBOb3cgYXJyYXlcbiAgICAgICAgc3VwcG9ydGVkRW52aXJvbm1lbnRzOiByZXF1aXJlbWVudHMuc3VwcG9ydGVkRW52aXJvbm1lbnRzLFxuICAgICAgICBsaW1pdGF0aW9uczogcmVxdWlyZW1lbnRzLmxpbWl0YXRpb25zXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlcXVpcmVtZW50cy5zZWN1cml0eU5vdGVzICYmIHJlcXVpcmVtZW50cy5zZWN1cml0eU5vdGVzLmxlbmd0aCA+IDApIHtcbiAgICByZXF1aXJlbWVudHMuc2VjdXJpdHlOb3Rlcy5mb3JFYWNoKChub3RlKSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oYFske2FkYXB0ZXJOYW1lfV0gU2VjdXJpdHkgTm90ZTogJHtub3RlfWApO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL3NoYXJlZC9kaXN0L3JlZ2lzdHJ5L2NvbXBhdGliaWxpdHkuanNcbnZhciBXQUxMRVRfQ09NUEFUSUJJTElUWSA9IHtcbiAgXCJldGhlcnNAMS4wLjBcIjoge1xuICAgIGFkYXB0ZXJOYW1lOiBcImV0aGVyc1wiLFxuICAgIHZlcnNpb246IFwiMS4wLjBcIixcbiAgICBjb21wYXRpYmxlVmVyc2lvbnM6IFtcIjEuMC4wXCJdLFxuICAgIGJyZWFraW5nQ2hhbmdlczogW10sXG4gICAgY3Jvc3NNb2R1bGVDb21wYXRpYmlsaXR5OiBbXG4gICAgICB7XG4gICAgICAgIG1vZHVsZU5hbWU6IFwic21hcnQtY29udHJhY3RcIixcbiAgICAgICAgLy8g4pyFIFRoaXMgd2FsbGV0IGNhbiB3b3JrIHdpdGggYW55IHNtYXJ0LWNvbnRyYWN0IGFkYXB0ZXIgdGhhdCBjYW4gZ2VuZXJhdGUgY29udHJhY3RzLlxuICAgICAgICByZXF1aXJlc0NhcGFiaWxpdGllczogW0NhcGFiaWxpdHkuQ29udHJhY3RHZW5lcmF0b3JdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBtb2R1bGVOYW1lOiBcImNyb3NzY2hhaW5cIixcbiAgICAgICAgLy8g4pyFIFRoaXMgd2FsbGV0IGNhbiB3b3JrIHdpdGggYW55IGNyb3NzY2hhaW4gYWRhcHRlciB0aGF0IGNhbiBleGVjdXRlIG9wZXJhdGlvbnMuXG4gICAgICAgIHJlcXVpcmVzQ2FwYWJpbGl0aWVzOiBbQ2FwYWJpbGl0eS5PcGVyYXRpb25IYW5kbGVyXVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAgXCJ3ZWIzYXV0aEAxLjAuMFwiOiB7XG4gICAgYWRhcHRlck5hbWU6IFwid2ViM2F1dGhcIixcbiAgICB2ZXJzaW9uOiBcIjEuMC4wXCIsXG4gICAgY29tcGF0aWJsZVZlcnNpb25zOiBbXCIxLjAuMFwiXSxcbiAgICBicmVha2luZ0NoYW5nZXM6IFtdLFxuICAgIGNyb3NzTW9kdWxlQ29tcGF0aWJpbGl0eTogW1xuICAgICAge1xuICAgICAgICBtb2R1bGVOYW1lOiBcInNtYXJ0LWNvbnRyYWN0XCIsXG4gICAgICAgIC8vIOKchSBUaGlzIHdhbGxldCBjYW4gd29yayB3aXRoIGFueSBzbWFydC1jb250cmFjdCBhZGFwdGVyIHRoYXQgY2FuIGdlbmVyYXRlIGNvbnRyYWN0cy5cbiAgICAgICAgcmVxdWlyZXNDYXBhYmlsaXRpZXM6IFtDYXBhYmlsaXR5LkNvbnRyYWN0R2VuZXJhdG9yXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbW9kdWxlTmFtZTogXCJjcm9zc2NoYWluXCIsXG4gICAgICAgIC8vIOKchSBUaGlzIHdhbGxldCBjYW4gd29yayB3aXRoIGFueSBjcm9zc2NoYWluIGFkYXB0ZXIgdGhhdCBjYW4gZXhlY3V0ZSBvcGVyYXRpb25zLlxuICAgICAgICByZXF1aXJlc0NhcGFiaWxpdGllczogW0NhcGFiaWxpdHkuT3BlcmF0aW9uSGFuZGxlcl1cbiAgICAgIH1cbiAgICBdXG4gIH1cbn07XG52YXIgU01BUlRfQ09OVFJBQ1RfQ09NUEFUSUJJTElUWSA9IHtcbiAgXCJvcGVuWmVwcGVsaW5AMS4wLjBcIjoge1xuICAgIGFkYXB0ZXJOYW1lOiBcIm9wZW5aZXBwZWxpblwiLFxuICAgIHZlcnNpb246IFwiMS4wLjBcIixcbiAgICBjb21wYXRpYmxlVmVyc2lvbnM6IFtcIjEuMC4wXCJdLFxuICAgIGJyZWFraW5nQ2hhbmdlczogW10sXG4gICAgY3Jvc3NNb2R1bGVDb21wYXRpYmlsaXR5OiBbXG4gICAgICB7XG4gICAgICAgIG1vZHVsZU5hbWU6IFwid2FsbGV0XCIsXG4gICAgICAgIC8vIOKchSBUaGlzIHNtYXJ0LWNvbnRyYWN0IGFkYXB0ZXIgbmVlZHMgYSB3YWxsZXQgdGhhdCBjYW4gaGFuZGxlIHRyYW5zYWN0aW9ucy5cbiAgICAgICAgcmVxdWlyZXNDYXBhYmlsaXRpZXM6IFtDYXBhYmlsaXR5LlRyYW5zYWN0aW9uSGFuZGxlciwgQ2FwYWJpbGl0eS5SUENIYW5kbGVyXVxuICAgICAgfVxuICAgIF1cbiAgfVxufTtcbnZhciBDUk9TU0NIQUlOX0NPTVBBVElCSUxJVFkgPSB7XG4gIFwibGlmaUAxLjAuMFwiOiB7XG4gICAgYWRhcHRlck5hbWU6IFwibGlmaVwiLFxuICAgIHZlcnNpb246IFwiMS4wLjBcIixcbiAgICBjb21wYXRpYmxlVmVyc2lvbnM6IFtcIjEuMC4wXCJdLFxuICAgIGJyZWFraW5nQ2hhbmdlczogW10sXG4gICAgY3Jvc3NNb2R1bGVDb21wYXRpYmlsaXR5OiBbXG4gICAgICB7XG4gICAgICAgIG1vZHVsZU5hbWU6IFwid2FsbGV0XCIsXG4gICAgICAgIC8vIOKchSBUaGlzIGNyb3NzY2hhaW4gYWRhcHRlciBuZWVkcyBhIHdhbGxldCB0aGF0IGNhbiBoYW5kbGUgdHJhbnNhY3Rpb25zIGFuZCBSUEMgY2FsbHMuXG4gICAgICAgIHJlcXVpcmVzQ2FwYWJpbGl0aWVzOiBbQ2FwYWJpbGl0eS5UcmFuc2FjdGlvbkhhbmRsZXIsIENhcGFiaWxpdHkuUlBDSGFuZGxlcl1cbiAgICAgIH1cbiAgICBdXG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTdGF0aWNDb21wYXRpYmlsaXR5TWF0cml4KG1vZHVsZU5hbWUsIGFkYXB0ZXJOYW1lLCB2ZXJzaW9uKSB7XG4gIGNvbnN0IGtleSA9IGAke2FkYXB0ZXJOYW1lfUAke3ZlcnNpb259YDtcbiAgc3dpdGNoIChtb2R1bGVOYW1lKSB7XG4gICAgY2FzZSBcIndhbGxldFwiOlxuICAgICAgcmV0dXJuIFdBTExFVF9DT01QQVRJQklMSVRZW2tleV07XG4gICAgY2FzZSBcInNtYXJ0LWNvbnRyYWN0XCI6XG4gICAgICByZXR1cm4gU01BUlRfQ09OVFJBQ1RfQ09NUEFUSUJJTElUWVtrZXldO1xuICAgIGNhc2UgXCJjcm9zc2NoYWluXCI6XG4gICAgICByZXR1cm4gQ1JPU1NDSEFJTl9DT01QQVRJQklMSVRZW2tleV07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ3Jvc3NQYWNrYWdlQ29tcGF0aWJpbGl0eShzb3VyY2VNb2R1bGUsIHNvdXJjZUFkYXB0ZXIsIHNvdXJjZVZlcnNpb24sIHRhcmdldE1vZHVsZSwgdGFyZ2V0QWRhcHRlciwgdGFyZ2V0VmVyc2lvbikge1xuICBjb25zdCBzb3VyY2VNYXRyaXggPSBnZXRTdGF0aWNDb21wYXRpYmlsaXR5TWF0cml4KHNvdXJjZU1vZHVsZSwgc291cmNlQWRhcHRlciwgc291cmNlVmVyc2lvbik7XG4gIGlmICghc291cmNlTWF0cml4KVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdGFyZ2V0TW9kdWxlQ29tcGF0UnVsZSA9IHNvdXJjZU1hdHJpeC5jcm9zc01vZHVsZUNvbXBhdGliaWxpdHkuZmluZCgoY21jKSA9PiBjbWMubW9kdWxlTmFtZSA9PT0gdGFyZ2V0TW9kdWxlKTtcbiAgaWYgKCF0YXJnZXRNb2R1bGVDb21wYXRSdWxlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdGFyZ2V0QWRhcHRlckluZm8gPSByZWdpc3RyeS5nZXRBZGFwdGVyKHRhcmdldE1vZHVsZSwgdGFyZ2V0QWRhcHRlciwgdGFyZ2V0VmVyc2lvbik7XG4gIGlmICghdGFyZ2V0QWRhcHRlckluZm8/LmNhcGFiaWxpdGllcylcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHNvdXJjZUFkYXB0ZXJJbmZvID0gcmVnaXN0cnkuZ2V0QWRhcHRlcihzb3VyY2VNb2R1bGUsIHNvdXJjZUFkYXB0ZXIsIHNvdXJjZVZlcnNpb24pO1xuICBjb25zdCBjdXJyZW50RW52aXJvbm1lbnRzID0gZGV0ZWN0UnVudGltZUVudmlyb25tZW50KCk7XG4gIGlmIChzb3VyY2VBZGFwdGVySW5mbz8uZW52aXJvbm1lbnQgJiYgIXNvdXJjZUFkYXB0ZXJJbmZvLmVudmlyb25tZW50LnN1cHBvcnRlZEVudmlyb25tZW50cy5zb21lKChlbnYpID0+IGN1cnJlbnRFbnZpcm9ubWVudHMuaW5jbHVkZXMoZW52KSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRhcmdldEFkYXB0ZXJJbmZvLmVudmlyb25tZW50ICYmICF0YXJnZXRBZGFwdGVySW5mby5lbnZpcm9ubWVudC5zdXBwb3J0ZWRFbnZpcm9ubWVudHMuc29tZSgoZW52KSA9PiBjdXJyZW50RW52aXJvbm1lbnRzLmluY2x1ZGVzKGVudikpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0YXJnZXRNb2R1bGVDb21wYXRSdWxlLnJlcXVpcmVzQ2FwYWJpbGl0aWVzLmV2ZXJ5KChyZXF1aXJlZENhcCkgPT4gdGFyZ2V0QWRhcHRlckluZm8uY2FwYWJpbGl0aWVzLmluY2x1ZGVzKHJlcXVpcmVkQ2FwKSk7XG59XG5cbi8vIHBhY2thZ2VzL3NoYXJlZC9kaXN0L3JlZ2lzdHJ5L3JlZ2lzdHJ5LmpzXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUJ5UGF0aChvYmosIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3BsaXQoXCIuXCIpLnJlZHVjZSgoY3VycmVudE9iamVjdCwga2V5KSA9PiB7XG4gICAgcmV0dXJuIGN1cnJlbnRPYmplY3QgJiYgdHlwZW9mIGN1cnJlbnRPYmplY3QgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnJlbnRPYmplY3QsIGtleSkgPyBjdXJyZW50T2JqZWN0W2tleV0gOiB2b2lkIDA7XG4gIH0sIG9iaik7XG59XG52YXIgVW5pdmVyc2FsUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb2R1bGVzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhZGFwdGVyc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29tcGF0aWJpbGl0eU1hdHJpY2VzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbnRlcmZhY2VTaGFwZXNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH1cbiAgLy8g4pyFIEFERDogVGhlIG1pc3NpbmcgbWFwXG4gIC8qKlxuICAqIOKchSBORVc6IFJlZ2lzdGVyIHRoZSBzaGFwZSBvZiBhIGNvbnZlbmllbmNlIGFsaWFzLlxuICAqIFRoaXMgaXMgY2FsbGVkIGJ5IG1vZHVsZXMgKGUuZy4sIHdhbGxldC9pbmRleC50cykgdG8gZGVmaW5lIHRoZWlyIGFsaWFzZXMuXG4gICogQHBhcmFtIGludGVyZmFjZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGFsaWFzIChlLmcuLCAnSUVWTVdhbGxldCcpLlxuICAqIEBwYXJhbSByZXF1aXJlZENhcGFiaWxpdGllcyBBbiBhcnJheSBvZiBiYXNlIGNhcGFiaWxpdHkgbmFtZXMgaXQgcmVxdWlyZXMuXG4gICovXG4gIHJlZ2lzdGVySW50ZXJmYWNlU2hhcGUoaW50ZXJmYWNlTmFtZSwgcmVxdWlyZWRDYXBhYmlsaXRpZXMpIHtcbiAgICB0aGlzLmludGVyZmFjZVNoYXBlcy5zZXQoaW50ZXJmYWNlTmFtZSwgcmVxdWlyZWRDYXBhYmlsaXRpZXMpO1xuICB9XG4gIC8qKlxuICAgKiDinIUgTkVXOiBHZXQgdGhlIHNoYXBlIG9mIGEgY29udmVuaWVuY2UgYWxpYXMuXG4gICAqIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSB2YWxpZGF0b3IgdG8gdmVyaWZ5IGFuIGFkYXB0ZXIgbWVldHMgYW4gaW50ZXJmYWNlJ3MgcmVxdWlyZW1lbnRzLlxuICAgKi9cbiAgZ2V0SW50ZXJmYWNlU2hhcGUoaW50ZXJmYWNlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmludGVyZmFjZVNoYXBlcy5nZXQoaW50ZXJmYWNlTmFtZSk7XG4gIH1cbiAgLyoqXG4gICog4pyFIE5FVzogQSBtb2Rlcm4gcmVwbGFjZW1lbnQgZm9yIGZpbmRBZGFwdGVyc1dpdGhGZWF0dXJlIHRoYXQgdXNlcyBvdXIgbmV3IGFyY2hpdGVjdHVyZS5cbiAgKiBGaW5kcyBhbGwgYWRhcHRlcnMgdGhhdCBoYXZlIGEgc3BlY2lmaWMgY2FwYWJpbGl0eS5cbiAgKi9cbiAgZmluZEFkYXB0ZXJzV2l0aENhcGFiaWxpdHkoY2FwYWJpbGl0eSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgbW9kdWxlQWRhcHRlcnMgb2YgdGhpcy5hZGFwdGVycy52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiBtb2R1bGVBZGFwdGVycy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAobWV0YWRhdGEuY2FwYWJpbGl0aWVzPy5pbmNsdWRlcyhjYXBhYmlsaXR5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAqIEdldCBjb21wYXRpYmlsaXR5IG1hdHJpeCBmb3IgYW4gYWRhcHRlclxuICAqL1xuICBnZXRDb21wYXRpYmlsaXR5TWF0cml4KG1vZHVsZU5hbWUsIG5hbWUsIHZlcnNpb24pIHtcbiAgICBjb25zdCBtb2R1bGVNYXRyaWNlcyA9IHRoaXMuY29tcGF0aWJpbGl0eU1hdHJpY2VzLmdldChtb2R1bGVOYW1lKTtcbiAgICBpZiAoIW1vZHVsZU1hdHJpY2VzKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBrZXkgPSBgJHtuYW1lfUAke3ZlcnNpb259YDtcbiAgICByZXR1cm4gbW9kdWxlTWF0cmljZXMuZ2V0KGtleSk7XG4gIH1cbiAgLyoqXG4gICogR2V0IGxhdGVzdCB2ZXJzaW9uIG9mIGFuIGFkYXB0ZXJcbiAgKi9cbiAgZ2V0TGF0ZXN0VmVyc2lvbihtb2R1bGVOYW1lLCBuYW1lKSB7XG4gICAgY29uc3QgbGF0ZXN0ID0gdGhpcy5nZXRMYXRlc3RBZGFwdGVyKG1vZHVsZU5hbWUsIG5hbWUpO1xuICAgIHJldHVybiBsYXRlc3Q/LnZlcnNpb247XG4gIH1cbiAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjb21wYXRpYmlsaXR5IG1hdHJpeCBmb3IgYW4gYWRhcHRlclxuICAgICAqL1xuICByZWdpc3RlckNvbXBhdGliaWxpdHlNYXRyaXgobW9kdWxlTmFtZSwgbWF0cml4KSB7XG4gICAgaWYgKCF0aGlzLmNvbXBhdGliaWxpdHlNYXRyaWNlcy5oYXMobW9kdWxlTmFtZSkpIHtcbiAgICAgIHRoaXMuY29tcGF0aWJpbGl0eU1hdHJpY2VzLnNldChtb2R1bGVOYW1lLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlTWF0cmljZXMgPSB0aGlzLmNvbXBhdGliaWxpdHlNYXRyaWNlcy5nZXQobW9kdWxlTmFtZSk7XG4gICAgY29uc3Qga2V5ID0gYCR7bWF0cml4LmFkYXB0ZXJOYW1lfUAke21hdHJpeC52ZXJzaW9ufWA7XG4gICAgbW9kdWxlTWF0cmljZXMuc2V0KGtleSwgbWF0cml4KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgY29tcGF0aWJpbGl0eSBiZXR3ZWVuIGFkYXB0ZXIgdmVyc2lvbnNcbiAgICovXG4gIGNoZWNrQWRhcHRlckNvbXBhdGliaWxpdHkobW9kdWxlTmFtZSwgbmFtZSwgdmVyc2lvbnMpIHtcbiAgICBjb25zdCByZXBvcnQgPSB7XG4gICAgICBjb21wYXRpYmxlOiB0cnVlLFxuICAgICAgY29uZmxpY3RzOiBbXSxcbiAgICAgIHJlY29tbWVuZGF0aW9uczogW10sXG4gICAgICBzdXBwb3J0ZWRWZXJzaW9uczogW11cbiAgICB9O1xuICAgIGNvbnN0IG1vZHVsZUFkYXB0ZXJzID0gdGhpcy5hZGFwdGVycy5nZXQobW9kdWxlTmFtZSk7XG4gICAgaWYgKCFtb2R1bGVBZGFwdGVycykge1xuICAgICAgcmVwb3J0LmNvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgIHJlcG9ydC5jb25mbGljdHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidmVyc2lvblwiLFxuICAgICAgICBzZXZlcml0eTogXCJlcnJvclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYE1vZHVsZSAnJHttb2R1bGVOYW1lfScgbm90IGZvdW5kYCxcbiAgICAgICAgYWZmZWN0ZWRWZXJzaW9uczogdmVyc2lvbnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcG9ydDtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHZlcnNpb25zKSB7XG4gICAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5nZXRBZGFwdGVyKG1vZHVsZU5hbWUsIG5hbWUsIHZlcnNpb24pO1xuICAgICAgaWYgKCFhZGFwdGVyKSB7XG4gICAgICAgIHJlcG9ydC5jb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgIHJlcG9ydC5jb25mbGljdHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ2ZXJzaW9uXCIsXG4gICAgICAgICAgc2V2ZXJpdHk6IFwiZXJyb3JcIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEFkYXB0ZXIgJyR7bmFtZX0nIHZlcnNpb24gJyR7dmVyc2lvbn0nIG5vdCBmb3VuZGAsXG4gICAgICAgICAgYWZmZWN0ZWRWZXJzaW9uczogW3ZlcnNpb25dXG4gICAgICAgIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlcG9ydC5zdXBwb3J0ZWRWZXJzaW9ucy5wdXNoKHZlcnNpb24pO1xuICAgICAgY29uc3QgbWF0cml4ID0gdGhpcy5nZXRDb21wYXRpYmlsaXR5TWF0cml4KG1vZHVsZU5hbWUsIG5hbWUsIHZlcnNpb24pO1xuICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICBmb3IgKGNvbnN0IG90aGVyVmVyc2lvbiBvZiB2ZXJzaW9ucykge1xuICAgICAgICAgIGlmICh2ZXJzaW9uICE9PSBvdGhlclZlcnNpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGJyZWFraW5nQ2hhbmdlID0gbWF0cml4LmJyZWFraW5nQ2hhbmdlcy5maW5kKChiYykgPT4gYmMuZnJvbVZlcnNpb24gPT09IG90aGVyVmVyc2lvbiB8fCBiYy50b1ZlcnNpb24gPT09IG90aGVyVmVyc2lvbik7XG4gICAgICAgICAgICBpZiAoYnJlYWtpbmdDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgcmVwb3J0LmNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJyZWFraW5nLWNoYW5nZVwiLFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiBcIndhcm5pbmdcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYEJyZWFraW5nIGNoYW5nZXMgYmV0d2VlbiAke2JyZWFraW5nQ2hhbmdlLmZyb21WZXJzaW9ufSBhbmQgJHticmVha2luZ0NoYW5nZS50b1ZlcnNpb259OiAke2JyZWFraW5nQ2hhbmdlLmNoYW5nZXMuam9pbihcIiwgXCIpfWAsXG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRWZXJzaW9uczogW2JyZWFraW5nQ2hhbmdlLmZyb21WZXJzaW9uLCBicmVha2luZ0NoYW5nZS50b1ZlcnNpb25dLFxuICAgICAgICAgICAgICAgIHN1Z2dlc3RlZEFjdGlvbjogYnJlYWtpbmdDaGFuZ2UubWlncmF0aW9uUGF0aFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlcG9ydC5jb25mbGljdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXBvcnQucmVjb21tZW5kYXRpb25zLnB1c2goXCJBbGwgc3BlY2lmaWVkIHZlcnNpb25zIGFyZSBjb21wYXRpYmxlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXRlc3RWZXJzaW9uID0gdGhpcy5nZXRMYXRlc3RWZXJzaW9uKG1vZHVsZU5hbWUsIG5hbWUpO1xuICAgICAgaWYgKGxhdGVzdFZlcnNpb24pIHtcbiAgICAgICAgcmVwb3J0LnJlY29tbWVuZGF0aW9ucy5wdXNoKGBDb25zaWRlciB1c2luZyBsYXRlc3QgdmVyc2lvbjogJHtsYXRlc3RWZXJzaW9ufWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVwb3J0O1xuICB9XG4gIC8qKlxuICAqIEdldCBhZGFwdGVycyBjb21wYXRpYmxlIHdpdGggYSBzcGVjaWZpYyBhZGFwdGVyIGluc3RhbmNlXG4gICovXG4gIGdldENvbXBhdGlibGVBZGFwdGVycyhjdXJyZW50QWRhcHRlciwgdGFyZ2V0TW9kdWxlTmFtZSkge1xuICAgIGNvbnN0IGNvbXBhdGlibGVBZGFwdGVycyA9IFtdO1xuICAgIGNvbnN0IG1vZHVsZXNUb0NoZWNrID0gdGFyZ2V0TW9kdWxlTmFtZSA/IFt0YXJnZXRNb2R1bGVOYW1lXSA6IEFycmF5LmZyb20odGhpcy5hZGFwdGVycy5rZXlzKCkpO1xuICAgIGZvciAoY29uc3QgbW9kdWxlTmFtZSBvZiBtb2R1bGVzVG9DaGVjaykge1xuICAgICAgaWYgKG1vZHVsZU5hbWUgPT09IGN1cnJlbnRBZGFwdGVyLm1vZHVsZU5hbWUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbW9kdWxlQWRhcHRlcnMgPSB0aGlzLmFkYXB0ZXJzLmdldChtb2R1bGVOYW1lKTtcbiAgICAgIGlmICghbW9kdWxlQWRhcHRlcnMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZm9yIChjb25zdCBbLCB0YXJnZXRBZGFwdGVyTWV0YWRhdGFdIG9mIG1vZHVsZUFkYXB0ZXJzKSB7XG4gICAgICAgIGNvbnN0IGlzQ29tcGF0aWJsZSA9IGNoZWNrQ3Jvc3NQYWNrYWdlQ29tcGF0aWJpbGl0eShjdXJyZW50QWRhcHRlci5tb2R1bGVOYW1lLCBjdXJyZW50QWRhcHRlci5uYW1lLCBjdXJyZW50QWRhcHRlci52ZXJzaW9uLCB0YXJnZXRBZGFwdGVyTWV0YWRhdGEubW9kdWxlLCB0YXJnZXRBZGFwdGVyTWV0YWRhdGEubmFtZSwgdGFyZ2V0QWRhcHRlck1ldGFkYXRhLnZlcnNpb24pO1xuICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgY29tcGF0aWJsZUFkYXB0ZXJzLnB1c2godGFyZ2V0QWRhcHRlck1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tcGF0aWJsZUFkYXB0ZXJzO1xuICB9XG4gIC8qKlxuICAgKiBCYXRjaCByZWdpc3RlciBhZGFwdGVycyB3aXRoIGF0b21pYyByb2xsYmFja1xuICAgKi9cbiAgcmVnaXN0ZXJBZGFwdGVycyhhZGFwdGVycykge1xuICAgIGNvbnN0IG9yaWdpbmFsU3RhdGUgPSBuZXcgTWFwKHRoaXMuYWRhcHRlcnMpO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGNvbnN0IGFkYXB0ZXIgb2YgYWRhcHRlcnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckFkYXB0ZXIoYWRhcHRlci5tb2R1bGUsIGFkYXB0ZXIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJzID0gb3JpZ2luYWxTdGF0ZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmF0Y2ggcmVnaXN0cmF0aW9uIGZhaWxlZDogJHtlcnJvcn0uIFN0YXRlIHJvbGxlZCBiYWNrLmApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBtb2R1bGUgaW4gdGhlIHJlZ2lzdHJ5XG4gICAqL1xuICByZWdpc3Rlck1vZHVsZShtZXRhZGF0YSkge1xuICAgIHRoaXMubW9kdWxlcy5zZXQobWV0YWRhdGEubmFtZSwgbWV0YWRhdGEpO1xuICAgIGlmICghdGhpcy5hZGFwdGVycy5oYXMobWV0YWRhdGEubmFtZSkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcnMuc2V0KG1ldGFkYXRhLm5hbWUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gYWRhcHRlciBmb3IgYSBzcGVjaWZpYyBtb2R1bGVcbiAgICovXG4gIHJlZ2lzdGVyQWRhcHRlcihtb2R1bGVOYW1lLCBtZXRhZGF0YSkge1xuICAgIGlmICghdGhpcy5tb2R1bGVzLmhhcyhtb2R1bGVOYW1lKSkge1xuICAgICAgY29uc3QgbW9kdWxlTWV0YWRhdGEgPSB7XG4gICAgICAgIG5hbWU6IG1vZHVsZU5hbWUsXG4gICAgICAgIHZlcnNpb246IG1ldGFkYXRhLnZlcnNpb25cbiAgICAgICAgLy8gVXNlIGFkYXB0ZXIncyB2ZXJzaW9uIGFzIGRlZmF1bHQgbW9kdWxlIHZlcnNpb25cbiAgICAgIH07XG4gICAgICB0aGlzLnJlZ2lzdGVyTW9kdWxlKG1vZHVsZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlQWRhcHRlcnMgPSB0aGlzLmFkYXB0ZXJzLmdldChtb2R1bGVOYW1lKTtcbiAgICBpZiAoIW1vZHVsZUFkYXB0ZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1vZHVsZSAke21vZHVsZU5hbWV9IG5vdCBwcm9wZXJseSBpbml0aWFsaXplZCBpbiByZWdpc3RyeWApO1xuICAgIH1cbiAgICBjb25zdCBhZGFwdGVyS2V5ID0gYCR7bWV0YWRhdGEubmFtZX1AJHttZXRhZGF0YS52ZXJzaW9ufWA7XG4gICAgbW9kdWxlQWRhcHRlcnMuc2V0KGFkYXB0ZXJLZXksIG1ldGFkYXRhKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFuIGFkYXB0ZXIgYnkgbW9kdWxlIGFuZCBhZGFwdGVyIG5hbWVcbiAgICovXG4gIGdldEFkYXB0ZXIobW9kdWxlTmFtZSwgbmFtZSwgdmVyc2lvbikge1xuICAgIGNvbnN0IG1vZHVsZUFkYXB0ZXJzID0gdGhpcy5hZGFwdGVycy5nZXQobW9kdWxlTmFtZSk7XG4gICAgaWYgKCFtb2R1bGVBZGFwdGVycylcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgYWRhcHRlcktleSA9IGAke25hbWV9QCR7dmVyc2lvbn1gO1xuICAgIHJldHVybiBtb2R1bGVBZGFwdGVycy5nZXQoYWRhcHRlcktleSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgYW4gYWRhcHRlciBieSBuYW1lXG4gICAqL1xuICBnZXRMYXRlc3RBZGFwdGVyKG1vZHVsZU5hbWUsIG5hbWUpIHtcbiAgICBjb25zdCBtb2R1bGVBZGFwdGVycyA9IHRoaXMuYWRhcHRlcnMuZ2V0KG1vZHVsZU5hbWUpO1xuICAgIGlmICghbW9kdWxlQWRhcHRlcnMpXG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IG1hdGNoaW5nQWRhcHRlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFssIG1ldGFkYXRhXSBvZiBtb2R1bGVBZGFwdGVycy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChtZXRhZGF0YS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIG1hdGNoaW5nQWRhcHRlcnMucHVzaChtZXRhZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGluZ0FkYXB0ZXJzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgbWF0Y2hpbmdBZGFwdGVycy5zb3J0KChhLCBiKSA9PiBiLnZlcnNpb24ubG9jYWxlQ29tcGFyZShhLnZlcnNpb24pKTtcbiAgICByZXR1cm4gbWF0Y2hpbmdBZGFwdGVyc1swXTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBhZGFwdGVycyBmb3IgYSBtb2R1bGVcbiAgICovXG4gIGdldE1vZHVsZUFkYXB0ZXJzKG1vZHVsZU5hbWUpIHtcbiAgICBjb25zdCBtb2R1bGVBZGFwdGVycyA9IHRoaXMuYWRhcHRlcnMuZ2V0KG1vZHVsZU5hbWUpO1xuICAgIGlmICghbW9kdWxlQWRhcHRlcnMpXG4gICAgICByZXR1cm4gW107XG4gICAgcmV0dXJuIEFycmF5LmZyb20obW9kdWxlQWRhcHRlcnMudmFsdWVzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIGF2YWlsYWJsZSB2ZXJzaW9ucyBvZiBhIHNwZWNpZmljIGFkYXB0ZXJcbiAgICovXG4gIGdldEFkYXB0ZXJWZXJzaW9ucyhtb2R1bGVOYW1lLCBuYW1lKSB7XG4gICAgY29uc3QgbW9kdWxlQWRhcHRlcnMgPSB0aGlzLmFkYXB0ZXJzLmdldChtb2R1bGVOYW1lKTtcbiAgICBpZiAoIW1vZHVsZUFkYXB0ZXJzKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHZlcnNpb25zID0gW107XG4gICAgZm9yIChjb25zdCBbLCBtZXRhZGF0YV0gb2YgbW9kdWxlQWRhcHRlcnMuZW50cmllcygpKSB7XG4gICAgICBpZiAobWV0YWRhdGEubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICB2ZXJzaW9ucy5wdXNoKG1ldGFkYXRhLnZlcnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gYi5sb2NhbGVDb21wYXJlKGEpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBtb2R1bGVzXG4gICAqL1xuICBnZXRBbGxNb2R1bGVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubW9kdWxlcy52YWx1ZXMoKSk7XG4gIH1cbiAgLyoqXG4gICAgICogR2V0IGVudmlyb25tZW50IHJlcXVpcmVtZW50cyBmb3IgYW4gYWRhcHRlclxuICAgICAqL1xuICBnZXRFbnZpcm9ubWVudFJlcXVpcmVtZW50cyhtb2R1bGVOYW1lLCBuYW1lLCB2ZXJzaW9uKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuZ2V0QWRhcHRlcihtb2R1bGVOYW1lLCBuYW1lLCB2ZXJzaW9uKTtcbiAgICByZXR1cm4gYWRhcHRlcj8uZW52aXJvbm1lbnQ7XG4gIH1cbiAgLyoqXG4gICogQ2hlY2sgaWYgYW4gYWRhcHRlciBzdXBwb3J0cyBhIHNwZWNpZmljIGVudmlyb25tZW50XG4gICovXG4gIHN1cHBvcnRzRW52aXJvbm1lbnQobW9kdWxlTmFtZSwgbmFtZSwgdmVyc2lvbiwgZW52aXJvbm1lbnQpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5nZXRBZGFwdGVyKG1vZHVsZU5hbWUsIG5hbWUsIHZlcnNpb24pO1xuICAgIGlmICghYWRhcHRlciB8fCAhYWRhcHRlci5lbnZpcm9ubWVudClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBhZGFwdGVyLmVudmlyb25tZW50LnN1cHBvcnRlZEVudmlyb25tZW50cy5pbmNsdWRlcyhlbnZpcm9ubWVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhZGFwdGVycyB0aGF0IHN1cHBvcnQgYSBzcGVjaWZpYyBlbnZpcm9ubWVudFxuICAgKi9cbiAgZ2V0QWRhcHRlcnNCeUVudmlyb25tZW50KG1vZHVsZU5hbWUsIGVudmlyb25tZW50KSB7XG4gICAgY29uc3QgbW9kdWxlQWRhcHRlcnMgPSB0aGlzLmFkYXB0ZXJzLmdldChtb2R1bGVOYW1lKTtcbiAgICBpZiAoIW1vZHVsZUFkYXB0ZXJzKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgWywgbWV0YWRhdGFdIG9mIG1vZHVsZUFkYXB0ZXJzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKCFtZXRhZGF0YS5lbnZpcm9ubWVudCB8fCBtZXRhZGF0YS5lbnZpcm9ubWVudC5zdXBwb3J0ZWRFbnZpcm9ubWVudHMuaW5jbHVkZXMoZW52aXJvbm1lbnQpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGFkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciByZWdpc3RyeSA9IG5ldyBVbml2ZXJzYWxSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9zaGFyZWQvZGlzdC9oZWxwZXJzL25ldHdvcmsuanNcbmltcG9ydCB7IEJyb3dzZXJQcm92aWRlciwgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcImV0aGVyc1wiO1xudmFyIHN0YXRpY0NoYWluTGlzdCA9IFtcbiAge1xuICAgIG5hbWU6IFwiRXRoZXJldW0gTWFpbm5ldFwiLFxuICAgIGNoYWluSWQ6IDEsXG4gICAgc2hvcnROYW1lOiBcImV0aFwiLFxuICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6IFwiRXRoZXJcIiwgc3ltYm9sOiBcIkVUSFwiLCBkZWNpbWFsczogMTggfSxcbiAgICBycGM6IFtcbiAgICAgIFwiaHR0cHM6Ly9ldGgubGxhbWFycGMuY29tXCIsXG4gICAgICBcImh0dHBzOi8vZXRoZXJldW0tcnBjLnB1YmxpY25vZGUuY29tXCIsXG4gICAgICBcImh0dHBzOi8vMXJwYy5pby9ldGhcIixcbiAgICAgIFwiaHR0cHM6Ly9jbG91ZGZsYXJlLWV0aC5jb21cIlxuICAgIF0sXG4gICAgYmxvY2tFeHBsb3JlclVybDogXCJodHRwczovL2V0aGVyc2Nhbi5pb1wiLFxuICAgIGlzVGVzdG5ldDogZmFsc2UsXG4gICAgaXNTdGF0aWM6IHRydWVcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiUG9seWdvbiBNYWlubmV0XCIsXG4gICAgY2hhaW5JZDogMTM3LFxuICAgIHNob3J0TmFtZTogXCJtYXRpY1wiLFxuICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6IFwiTUFUSUNcIiwgc3ltYm9sOiBcIk1BVElDXCIsIGRlY2ltYWxzOiAxOCB9LFxuICAgIHJwYzogW1xuICAgICAgXCJodHRwczovL3BvbHlnb24tcnBjLmNvbVwiLFxuICAgICAgXCJodHRwczovL3BvbHlnb24ubGxhbWFycGMuY29tXCIsXG4gICAgICBcImh0dHBzOi8vcG9seWdvbi5kcnBjLm9yZ1wiXG4gICAgXSxcbiAgICBibG9ja0V4cGxvcmVyVXJsOiBcImh0dHBzOi8vcG9seWdvbnNjYW4uY29tXCIsXG4gICAgaXNUZXN0bmV0OiBmYWxzZSxcbiAgICBpc1N0YXRpYzogdHJ1ZVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJPcHRpbWlzbVwiLFxuICAgIGNoYWluSWQ6IDEwLFxuICAgIHNob3J0TmFtZTogXCJvZXRoXCIsXG4gICAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogXCJFdGhlclwiLCBzeW1ib2w6IFwiRVRIXCIsIGRlY2ltYWxzOiAxOCB9LFxuICAgIHJwYzogW1xuICAgICAgXCJodHRwczovL21haW5uZXQub3B0aW1pc20uaW9cIixcbiAgICAgIFwiaHR0cHM6Ly9vcHRpbWlzbS5sbGFtYXJwYy5jb21cIixcbiAgICAgIFwiaHR0cHM6Ly9vcHRpbWlzbS5wdWJsaWNub2RlLmNvbVwiXG4gICAgXSxcbiAgICBibG9ja0V4cGxvcmVyVXJsOiBcImh0dHBzOi8vb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIixcbiAgICBpc1Rlc3RuZXQ6IGZhbHNlLFxuICAgIGlzU3RhdGljOiB0cnVlXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkFyYml0cnVtIE9uZVwiLFxuICAgIGNoYWluSWQ6IDQyMTYxLFxuICAgIHNob3J0TmFtZTogXCJhcmIxXCIsXG4gICAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogXCJFdGhlclwiLCBzeW1ib2w6IFwiRVRIXCIsIGRlY2ltYWxzOiAxOCB9LFxuICAgIHJwYzogW1xuICAgICAgXCJodHRwczovL2FyYjEuYXJiaXRydW0uaW8vcnBjXCIsXG4gICAgICBcImh0dHBzOi8vYXJiaXRydW0ubGxhbWFycGMuY29tXCIsXG4gICAgICBcImh0dHBzOi8vYXJiaXRydW0tb25lLnB1YmxpYy5ibGFzdGFwaS5pb1wiXG4gICAgXSxcbiAgICBibG9ja0V4cGxvcmVyVXJsOiBcImh0dHBzOi8vYXJiaXNjYW4uaW9cIixcbiAgICBpc1Rlc3RuZXQ6IGZhbHNlLFxuICAgIGlzU3RhdGljOiB0cnVlXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkhvbGVza3lcIixcbiAgICBjaGFpbklkOiAxN2UzLFxuICAgIHNob3J0TmFtZTogXCJob2xlc2t5XCIsXG4gICAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogXCJIb2xlc2t5IEV0aGVyXCIsIHN5bWJvbDogXCJFVEhcIiwgZGVjaW1hbHM6IDE4IH0sXG4gICAgcnBjOiBbXCJodHRwczovL2V0aGVyZXVtLWhvbGVza3kucHVibGljbm9kZS5jb21cIl0sXG4gICAgYmxvY2tFeHBsb3JlclVybDogXCJodHRwczovL2hvbGVza3kuZXRoZXJzY2FuLmlvXCIsXG4gICAgaXNUZXN0bmV0OiB0cnVlLFxuICAgIGlzU3RhdGljOiB0cnVlXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNlcG9saWFcIixcbiAgICBjaGFpbklkOiAxMTE1NTExMSxcbiAgICBzaG9ydE5hbWU6IFwic2VwXCIsXG4gICAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogXCJTZXBvbGlhIEV0aGVyXCIsIHN5bWJvbDogXCJFVEhcIiwgZGVjaW1hbHM6IDE4IH0sXG4gICAgcnBjOiBbXG4gICAgICBcImh0dHBzOi8vcnBjLnNlcG9saWEub3JnXCIsXG4gICAgICBcImh0dHBzOi8vZXRoZXJldW0tc2Vwb2xpYS1ycGMucHVibGljbm9kZS5jb21cIixcbiAgICAgIFwiaHR0cHM6Ly9lbmRwb2ludHMub21uaWF0ZWNoLmlvL3YxL2V0aC9zZXBvbGlhL3B1YmxpY1wiLFxuICAgICAgXCJodHRwczovL2V0aC1zZXBvbGlhLnB1YmxpYy5ibGFzdGFwaS5pb1wiXG4gICAgXSxcbiAgICBibG9ja0V4cGxvcmVyVXJsOiBcImh0dHBzOi8vc2Vwb2xpYS5ldGhlcnNjYW4uaW9cIixcbiAgICBpc1Rlc3RuZXQ6IHRydWUsXG4gICAgaXNTdGF0aWM6IHRydWVcbiAgfVxuXTtcbnZhciBfTmV0d29ya0hlbHBlciA9IGNsYXNzIF9OZXR3b3JrSGVscGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5ldHdvcmtDYWNoZVwiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluaXRpYWxpemF0aW9uUHJvbWlzZVwiLCBudWxsKTtcbiAgICBmb3IgKGNvbnN0IGNoYWluIG9mIHN0YXRpY0NoYWluTGlzdCkge1xuICAgICAgdGhpcy5hZGRDaGFpblRvQ2FjaGUoY2hhaW4pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgaWYgKCFfTmV0d29ya0hlbHBlci5pbnN0YW5jZSkge1xuICAgICAgX05ldHdvcmtIZWxwZXIuaW5zdGFuY2UgPSBuZXcgX05ldHdvcmtIZWxwZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9OZXR3b3JrSGVscGVyLmluc3RhbmNlO1xuICB9XG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgbG9hZGluZyBvZiBuZXR3b3JrcyBoYXMgYXR0ZW1wdGVkIHRvIGNvbXBsZXRlLlxuICAgKi9cbiAgYXN5bmMgZW5zdXJlSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZSkge1xuICAgICAgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2UgPSB0aGlzLmZldGNoQW5kTWVyZ2VFeHRlcm5hbENoYWluTGlzdCgpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgfVxuICBhc3luYyBmZXRjaEFuZE1lcmdlRXh0ZXJuYWxDaGFpbkxpc3QoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwczovL2NoYWluaWQubmV0d29yay9jaGFpbnMuanNvblwiKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggY2hhaW4gbGlzdDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZXh0ZXJuYWxDaGFpbnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBmb3IgKGNvbnN0IGNoYWluIG9mIGV4dGVybmFsQ2hhaW5zKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZCA9IF9OZXR3b3JrSGVscGVyLm5vcm1hbGl6ZUNoYWluSWQoY2hhaW4uY2hhaW5JZCk7XG4gICAgICAgIGlmICghdGhpcy5uZXR3b3JrQ2FjaGVbbm9ybWFsaXplZElkXSB8fCAhdGhpcy5uZXR3b3JrQ2FjaGVbbm9ybWFsaXplZElkXS5pc1N0YXRpYykge1xuICAgICAgICAgIHRoaXMuYWRkQ2hhaW5Ub0NhY2hlKGNoYWluLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiW05ldHdvcmtIZWxwZXJdIENvdWxkIG5vdCBmZXRjaCBleHRlcm5hbCBjaGFpbiBsaXN0LiBVc2luZyBlbWJlZGRlZCBzdGF0aWMgbGlzdCBvbmx5LlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGFkZENoYWluVG9DYWNoZShjaGFpbiwgaXNTdGF0aWMgPSB0cnVlKSB7XG4gICAgaWYgKCFjaGFpbiB8fCAhY2hhaW4uY2hhaW5JZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBub3JtYWxpemVkSWQgPSBfTmV0d29ya0hlbHBlci5ub3JtYWxpemVDaGFpbklkKGNoYWluLmNoYWluSWQpO1xuICAgIGNvbnN0IHJwY1VybHMgPSAoY2hhaW4ucnBjIHx8IFtdKS5maWx0ZXIoKHVybCkgPT4gdXJsICYmIHVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiAhdXJsLmluY2x1ZGVzKFwiJHtcIikpO1xuICAgIGlmIChycGNVcmxzLmxlbmd0aCA9PT0gMCAmJiAhaXNTdGF0aWMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgbmFtZTogY2hhaW4ubmFtZSxcbiAgICAgIGNoYWluSWQ6IG5vcm1hbGl6ZWRJZCxcbiAgICAgIHNob3J0TmFtZTogY2hhaW4uc2hvcnROYW1lLFxuICAgICAgbmF0aXZlQ3VycmVuY3k6IGNoYWluLm5hdGl2ZUN1cnJlbmN5LFxuICAgICAgcnBjVXJscyxcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6IGNoYWluLmV4cGxvcmVycz8uWzBdPy51cmwgfHwgY2hhaW4uYmxvY2tFeHBsb3JlclVybCxcbiAgICAgIC8vIGlzVGVzdG5ldDogY2hhaW4uaXNUZXN0bmV0ID8/IChjaGFpbi5uZXR3b3JrSWQgIT09IDEpLCAvLyBTaW1wbGUgaGV1cmlzdGljXG4gICAgICBpc1N0YXRpYyxcbiAgICAgIGRpc3BsYXlOYW1lOiBjaGFpbi5uYW1lLFxuICAgICAgZGVjaW1hbHM6IGNoYWluLm5hdGl2ZUN1cnJlbmN5Py5kZWNpbWFscyB8fCAxOCxcbiAgICAgIHRpY2tlcjogY2hhaW4ubmF0aXZlQ3VycmVuY3k/LnN5bWJvbCxcbiAgICAgIHRpY2tlck5hbWU6IGNoYWluLm5hdGl2ZUN1cnJlbmN5Py5uYW1lXG4gICAgfTtcbiAgICB0aGlzLm5ldHdvcmtDYWNoZVtub3JtYWxpemVkSWRdID0gY29uZmlnO1xuICAgIHRoaXMubmV0d29ya0NhY2hlW2NoYWluLmNoYWluSWQudG9TdHJpbmcoKV0gPSBjb25maWc7XG4gICAgaWYgKGNoYWluLnNob3J0TmFtZSkge1xuICAgICAgdGhpcy5uZXR3b3JrQ2FjaGVbY2hhaW4uc2hvcnROYW1lLnRvTG93ZXJDYXNlKCldID0gY29uZmlnO1xuICAgIH1cbiAgICBpZiAoY2hhaW4ubmFtZSkge1xuICAgICAgdGhpcy5uZXR3b3JrQ2FjaGVbY2hhaW4ubmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgXCJcIildID0gY29uZmlnO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXROZXR3b3JrQ29uZmlnKG5ldHdvcmtJZGVudGlmaWVyLCBwcmVmZXJyZWRScGNVcmxzID0gW10sIHVzZU9ubHlQcmVmZXJyZWRScGMgPSBmYWxzZSkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBpZGVudGlmaWVyU3RyID0gU3RyaW5nKG5ldHdvcmtJZGVudGlmaWVyKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgXCJcIik7XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHRoaXMubmV0d29ya0NhY2hlW2lkZW50aWZpZXJTdHJdO1xuICAgIGlmICghYmFzZUNvbmZpZyB8fCAhYmFzZUNvbmZpZy5jaGFpbklkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdW5pcXVlUHJlZmVycmVkID0gWy4uLm5ldyBTZXQocHJlZmVycmVkUnBjVXJscy5maWx0ZXIoKHVybCkgPT4gdXJsKSldO1xuICAgIGNvbnN0IGJhc2VScGNVcmxzID0gQXJyYXkuaXNBcnJheShiYXNlQ29uZmlnLnJwY1VybHMpID8gYmFzZUNvbmZpZy5ycGNVcmxzIDogW107XG4gICAgbGV0IHVybHNUb1Rlc3QgPSBbXTtcbiAgICBpZiAodXNlT25seVByZWZlcnJlZFJwYykge1xuICAgICAgaWYgKHVuaXF1ZVByZWZlcnJlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbTmV0d29ya0hlbHBlcl0gZ2V0TmV0d29ya0NvbmZpZyBjYWxsZWQgd2l0aCB1c2VPbmx5UHJlZmVycmVkUnBjPXRydWUgYnV0IG5vIHByZWZlcnJlZFJwY1VybHMgd2VyZSBwcm92aWRlZCBmb3IgJHtuZXR3b3JrSWRlbnRpZmllcn0uYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdXJsc1RvVGVzdCA9IHVuaXF1ZVByZWZlcnJlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsc1RvVGVzdCA9IFsuLi51bmlxdWVQcmVmZXJyZWQsIC4uLmJhc2VScGNVcmxzLmZpbHRlcigodXJsKSA9PiAhdW5pcXVlUHJlZmVycmVkLmluY2x1ZGVzKHVybCkpXTtcbiAgICB9XG4gICAgaWYgKHVybHNUb1Rlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgd29ya2luZ1VybCA9IGF3YWl0IHRoaXMuZmluZEZpcnN0V29ya2luZ1JwYyh1cmxzVG9UZXN0LCBiYXNlQ29uZmlnLmNoYWluSWQpO1xuICAgIGlmICghd29ya2luZ1VybCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghdXNlT25seVByZWZlcnJlZFJwYyAmJiB1bmlxdWVQcmVmZXJyZWQubGVuZ3RoID4gMCAmJiAhdW5pcXVlUHJlZmVycmVkLmluY2x1ZGVzKHdvcmtpbmdVcmwpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtOZXR3b3JrSGVscGVyXSBOb25lIG9mIHRoZSBwcmVmZXJyZWQgUlBDcyB3b3JrZWQgZm9yICR7YmFzZUNvbmZpZy5uYW1lfS4gVXNpbmcgYSBwdWJsaWMgUlBDOiAke3dvcmtpbmdVcmx9LiBGb3IgY3JpdGljYWwgb3BlcmF0aW9ucywgZW5zdXJlIHlvdXIgcHJlZmVycmVkIFJQQ3MgYXJlIG9wZXJhdGlvbmFsLmApO1xuICAgIH1cbiAgICBjb25zdCBvcmRlcmVkUnBjVXJscyA9IFt3b3JraW5nVXJsLCAuLi51cmxzVG9UZXN0LmZpbHRlcigodXJsKSA9PiB1cmwgIT09IHdvcmtpbmdVcmwpXTtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhaW5JZDogYmFzZUNvbmZpZy5jaGFpbklkLFxuICAgICAgbmFtZTogYmFzZUNvbmZpZy5uYW1lLFxuICAgICAgZGlzcGxheU5hbWU6IGJhc2VDb25maWcuZGlzcGxheU5hbWUgfHwgYmFzZUNvbmZpZy5uYW1lLFxuICAgICAgcnBjVXJsczogb3JkZXJlZFJwY1VybHMsXG4gICAgICBkZWNpbWFsczogYmFzZUNvbmZpZy5kZWNpbWFscyxcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6IGJhc2VDb25maWcuYmxvY2tFeHBsb3JlclVybCxcbiAgICAgIHRpY2tlcjogYmFzZUNvbmZpZy50aWNrZXIsXG4gICAgICB0aWNrZXJOYW1lOiBiYXNlQ29uZmlnLnRpY2tlck5hbWUsXG4gICAgICBzaG9ydE5hbWU6IGJhc2VDb25maWcuc2hvcnROYW1lXG4gICAgfTtcbiAgfVxuICBhc3luYyB0ZXN0UnBjQ29ubmVjdGlvbih1cmwsIGV4cGVjdGVkQ2hhaW5JZCwgdGltZW91dE1zID0gNWUzKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXRNcyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBqc29ucnBjOiBcIjIuMFwiLCBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiwgcGFyYW1zOiBbXSwgaWQ6IDEgfSksXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVjZWl2ZWRDaGFpbklkID0gX05ldHdvcmtIZWxwZXIubm9ybWFsaXplQ2hhaW5JZChkYXRhLnJlc3VsdCk7XG4gICAgICBjb25zdCBleHBlY3RlZE5vcm1hbGl6ZWQgPSBfTmV0d29ya0hlbHBlci5ub3JtYWxpemVDaGFpbklkKGV4cGVjdGVkQ2hhaW5JZCk7XG4gICAgICBpZiAocmVjZWl2ZWRDaGFpbklkICE9PSBleHBlY3RlZE5vcm1hbGl6ZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbdGVzdFJwY0Nvbm5lY3Rpb25dIENoYWluIElEIG1pc21hdGNoIGZvciAke3VybH06IEdvdCAke3JlY2VpdmVkQ2hhaW5JZH0sIEV4cGVjdGVkICR7ZXhwZWN0ZWROb3JtYWxpemVkfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICB9IGVsc2Uge1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZpbmRGaXJzdFdvcmtpbmdScGModXJscywgZXhwZWN0ZWRDaGFpbklkLCB0aW1lb3V0TXMgPSAzZTMpIHtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgICBpZiAoYXdhaXQgdGhpcy50ZXN0UnBjQ29ubmVjdGlvbih1cmwsIGV4cGVjdGVkQ2hhaW5JZCwgdGltZW91dE1zKSkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhc3luYyBnZXRQcm92aWRlcihpbnB1dCwgcHJlZmVycmVkUnBjVXJscyA9IFtdLCBjaGFpbklkKSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgSnNvblJwY1Byb3ZpZGVyIHx8IGlucHV0IGluc3RhbmNlb2YgQnJvd3NlclByb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQucmVxdWVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gbmV3IEJyb3dzZXJQcm92aWRlcihpbnB1dCwgXCJhbnlcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBuZXcgSnNvblJwY1Byb3ZpZGVyKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiBBcnJheS5pc0FycmF5KGlucHV0LnJwY1VybHMpICYmIGlucHV0LnJwY1VybHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBKc29uUnBjUHJvdmlkZXIoaW5wdXQucnBjVXJsc1swXSk7XG4gICAgfVxuICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIk5vIGNoYWluSWQgYXZhaWxhYmxlIHRvIHBpY2sgYSBwdWJsaWMgUlBDLiBTdXBwbHkgeW91ciBvd24gaW4gb3B0aW9ucy5wcm92aWRlci5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LCBtZXRob2ROYW1lOiBcImdldFByb3ZpZGVyXCIgfSk7XG4gICAgfVxuICAgIGNvbnN0IG5ldCA9IGF3YWl0IHRoaXMuZ2V0TmV0d29ya0NvbmZpZyhjaGFpbklkLCBwcmVmZXJyZWRScGNVcmxzKTtcbiAgICBpZiAoIW5ldCB8fCAhbmV0LnJwY1VybHMgfHwgbmV0LnJwY1VybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBObyBSUEMgY291bGQgYmUgcmVhY2hlZCBmb3IgY2hhaW5JZD0ke2NoYWluSWR9LiBQbGVhc2Ugc3VwcGx5IGF0IGxlYXN0IG9uZSB3b3JraW5nIFVSTCBpbiBvcHRpb25zLnByb3ZpZGVyLnJwY1VybHMuYCwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuQ29ubmVjdGlvbkZhaWxlZCwgbWV0aG9kTmFtZTogXCJnZXRQcm92aWRlclwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEpzb25ScGNQcm92aWRlcihuZXQucnBjVXJsc1swXSk7XG4gIH1cbiAgc3RhdGljIG5vcm1hbGl6ZUNoYWluSWQoY2hhaW5JZCkge1xuICAgIGlmICh0eXBlb2YgY2hhaW5JZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGAweCR7Y2hhaW5JZC50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKX1gO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoYWluSWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChjaGFpbklkLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgIHJldHVybiBjaGFpbklkLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBudW0gPSBwYXJzZUludChjaGFpbklkLCAxMCk7XG4gICAgICBpZiAoIWlzTmFOKG51bSkpIHtcbiAgICAgICAgcmV0dXJuIGAweCR7bnVtLnRvU3RyaW5nKDE2KS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYEludmFsaWQgY2hhaW5JZCBmb3JtYXQ6ICR7Y2hhaW5JZH1gLCB7IGNvZGU6IFdhbGxldEVycm9yQ29kZS5JbnZhbGlkSW5wdXQgfSk7XG4gIH1cbiAgc3RhdGljIGFzc2VydENvbmZpZ0lzVmFsaWQoY29uZmlnLCBjb250ZXh0ID0gXCJOZXR3b3JrQ29uZmlndXJhdGlvblwiKSB7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW05ldHdvcmtIZWxwZXJdICR7Y29udGV4dH06IENvbmZpZ3VyYXRpb24gaXMgbnVsbCBvciB1bmRlZmluZWQuYCk7XG4gICAgfVxuICAgIGlmICghY29uZmlnLmNoYWluSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW05ldHdvcmtIZWxwZXJdICR7Y29udGV4dH0gKE5hbWU6ICR7Y29uZmlnLm5hbWUgfHwgXCJOL0FcIn0pOiBNaXNzaW5nIGNoYWluSWQuYCk7XG4gICAgfVxuICAgIGlmICghY29uZmlnLnJwY1VybHMgfHwgY29uZmlnLnJwY1VybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFtOZXR3b3JrSGVscGVyXSAke2NvbnRleHR9IChOYW1lOiAke2NvbmZpZy5uYW1lIHx8IFwiTi9BXCJ9LCBDaGFpbklEOiAke2NvbmZpZy5jaGFpbklkfSk6IE1pc3Npbmcgb3IgZW1wdHkgcnBjVXJscy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBzdGF0aWMgZmlsdGVyVmFsaWRDb25maWdzKGNvbmZpZ3MpIHtcbiAgICBjb25zdCBpc1ZhbGlkID0gKGNvbmZpZykgPT4gISFjb25maWcgJiYgISFjb25maWcuY2hhaW5JZCAmJiBBcnJheS5pc0FycmF5KGNvbmZpZy5ycGNVcmxzKSAmJiBjb25maWcucnBjVXJscy5sZW5ndGggPiAwO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZ3MpKSB7XG4gICAgICByZXR1cm4gY29uZmlncy5maWx0ZXIoaXNWYWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29uZmlncykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZ3MsIGtleSkpIHtcbiAgICAgICAgICBjb25zdCBjb25maWcgPSBjb25maWdzW2tleV07XG4gICAgICAgICAgaWYgKGlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjb25maWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICB2YWxpZGF0ZVByaXZhdGVScGNzRm9yQ2hhaW5zKGNoYWluSWRzLCB3YWxsZXRScGNzKSB7XG4gICAgY29uc3QgbWlzc2luZ0NoYWlucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2hhaW5JZCBvZiBjaGFpbklkcykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZElkID0gX05ldHdvcmtIZWxwZXIubm9ybWFsaXplQ2hhaW5JZChjaGFpbklkKTtcbiAgICAgIGNvbnN0IGRlY2ltYWxJZCA9IHBhcnNlSW50KG5vcm1hbGl6ZWRJZCwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBoYXNScGNzID0gd2FsbGV0UnBjc1tub3JtYWxpemVkSWRdPy5sZW5ndGggPiAwIHx8IHdhbGxldFJwY3NbZGVjaW1hbElkXT8ubGVuZ3RoID4gMDtcbiAgICAgIGlmICghaGFzUnBjcykge1xuICAgICAgICBtaXNzaW5nQ2hhaW5zLnB1c2goZGVjaW1hbElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0FsbFByaXZhdGVScGNzOiBtaXNzaW5nQ2hhaW5zLmxlbmd0aCA9PT0gMCxcbiAgICAgIG1pc3NpbmdDaGFpbnNcbiAgICB9O1xuICB9XG59O1xuX19wdWJsaWNGaWVsZChfTmV0d29ya0hlbHBlciwgXCJpbnN0YW5jZVwiKTtcbnZhciBOZXR3b3JrSGVscGVyID0gX05ldHdvcmtIZWxwZXI7XG5cbi8vIHBhY2thZ2VzL3NoYXJlZC9kaXN0L2hlbHBlcnMva2V5cy5qc1xuaW1wb3J0IHsgV2FsbGV0IGFzIEV0aGVyc1dhbGxldCwgSEROb2RlV2FsbGV0LCBNbmVtb25pYywgV2FsbGV0LCBpc0hleFN0cmluZyB9IGZyb20gXCJldGhlcnNcIjtcbnZhciBQcml2YXRlS2V5SGVscGVyID0gY2xhc3Mge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgbmV3IHJhbmRvbSBFVk0tY29tcGF0aWJsZSBwcml2YXRlIGtleS5cbiAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwcml2YXRlIGtleSAoaGV4YWRlY2ltYWwsIDB4LXByZWZpeGVkKS5cbiAgICovXG4gIGdlbmVyYXRlUHJpdmF0ZUtleSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgd2FsbGV0ID0gRXRoZXJzV2FsbGV0LmNyZWF0ZVJhbmRvbSgpO1xuICAgICAgcmV0dXJuIHdhbGxldC5wcml2YXRlS2V5O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFtQcml2YXRlS2V5SGVscGVyLmdlbmVyYXRlUHJpdmF0ZUtleV0gRmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbmNyeXB0cyBhbiBFVk0gcHJpdmF0ZSBrZXkgaW50byBhIEpTT04ga2V5c3RvcmUgKEVJUC0yMzM1IGZvcm1hdCkgdXNpbmcgYSBwYXNzd29yZC5cbiAgICogQHBhcmFtIHByaXZhdGVLZXkgVGhlIEVWTSBwcml2YXRlIGtleSBzdHJpbmcgKGhleGFkZWNpbWFsLCAweC1wcmVmaXhlZCkuXG4gICAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgZm9yIGVuY3J5cHRpb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIEpTT04ga2V5c3RvcmUgc3RyaW5nLlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBwcml2YXRlIGtleSBpcyBpbnZhbGlkIG9yIGVuY3J5cHRpb24gZmFpbHMuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0UHJpdmF0ZUtleShwcml2YXRlS2V5LCBwYXNzd29yZCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkRXZtUHJpdmF0ZUtleShwcml2YXRlS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1ByaXZhdGVLZXlIZWxwZXIuZW5jcnlwdFByaXZhdGVLZXldIEludmFsaWQgcHJpdmF0ZSBrZXkgZm9ybWF0LlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHdhbGxldCA9IG5ldyBFdGhlcnNXYWxsZXQocHJpdmF0ZUtleSk7XG4gICAgICBjb25zdCBqc29uS2V5c3RvcmUgPSBhd2FpdCB3YWxsZXQuZW5jcnlwdChwYXNzd29yZCk7XG4gICAgICByZXR1cm4ganNvbktleXN0b3JlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFtQcml2YXRlS2V5SGVscGVyLmVuY3J5cHRQcml2YXRlS2V5XSBFbmNyeXB0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVjcnlwdHMgYW4gRVZNIEpTT04ga2V5c3RvcmUgdXNpbmcgYSBwYXNzd29yZC5cbiAgICogQHBhcmFtIGVuY3J5cHRlZEpzb25LZXlzdG9yZSBUaGUgSlNPTiBrZXlzdG9yZSBzdHJpbmcuXG4gICAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgZm9yIGRlY3J5cHRpb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGRlY3J5cHRlZCBFVk0gcHJpdmF0ZSBrZXkgc3RyaW5nLlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIGRlY3J5cHRpb24gZmFpbHMgKGUuZy4sIGludmFsaWQga2V5c3RvcmUsIGluY29ycmVjdCBwYXNzd29yZCkuXG4gICAqL1xuICBhc3luYyBkZWNyeXB0UHJpdmF0ZUtleShlbmNyeXB0ZWRKc29uS2V5c3RvcmUsIHBhc3N3b3JkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHdhbGxldCA9IGF3YWl0IEV0aGVyc1dhbGxldC5mcm9tRW5jcnlwdGVkSnNvbihlbmNyeXB0ZWRKc29uS2V5c3RvcmUsIHBhc3N3b3JkKTtcbiAgICAgIHJldHVybiB3YWxsZXQucHJpdmF0ZUtleTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbUHJpdmF0ZUtleUhlbHBlci5kZWNyeXB0UHJpdmF0ZUtleV0gRGVjcnlwdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlcml2ZXMgdGhlIHB1YmxpYyBFdGhlcmV1bSBhZGRyZXNzIGZyb20gYW4gRVZNIHByaXZhdGUga2V5LlxuICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBUaGUgRVZNIHByaXZhdGUga2V5IHN0cmluZyAoaGV4YWRlY2ltYWwsIDB4LXByZWZpeGVkKS5cbiAgICogQHJldHVybnMgVGhlIGNvcnJlc3BvbmRpbmcgcHVibGljIGFkZHJlc3Mgc3RyaW5nLlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBwcml2YXRlIGtleSBpcyBpbnZhbGlkLlxuICAgKi9cbiAgZ2V0QWRkcmVzc0Zyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEV2bVByaXZhdGVLZXkocHJpdmF0ZUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltQcml2YXRlS2V5SGVscGVyLmdldEFkZHJlc3NGcm9tUHJpdmF0ZUtleV0gSW52YWxpZCBwcml2YXRlIGtleSBmb3JtYXQuXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgd2FsbGV0ID0gbmV3IEV0aGVyc1dhbGxldChwcml2YXRlS2V5KTtcbiAgICAgIHJldHVybiB3YWxsZXQuYWRkcmVzcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbUHJpdmF0ZUtleUhlbHBlci5nZXRBZGRyZXNzRnJvbVByaXZhdGVLZXldIEZhaWxlZCB0byBkZXJpdmUgYWRkcmVzczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBHZW5lcmF0ZXMgYSBuZXcgcmFuZG9tIEJJUDM5IG1uZW1vbmljIHBocmFzZS5cbiAgKiBVc2VzIGV0aGVycy5XYWxsZXQuY3JlYXRlUmFuZG9tKCkgZm9yIHJvYnVzdCBnZW5lcmF0aW9uLlxuICAqIEByZXR1cm5zIEEgcmFuZG9tbHkgZ2VuZXJhdGVkIG1uZW1vbmljIHBocmFzZSAodHlwaWNhbGx5IDEyIHdvcmRzKS5cbiAgKiBAdGhyb3dzIEVycm9yIGlmIG1uZW1vbmljIGdlbmVyYXRpb24gZmFpbHMuXG4gICovXG4gIGdlbmVyYXRlTW5lbW9uaWMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhbmRvbVdhbGxldCA9IFdhbGxldC5jcmVhdGVSYW5kb20oKTtcbiAgICAgIGlmICghcmFuZG9tV2FsbGV0Lm1uZW1vbmljIHx8ICFyYW5kb21XYWxsZXQubW5lbW9uaWMucGhyYXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBtbmVtb25pYyBwaHJhc2UgZnJvbSByYW5kb20gd2FsbGV0LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5kb21XYWxsZXQubW5lbW9uaWMucGhyYXNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCB3cmFwcGVkRXJyb3IgPSBuZXcgRXJyb3IoYFtQcml2YXRlS2V5SGVscGVyLmdlbmVyYXRlTW5lbW9uaWNdIEZhaWxlZCBkdXJpbmcgbW5lbW9uaWMgZ2VuZXJhdGlvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgIHdyYXBwZWRFcnJvci5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgfVxuICAgICAgd3JhcHBlZEVycm9yLmNhdXNlID0gZXJyb3I7XG4gICAgICB0aHJvdyB3cmFwcGVkRXJyb3I7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXJpdmVzIGFuIEVWTSBwcml2YXRlIGtleSBmcm9tIGEgbW5lbW9uaWMgcGhyYXNlIGFuZCBhbiBvcHRpb25hbCBIRCBwYXRoLlxuICAgKiBAcGFyYW0gbW5lbW9uaWMgVGhlIEJJUC0zOSBtbmVtb25pYyBwaHJhc2UuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBIRCBwYXRoIChlLmcuLCBcIm0vNDQnLzYwJy8wJy8wLzBcIikuIERlZmF1bHRzIHRvIHRoZSBzdGFuZGFyZCBFdGhlcmV1bSBwYXRoLlxuICAgKiBAcmV0dXJucyBUaGUgZGVyaXZlZCBwcml2YXRlIGtleSBzdHJpbmcuXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIG1uZW1vbmljIGlzIGludmFsaWQgb3IgZGVyaXZhdGlvbiBmYWlscy5cbiAgICovXG4gIGdldFByaXZhdGVLZXlGcm9tTW5lbW9uaWMobW5lbW9uaWMsIHBhdGgpIHtcbiAgICBjb25zdCBoZFBhdGggPSBwYXRoIHx8IFwibS80NCcvNjAnLzAnLzAvMFwiO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIU1uZW1vbmljLmlzVmFsaWRNbmVtb25pYyhtbmVtb25pYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtbmVtb25pYyBwaHJhc2UgcHJvdmlkZWQuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW5lbW9uaWNJbnN0YW5jZSA9IE1uZW1vbmljLmZyb21QaHJhc2UobW5lbW9uaWMpO1xuICAgICAgY29uc3QgaGROb2RlID0gSEROb2RlV2FsbGV0LmZyb21NbmVtb25pYyhtbmVtb25pY0luc3RhbmNlLCBoZFBhdGgpO1xuICAgICAgcmV0dXJuIGhkTm9kZS5wcml2YXRlS2V5O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFtQcml2YXRlS2V5SGVscGVyLmdldFByaXZhdGVLZXlGcm9tTW5lbW9uaWNdIEZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBwbGF1c2libGUgRVZNIHByaXZhdGUga2V5IGZvcm1hdC5cbiAgICogKEJhc2ljIGNoZWNrIGZvciAweCBwcmVmaXggYW5kIDY0IGhleCBjaGFyYWN0ZXJzKS5cbiAgICogQHBhcmFtIHByaXZhdGVLZXkgVGhlIHN0cmluZyB0byB2YWxpZGF0ZS5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBpdCBtYXRjaGVzIHRoZSBiYXNpYyBmb3JtYXQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzVmFsaWRFdm1Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByaXZhdGVLZXkgPT09IFwic3RyaW5nXCIgJiYgaXNIZXhTdHJpbmcocHJpdmF0ZUtleSwgMzIpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9zaGFyZWQvZGlzdC9oZWxwZXJzL3ZhbGlkYXRvci5qc1xuZnVuY3Rpb24gdmFsaWRhdGVBZGFwdGVyUGFyYW1ldGVycyhhcmdzKSB7XG4gIGNvbnN0IHsgbmFtZSwgdmVyc2lvbiwgcGFyYW1zLCBhZGFwdGVySW5mbywgcmVnaXN0cnk6IHJlZ2lzdHJ5MiwgZmFjdG9yeU1ldGhvZE5hbWUgfSA9IGFyZ3M7XG4gIGNvbnN0IHsgZXhwZWN0ZWRJbnRlcmZhY2UgfSA9IHBhcmFtcztcbiAgY29uc29sZS5sb2coXCJWYWxpZGF0b3IgLSBhcmd1bWVudHMsIFwiLCBhcmdzKTtcbiAgaWYgKGV4cGVjdGVkSW50ZXJmYWNlKSB7XG4gICAgY29uc3QgcmVxdWlyZWRDYXBhYmlsaXRpZXMgPSByZWdpc3RyeTIuZ2V0SW50ZXJmYWNlU2hhcGUoZXhwZWN0ZWRJbnRlcmZhY2UpO1xuICAgIGlmICghcmVxdWlyZWRDYXBhYmlsaXRpZXMpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYFVua25vd24gaW50ZXJmYWNlIHNoYXBlIHJlcXVlc3RlZDogJyR7ZXhwZWN0ZWRJbnRlcmZhY2V9Jy4gRW5zdXJlIGl0IGlzIHJlZ2lzdGVyZWQgaW4gdGhlIHJlZ2lzdHJ5LmAsIHsgY29kZTogXCJJTlRFUk5BTF9FUlJPUlwiIH0pO1xuICAgIH1cbiAgICBjb25zdCBhZGFwdGVyQ2FwYWJpbGl0aWVzID0gYWRhcHRlckluZm8uY2FwYWJpbGl0aWVzIHx8IFtdO1xuICAgIGZvciAoY29uc3QgcmVxIG9mIHJlcXVpcmVkQ2FwYWJpbGl0aWVzKSB7XG4gICAgICBpZiAoIWFkYXB0ZXJDYXBhYmlsaXRpZXMuaW5jbHVkZXMocmVxKSkge1xuICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBBZGFwdGVyICcke25hbWV9QCR7dmVyc2lvbn0nIGRvZXMgbm90IGZ1bGx5IGltcGxlbWVudCB0aGUgJyR7ZXhwZWN0ZWRJbnRlcmZhY2V9JyBpbnRlcmZhY2UuIE1pc3NpbmcgY2FwYWJpbGl0eTogJyR7cmVxfScuYCwgeyBjb2RlOiBcIklOQ09NUEFUSUJMRV9BREFQVEVSXCIsIG1ldGhvZE5hbWU6IGZhY3RvcnlNZXRob2ROYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoYWRhcHRlckluZm8ucmVxdWlyZW1lbnRzICYmIGFkYXB0ZXJJbmZvLnJlcXVpcmVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgY29uc29sZS5sb2coXCJWYWxpZGF0b3IgLSBhZGFwdGVySW5mbywgXCIsIGFkYXB0ZXJJbmZvKTtcbiAgICBmb3IgKGNvbnN0IHJlcSBvZiBhZGFwdGVySW5mby5yZXF1aXJlbWVudHMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0UHJvcGVydHlCeVBhdGgocGFyYW1zLCByZXEucGF0aCk7XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCAmJiAhcmVxLmFsbG93VW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlcS5tZXNzYWdlIHx8IGBSZXF1aXJlZCBvcHRpb24gJyR7cmVxLnBhdGh9JyBpcyBtaXNzaW5nIGZvciBhZGFwdGVyICcke25hbWV9Jy5gO1xuICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGVycm9yTWVzc2FnZSwge1xuICAgICAgICAgIG1ldGhvZE5hbWU6IGZhY3RvcnlNZXRob2ROYW1lLFxuICAgICAgICAgIGNvZGU6IFwiTUlTU0lOR19BREFQVEVSX1JFUVVJUkVNRU5UXCIsXG4gICAgICAgICAgZGV0YWlsczogeyBwYXRoOiByZXEucGF0aCwgbWVzc2FnZTogcmVxLm1lc3NhZ2UgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXEudHlwZSAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gXCJhcnJheVwiIDogdHlwZW9mIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWVUeXBlICE9PSByZXEudHlwZSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlcS5tZXNzYWdlIHx8IGBSZXF1aXJlZCBvcHRpb24gJyR7cmVxLnBhdGh9JyBmb3IgYWRhcHRlciAnJHtuYW1lfScgbXVzdCBiZSBvZiB0eXBlICcke3JlcS50eXBlfScsIGJ1dCByZWNlaXZlZCAnJHt2YWx1ZVR5cGV9Jy5gO1xuICAgICAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoZXJyb3JNZXNzYWdlLCB7XG4gICAgICAgICAgICBtZXRob2ROYW1lOiBmYWN0b3J5TWV0aG9kTmFtZSxcbiAgICAgICAgICAgIGNvZGU6IFwiSU5WQUxJRF9BREFQVEVSX1JFUVVJUkVNRU5UX1RZUEVcIixcbiAgICAgICAgICAgIGRldGFpbHM6IHsgcGF0aDogcmVxLnBhdGgsIG1lc3NhZ2U6IHJlcS5tZXNzYWdlLCBleHBlY3RlZFR5cGU6IHJlcS50eXBlLCBhY3R1YWxUeXBlOiB2YWx1ZVR5cGUgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHBhY2thZ2VzL3NoYXJlZC9kaXN0L2hlbHBlcnMvZGV2dG9vbC5qc1xuZnVuY3Rpb24gYW5hbHl6ZUpvaVNjaGVtYShzY2hlbWEsIGJhc2VQYXRoKSB7XG4gIGNvbnNvbGUubG9nKGBcXHV7MUY1MkN9IFthbmFseXplSm9pU2NoZW1hXSBBbmFseXppbmcgc2NoZW1hIGF0IHBhdGg6ICR7YmFzZVBhdGh9YCk7XG4gIGNvbnN0IHJlcXVpcmVtZW50cyA9IFtdO1xuICB0cnkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc2NoZW1hLmRlc2NyaWJlKCk7XG4gICAgY29uc29sZS5sb2coYFxcdXsxRjRDQn0gW2FuYWx5emVKb2lTY2hlbWFdIFNjaGVtYSBkZXNjcmlwdGlvbiB0eXBlOmAsIGRlc2NyaXB0aW9uLnR5cGUpO1xuICAgIGNvbnNvbGUubG9nKGBcXHV7MUY0Q0J9IFthbmFseXplSm9pU2NoZW1hXSBTY2hlbWEga2V5czpgLCBkZXNjcmlwdGlvbi5rZXlzID8gT2JqZWN0LmtleXMoZGVzY3JpcHRpb24ua2V5cykgOiBcIk5PIEtFWVNcIik7XG4gICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgZGVzY3JpcHRpb24ua2V5cykge1xuICAgICAgY29uc29sZS5sb2coYFxcdTI3MDUgW2FuYWx5emVKb2lTY2hlbWFdIFByb2Nlc3Npbmcgb2JqZWN0IHNjaGVtYSB3aXRoICR7T2JqZWN0LmtleXMoZGVzY3JpcHRpb24ua2V5cykubGVuZ3RofSBrZXlzYCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIGZpZWxkRGVzY10gb2YgT2JqZWN0LmVudHJpZXMoZGVzY3JpcHRpb24ua2V5cykpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFxcdXsxRjUxMX0gW2FuYWx5emVKb2lTY2hlbWFdIFByb2Nlc3NpbmcgZmllbGQ6ICR7a2V5fWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgXFx1ezFGNEREfSBbYW5hbHl6ZUpvaVNjaGVtYV0gRmllbGQgZGVzY3JpcHRpb246YCwgZmllbGREZXNjKTtcbiAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBmaWVsZERlc2M7XG4gICAgICAgIGNvbnN0IGZpZWxkUGF0aCA9IGAke2Jhc2VQYXRofS4ke2tleX1gO1xuICAgICAgICBjb25zdCBoYXNQcmVzZW5jZUZsYWcgPSBmaWVsZFNjaGVtYS5mbGFncz8ucHJlc2VuY2U7XG4gICAgICAgIGNvbnN0IGlzUmVxdWlyZWQgPSBoYXNQcmVzZW5jZUZsYWcgPT09IFwicmVxdWlyZWRcIiB8fCAhaGFzUHJlc2VuY2VGbGFnICYmICFmaWVsZFNjaGVtYS5mbGFncz8ub3B0aW9uYWw7XG4gICAgICAgIGxldCBmaWVsZFR5cGUgPSBmaWVsZFNjaGVtYS50eXBlIHx8IFwiYW55XCI7XG4gICAgICAgIGlmIChmaWVsZFR5cGUgPT09IFwiYWx0ZXJuYXRpdmVzXCIgJiYgZmllbGRTY2hlbWEubWF0Y2hlcykge1xuICAgICAgICAgIGZpZWxkVHlwZSA9IGZpZWxkU2NoZW1hLm1hdGNoZXNbMF0/LnNjaGVtYT8udHlwZSB8fCBcImFueVwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gZmllbGRTY2hlbWEuZmxhZ3M/LmRlc2NyaXB0aW9uIHx8IFwiXCI7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgIGNvbnN0IG1hbmRhdG9yeSA9IGlzUmVxdWlyZWQgPyBcInJlcXVpcmVkXCIgOiBcIm9wdGlvbmFsXCI7XG4gICAgICAgICAgbWVzc2FnZSA9IGAke2tleX0gaXMgJHttYW5kYXRvcnl9IGFuZCBtdXN0IGJlIG9mIHR5cGU6ICR7ZmllbGRUeXBlfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYFxcdXsxRjRDQX0gW2FuYWx5emVKb2lTY2hlbWFdIEZpZWxkICR7a2V5fTogdHlwZT0ke2ZpZWxkVHlwZX0sIHJlcXVpcmVkPSR7aXNSZXF1aXJlZH0sIG1lc3NhZ2U9XCIke21lc3NhZ2V9XCJgKTtcbiAgICAgICAgcmVxdWlyZW1lbnRzLnB1c2goe1xuICAgICAgICAgIHBhdGg6IGZpZWxkUGF0aCxcbiAgICAgICAgICB0eXBlOiBmaWVsZFR5cGUsXG4gICAgICAgICAgYWxsb3dVbmRlZmluZWQ6ICFpc1JlcXVpcmVkLFxuICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWVsZFNjaGVtYS50eXBlID09PSBcIm9iamVjdFwiICYmIGZpZWxkU2NoZW1hLmtleXMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgXFx1ezFGNTA0fSBbYW5hbHl6ZUpvaVNjaGVtYV0gUmVjdXJzaW5nIGludG8gbmVzdGVkIG9iamVjdDogJHtrZXl9YCk7XG4gICAgICAgICAgY29uc3QgbmVzdGVkUmVxdWlyZW1lbnRzID0gYW5hbHl6ZUpvaVNjaGVtYUZyb21EZXNjcmlwdGlvbihmaWVsZFNjaGVtYSwgZmllbGRQYXRoKTtcbiAgICAgICAgICByZXF1aXJlbWVudHMucHVzaCguLi5uZXN0ZWRSZXF1aXJlbWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihgXFx1MjZBMFxcdUZFMEYgW2FuYWx5emVKb2lTY2hlbWFdIEV4cGVjdGVkIG9iamVjdCBzY2hlbWEgYnV0IGdvdCB0eXBlOiAke2Rlc2NyaXB0aW9uLnR5cGV9YCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFxcdTI3NEMgW2FuYWx5emVKb2lTY2hlbWFdIEZhaWxlZCB0byBhbmFseXplIHNjaGVtYSBhdCAke2Jhc2VQYXRofTpgLCBlcnJvcik7XG4gIH1cbiAgY29uc29sZS5sb2coYFxcdXsxRjRDQX0gW2FuYWx5emVKb2lTY2hlbWFdIEdlbmVyYXRlZCAke3JlcXVpcmVtZW50cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmb3IgJHtiYXNlUGF0aH1gKTtcbiAgcmV0dXJuIHJlcXVpcmVtZW50cztcbn1cbmZ1bmN0aW9uIGFuYWx5emVKb2lTY2hlbWFGcm9tRGVzY3JpcHRpb24oZGVzY3JpcHRpb24sIGJhc2VQYXRoKSB7XG4gIGNvbnN0IHJlcXVpcmVtZW50cyA9IFtdO1xuICBpZiAoZGVzY3JpcHRpb24ua2V5cykge1xuICAgIGZvciAoY29uc3QgW2tleSwgZmllbGREZXNjXSBvZiBPYmplY3QuZW50cmllcyhkZXNjcmlwdGlvbi5rZXlzKSkge1xuICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBmaWVsZERlc2M7XG4gICAgICBjb25zdCBmaWVsZFBhdGggPSBgJHtiYXNlUGF0aH0uJHtrZXl9YDtcbiAgICAgIGNvbnN0IGlzUmVxdWlyZWQgPSBmaWVsZFNjaGVtYS5mbGFncz8ucHJlc2VuY2UgPT09IFwicmVxdWlyZWRcIiB8fCAhZmllbGRTY2hlbWEuZmxhZ3M/LnByZXNlbmNlICYmICFmaWVsZFNjaGVtYS5mbGFncz8ub3B0aW9uYWwgJiYgIWZpZWxkU2NoZW1hLmZsYWdzPy5kZWZhdWx0O1xuICAgICAgbGV0IGZpZWxkVHlwZSA9IGZpZWxkU2NoZW1hLnR5cGUgfHwgXCJhbnlcIjtcbiAgICAgIGlmIChmaWVsZFR5cGUgPT09IFwiYWx0ZXJuYXRpdmVzXCIgJiYgZmllbGRTY2hlbWEubWF0Y2hlcykge1xuICAgICAgICBmaWVsZFR5cGUgPSBmaWVsZFNjaGVtYS5tYXRjaGVzWzBdPy5zY2hlbWE/LnR5cGUgfHwgXCJhbnlcIjtcbiAgICAgIH1cbiAgICAgIGxldCBtZXNzYWdlID0gZmllbGRTY2hlbWEuZmxhZ3M/LmRlc2NyaXB0aW9uIHx8IFwiXCI7XG4gICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWFuZGF0b3J5ID0gaXNSZXF1aXJlZCA/IFwicmVxdWlyZWRcIiA6IFwib3B0aW9uYWxcIjtcbiAgICAgICAgbWVzc2FnZSA9IGAke2tleX0gaXMgJHttYW5kYXRvcnl9IGFuZCBtdXN0IGJlIG9mIHR5cGU6ICR7ZmllbGRUeXBlfWA7XG4gICAgICB9XG4gICAgICByZXF1aXJlbWVudHMucHVzaCh7XG4gICAgICAgIHBhdGg6IGZpZWxkUGF0aCxcbiAgICAgICAgdHlwZTogZmllbGRUeXBlLFxuICAgICAgICBhbGxvd1VuZGVmaW5lZDogIWlzUmVxdWlyZWQsXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgaWYgKGZpZWxkU2NoZW1hLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgZmllbGRTY2hlbWEua2V5cykge1xuICAgICAgICBjb25zdCBuZXN0ZWRSZXF1aXJlbWVudHMgPSBhbmFseXplSm9pU2NoZW1hRnJvbURlc2NyaXB0aW9uKGZpZWxkU2NoZW1hLCBmaWVsZFBhdGgpO1xuICAgICAgICByZXF1aXJlbWVudHMucHVzaCguLi5uZXN0ZWRSZXF1aXJlbWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVxdWlyZW1lbnRzO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVGYWxsYmFja1JlcXVpcmVtZW50cyhhZGFwdGVyTmFtZSkge1xuICBjb25zb2xlLmxvZyhgW2dldFJlcXVpcmVtZW50c10gTm8gcmVxdWlyZW1lbnRzIGZvdW5kIGZvciAke2FkYXB0ZXJOYW1lfSBpbnRlcmZhY2UgLSB1c2luZyBmYWxsYmFjay5gKTtcbiAgY29uc29sZS53YXJuKGBbZ2V0UmVxdWlyZW1lbnRzXSBVc2luZyBmYWxsYmFjayByZXF1aXJlbWVudHMgZm9yICR7YWRhcHRlck5hbWV9YCk7XG4gIGlmIChhZGFwdGVyTmFtZSA9PT0gXCJldGhlcnNcIikge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHBhdGg6IFwib3B0aW9ucy5wcml2YXRlS2V5XCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICAgICAgICBtZXNzYWdlOiBcIlByaXZhdGUga2V5IGZvciB3YWxsZXQgKGdlbmVyYXRlcyByYW5kb20gaWYgbm90IHByb3ZpZGVkKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXRoOiBcIm9wdGlvbnMucHJvdmlkZXJcIixcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYWxsb3dVbmRlZmluZWQ6IHRydWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiT3B0aW9uYWwgcHJvdmlkZXIgY29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBpZiAoYWRhcHRlck5hbWUgPT09IFwid2ViM2F1dGhcIikge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHBhdGg6IFwib3B0aW9ucy53ZWIzYXV0aENvbmZpZ1wiLFxuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhbGxvd1VuZGVmaW5lZDogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6IFwiV2ViM0F1dGggY29uZmlndXJhdGlvbiBvYmplY3QgaXMgcmVxdWlyZWRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGF0aDogXCJvcHRpb25zLndlYjNhdXRoQ29uZmlnLmNsaWVudElkXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGFsbG93VW5kZWZpbmVkOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogXCJZb3VyIFdlYjNBdXRoIENsaWVudCBJRCBpcyByZXF1aXJlZFwiXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBhbmFseXplTWV0aG9kU2lnbmF0dXJlKG1ldGhvZCwgbWV0aG9kTmFtZSkge1xuICB0cnkge1xuICAgIGNvbnN0IGZ1bmNTdHJpbmcgPSBtZXRob2QudG9TdHJpbmcoKTtcbiAgICBjb25zdCBwYXJhbU1hdGNoID0gZnVuY1N0cmluZy5tYXRjaCgvXFwoKFteKV0qKVxcKS8pO1xuICAgIGNvbnN0IHBhcmFtU3RyaW5nID0gcGFyYW1NYXRjaCA/IHBhcmFtTWF0Y2hbMV0udHJpbSgpIDogXCJcIjtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gcGFyYW1TdHJpbmcgPyBwYXJhbVN0cmluZy5zcGxpdChcIixcIikubWFwKChwYXJhbSkgPT4ge1xuICAgICAgY29uc3QgY2xlYW5QYXJhbSA9IHBhcmFtLnRyaW0oKTtcbiAgICAgIGNvbnN0IG5hbWUgPSBjbGVhblBhcmFtLnNwbGl0KC9bPTpdLylbMF0udHJpbSgpLnJlcGxhY2UoL1t7fVtcXF1dL2csIFwiXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSB8fCBcInBhcmFtXCIsXG4gICAgICAgIHR5cGU6IFwiYW55XCIsXG4gICAgICAgIC8vIFdlIGNhbid0IHJlbGlhYmx5IGV4dHJhY3QgdHlwZXMgZnJvbSBjb21waWxlZCBKU1xuICAgICAgICBvcHRpb25hbDogY2xlYW5QYXJhbS5pbmNsdWRlcyhcIj1cIikgfHwgY2xlYW5QYXJhbS5pbmNsdWRlcyhcIj9cIilcbiAgICAgIH07XG4gICAgfSkgOiBbXTtcbiAgICBjb25zdCBpc0FzeW5jID0gZnVuY1N0cmluZy5pbmNsdWRlcyhcImFzeW5jIFwiKSB8fCBmdW5jU3RyaW5nLmluY2x1ZGVzKFwiUHJvbWlzZVwiKSB8fCBmdW5jU3RyaW5nLmluY2x1ZGVzKFwiYXdhaXQgXCIpO1xuICAgIGxldCByZXR1cm5UeXBlID0gXCJhbnlcIjtcbiAgICBpZiAobWV0aG9kTmFtZS5zdGFydHNXaXRoKFwiaXNcIikgfHwgbWV0aG9kTmFtZS5zdGFydHNXaXRoKFwiaGFzXCIpKSB7XG4gICAgICByZXR1cm5UeXBlID0gXCJib29sZWFuXCI7XG4gICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSBcImluaXRpYWxpemVcIiB8fCBtZXRob2ROYW1lID09PSBcImRpc2Nvbm5lY3RcIikge1xuICAgICAgcmV0dXJuVHlwZSA9IFwidm9pZFwiO1xuICAgIH1cbiAgICBpZiAoaXNBc3luYyAmJiAhcmV0dXJuVHlwZS5pbmNsdWRlcyhcIlByb21pc2VcIikpIHtcbiAgICAgIHJldHVyblR5cGUgPSByZXR1cm5UeXBlID09PSBcInZvaWRcIiA/IFwiUHJvbWlzZTx2b2lkPlwiIDogYFByb21pc2U8JHtyZXR1cm5UeXBlfT5gO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhgXFx1MjcwNSBbYW5hbHl6ZU1ldGhvZFNpZ25hdHVyZV0gJHttZXRob2ROYW1lfSgke3BhcmFtZXRlcnMubGVuZ3RofSBwYXJhbXMpIC0+ICR7cmV0dXJuVHlwZX0sIGFzeW5jOiAke2lzQXN5bmN9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgcmV0dXJuVHlwZSxcbiAgICAgIGlzQXN5bmNcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihgXFx1Mjc0QyBbYW5hbHl6ZU1ldGhvZFNpZ25hdHVyZV0gRmFpbGVkIHRvIGFuYWx5emUgJHttZXRob2ROYW1lfTpgLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXSxcbiAgICAgIHJldHVyblR5cGU6IFwiYW55XCIsXG4gICAgICBpc0FzeW5jOiBmYWxzZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVudmlyb25tZW50cyhhZGFwdGVyTmFtZSwgc3VwcG9ydGVkRW52cywgY3VzdG9tTGltaXRhdGlvbnMsIGN1c3RvbVNlY3VyaXR5Tm90ZXMpIHtcbiAgY29uc3QgcmVxdWlyZW1lbnRzID0ge1xuICAgIHN1cHBvcnRlZEVudmlyb25tZW50czogWy4uLnN1cHBvcnRlZEVudnNdLFxuICAgIGxpbWl0YXRpb25zOiBbLi4uY3VzdG9tTGltaXRhdGlvbnMgfHwgW11dLFxuICAgIHNlY3VyaXR5Tm90ZXM6IFsuLi5jdXN0b21TZWN1cml0eU5vdGVzIHx8IFtdXVxuICB9O1xuICBmb3IgKGNvbnN0IGVudiBvZiBzdXBwb3J0ZWRFbnZzKSB7XG4gICAgc3dpdGNoIChlbnYpIHtcbiAgICAgIGNhc2UgUnVudGltZUVudmlyb25tZW50LkJST1dTRVI6XG4gICAgICAgIHJlcXVpcmVtZW50cy5saW1pdGF0aW9ucy5wdXNoKFwiUmVxdWlyZXMgYnJvd3NlciBlbnZpcm9ubWVudCB3aXRoIHdpbmRvdyBhbmQgZG9jdW1lbnQgb2JqZWN0c1wiLCBcIkNhbm5vdCBiZSB1c2VkIGluIE5vZGUuanMgc2VydmVyIGVudmlyb25tZW50c1wiLCBcIk1heSByZXF1aXJlIHVzZXIgaW50ZXJhY3Rpb24gZm9yIGF1dGhlbnRpY2F0aW9uIGZsb3dzXCIpO1xuICAgICAgICByZXF1aXJlbWVudHMuc2VjdXJpdHlOb3Rlcy5wdXNoKFwiRW5zdXJlIHNlY3VyZSBoYW5kbGluZyBvZiBwcml2YXRlIGtleXMgaW4gYnJvd3NlciBlbnZpcm9ubWVudFwiLCBcIkNvbnNpZGVyIHVzaW5nIGhhcmR3YXJlIHdhbGxldHMgZm9yIGVuaGFuY2VkIHNlY3VyaXR5XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUnVudGltZUVudmlyb25tZW50LlNFUlZFUjpcbiAgICAgICAgcmVxdWlyZW1lbnRzLmxpbWl0YXRpb25zLnB1c2goXCJSZXF1aXJlcyBOb2RlLmpzIHNlcnZlciBlbnZpcm9ubWVudFwiLCBcIkNhbm5vdCBiZSB1c2VkIGluIGJyb3dzZXIgZW52aXJvbm1lbnRzXCIpO1xuICAgICAgICByZXF1aXJlbWVudHMuc2VjdXJpdHlOb3Rlcy5wdXNoKFwiU2VydmVyIGVudmlyb25tZW50cyBwcm92aWRlIGJldHRlciBzZWN1cml0eSBmb3Igc2Vuc2l0aXZlIG9wZXJhdGlvbnNcIiwgXCJFbnN1cmUgcHJvcGVyIHByaXZhdGUga2V5IG1hbmFnZW1lbnQgYW5kIHN0b3JhZ2VcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXF1aXJlbWVudHMuc2VjdXJpdHlOb3Rlcy5wdXNoKGAke2FkYXB0ZXJOYW1lfSBhZGFwdGVyIGZvbGxvd3Mgc3RhbmRhcmQgc2VjdXJpdHkgcHJhY3RpY2VzYCk7XG4gIHJlcXVpcmVtZW50cy5saW1pdGF0aW9ucyA9IFsuLi5uZXcgU2V0KHJlcXVpcmVtZW50cy5saW1pdGF0aW9ucyldO1xuICByZXF1aXJlbWVudHMuc2VjdXJpdHlOb3RlcyA9IFsuLi5uZXcgU2V0KHJlcXVpcmVtZW50cy5zZWN1cml0eU5vdGVzKV07XG4gIHJldHVybiByZXF1aXJlbWVudHM7XG59XG5mdW5jdGlvbiBnZXRGZWF0dXJlcyhhZGFwdGVyQ2xhc3MpIHtcbiAgaWYgKCFhZGFwdGVyQ2xhc3MgfHwgdHlwZW9mIGFkYXB0ZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZS53YXJuKGBbZ2V0RmVhdHVyZXNdIEludmFsaWQgYWRhcHRlciBjbGFzcyBwcm92aWRlZDpgLCB0eXBlb2YgYWRhcHRlckNsYXNzKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc29sZS5sb2coYFxcdXsxRjUyN30gW2dldEZlYXR1cmVzXSBBbmFseXppbmcgJHthZGFwdGVyQ2xhc3MubmFtZX0gZm9yIG1ldGhvZCBzaWduYXR1cmVzIGJ5IHdhbGtpbmcgcHJvdG90eXBlIGNoYWluLmApO1xuICBjb25zdCBzaWduYXR1cmVzID0gW107XG4gIGNvbnN0IHNlZW5NZXRob2RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGN1cnJlbnRQcm90byA9IGFkYXB0ZXJDbGFzcy5wcm90b3R5cGU7XG4gIHdoaWxlIChjdXJyZW50UHJvdG8gJiYgY3VycmVudFByb3RvICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgY29uc3QgbWV0aG9kTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdXJyZW50UHJvdG8pLmZpbHRlcigobmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIG5hbWUgIT09IFwiY29uc3RydWN0b3JcIiAmJiAhbmFtZS5zdGFydHNXaXRoKFwiX1wiKSAmJiAhc2Vlbk1ldGhvZHMuaGFzKG5hbWUpICYmIHR5cGVvZiBjdXJyZW50UHJvdG9bbmFtZV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZyhgXFx1ezFGNTBEfSBbZ2V0RmVhdHVyZXNdIEZvdW5kICR7bWV0aG9kTmFtZXMubGVuZ3RofSBtZXRob2RzIG9uICR7Y3VycmVudFByb3RvLmNvbnN0cnVjdG9yLm5hbWV9OmAsIG1ldGhvZE5hbWVzKTtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgb2YgbWV0aG9kTmFtZXMpIHtcbiAgICAgIHNlZW5NZXRob2RzLmFkZChtZXRob2ROYW1lKTtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IGN1cnJlbnRQcm90b1ttZXRob2ROYW1lXTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGFuYWx5emVNZXRob2RTaWduYXR1cmUobWV0aG9kLCBtZXRob2ROYW1lKTtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgIH1cbiAgICBjdXJyZW50UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudFByb3RvKTtcbiAgfVxuICBjb25zb2xlLmxvZyhgXFx1MjcwNSBbZ2V0RmVhdHVyZXNdIEdlbmVyYXRlZCAke3NpZ25hdHVyZXMubGVuZ3RofSB0b3RhbCBtZXRob2Qgc2lnbmF0dXJlcyBmb3IgJHthZGFwdGVyQ2xhc3MubmFtZX1gKTtcbiAgcmV0dXJuIHNpZ25hdHVyZXM7XG59XG5mdW5jdGlvbiBnZXRSZXF1aXJlbWVudHMoam9pU2NoZW1hLCBhZGFwdGVyTmFtZSkge1xuICBjb25zb2xlLmxvZyhgXFx1ezFGNTBEfSBbZ2V0UmVxdWlyZW1lbnRzXSBTdGFydGluZyBhbmFseXNpcyBmb3IgJHthZGFwdGVyTmFtZX1gKTtcbiAgaWYgKGFkYXB0ZXJOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZXRoZXJzXCIpIHtcbiAgICBjb25zb2xlLmxvZyhgW2dldFJlcXVpcmVtZW50c10gVXNpbmcgZmFsbGJhY2sgcmVxdWlyZW1lbnRzIGZvciAke2FkYXB0ZXJOYW1lfWApO1xuICAgIHJldHVybiBnZW5lcmF0ZUZhbGxiYWNrUmVxdWlyZW1lbnRzKGFkYXB0ZXJOYW1lKTtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnNvbGUubG9nKGBcXHV7MUYzMTB9IFtnZXRSZXF1aXJlbWVudHNdIEJyb3dzZXIgZW52aXJvbm1lbnQgLSB1c2luZyBmYWxsYmFjayBmb3IgJHthZGFwdGVyTmFtZX1gKTtcbiAgICByZXR1cm4gZ2VuZXJhdGVGYWxsYmFja1JlcXVpcmVtZW50cyhhZGFwdGVyTmFtZSk7XG4gIH1cbiAgaWYgKGpvaVNjaGVtYSAmJiB0eXBlb2Ygam9pU2NoZW1hLmRlc2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGFuYWx5emVKb2lTY2hlbWEoam9pU2NoZW1hLCBcIm9wdGlvbnNcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFxcdTI3NEMgW2dldFJlcXVpcmVtZW50c10gSk9JIHZhbGlkYXRpb24gZmFpbGVkOmAsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlbmVyYXRlRmFsbGJhY2tSZXF1aXJlbWVudHMoYWRhcHRlck5hbWUpO1xufVxuXG4vLyBwYWNrYWdlcy93YWxsZXQvZGlzdC9hZGFwdGVycy9ldGhlcnMvZXRoZXJzV2FsbGV0LmpzXG5pbXBvcnQgeyBldGhlcnMgYXMgZXRoZXJzMywgV2FsbGV0IGFzIEV0aGVyc1dhbGxldDIsIEpzb25ScGNQcm92aWRlciBhcyBKc29uUnBjUHJvdmlkZXIyIH0gZnJvbSBcImV0aGVyc1wiO1xuXG4vLyBwYWNrYWdlcy93YWxsZXQvZGlzdC90eXBlcy9lbnVtcy9pbmRleC5qc1xudmFyIFdhbGxldEV2ZW50O1xuKGZ1bmN0aW9uKFdhbGxldEV2ZW50Mikge1xuICBXYWxsZXRFdmVudDJbXCJjb25uZWN0XCJdID0gXCJjb25uZWN0XCI7XG4gIFdhbGxldEV2ZW50MltcImRpc2Nvbm5lY3RcIl0gPSBcImRpc2Nvbm5lY3RcIjtcbiAgV2FsbGV0RXZlbnQyW1wiYWNjb3VudHNDaGFuZ2VkXCJdID0gXCJhY2NvdW50c0NoYW5nZWRcIjtcbiAgV2FsbGV0RXZlbnQyW1wiY2hhaW5DaGFuZ2VkXCJdID0gXCJjaGFpbkNoYW5nZWRcIjtcbiAgV2FsbGV0RXZlbnQyW1wiYmFsYW5jZUNoYW5nZWRcIl0gPSBcImJhbGFuY2VDaGFuZ2VkXCI7XG4gIFdhbGxldEV2ZW50MltcIm1lc3NhZ2VcIl0gPSBcIm1lc3NhZ2VcIjtcbiAgV2FsbGV0RXZlbnQyW1wiZXJyb3JcIl0gPSBcImVycm9yXCI7XG59KShXYWxsZXRFdmVudCB8fCAoV2FsbGV0RXZlbnQgPSB7fSkpO1xudmFyIFdhbGxldFR5cGU7XG4oZnVuY3Rpb24oV2FsbGV0VHlwZTIpIHtcbiAgV2FsbGV0VHlwZTJbXCJjb3JlXCJdID0gXCJjb3JlXCI7XG4gIFdhbGxldFR5cGUyW1wiZXZtXCJdID0gXCJldm1cIjtcbiAgV2FsbGV0VHlwZTJbXCJ3ZWIzYXV0aFwiXSA9IFwid2ViM2F1dGhcIjtcbn0pKFdhbGxldFR5cGUgfHwgKFdhbGxldFR5cGUgPSB7fSkpO1xudmFyIE5vbmNlVHlwZTtcbihmdW5jdGlvbihOb25jZVR5cGUyKSB7XG4gIE5vbmNlVHlwZTJbXCJsYXRlc3RcIl0gPSBcImxhdGVzdFwiO1xuICBOb25jZVR5cGUyW1wicGVuZGluZ1wiXSA9IFwicGVuZGluZ1wiO1xufSkoTm9uY2VUeXBlIHx8IChOb25jZVR5cGUgPSB7fSkpO1xuXG4vLyBwYWNrYWdlcy93YWxsZXQvZGlzdC9oZWxwZXJzL3NpZ25hdHVyZXMuanNcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcbnZhciBFSVA3MTJWYWxpZGF0b3IgPSBjbGFzcyBfRUlQNzEyVmFsaWRhdG9yIHtcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgYmFzaWMgc3RydWN0dXJlIG9mIEVJUC03MTIgdHlwZWQgZGF0YVxuICAgKiBAcGFyYW0gZGF0YSBUaGUgdHlwZWQgZGF0YSB0byB2YWxpZGF0ZVxuICAgKiBAdGhyb3dzIEFkYXB0ZXJFcnJvciBpZiBzdHJ1Y3R1cmUgaXMgaW52YWxpZFxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlU3RydWN0dXJlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJJbnZhbGlkIEVJUC03MTIgc3RydWN0dXJlOiBkYXRhIG11c3QgYmUgYW4gb2JqZWN0XCIsIHtcbiAgICAgICAgY29kZTogV2FsbGV0RXJyb3JDb2RlLkludmFsaWRJbnB1dCxcbiAgICAgICAgbWV0aG9kTmFtZTogXCJzaWduVHlwZWREYXRhXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWRhdGEuZG9tYWluKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiSW52YWxpZCBFSVAtNzEyIHN0cnVjdHVyZTogbXVzdCBoYXZlIGRvbWFpbiBvYmplY3RcIiwge1xuICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgICBtZXRob2ROYW1lOiBcInNpZ25UeXBlZERhdGFcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YS5kb21haW4gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJJbnZhbGlkIEVJUC03MTIgc3RydWN0dXJlOiBkb21haW4gbXVzdCBiZSBhbiBvYmplY3RcIiwge1xuICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgICBtZXRob2ROYW1lOiBcInNpZ25UeXBlZERhdGFcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghZGF0YS50eXBlcykge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIkludmFsaWQgRUlQLTcxMiBzdHJ1Y3R1cmU6IG11c3QgaGF2ZSB0eXBlcyBvYmplY3RcIiwge1xuICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgICBtZXRob2ROYW1lOiBcInNpZ25UeXBlZERhdGFcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YS50eXBlcyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIkludmFsaWQgRUlQLTcxMiBzdHJ1Y3R1cmU6IHR5cGVzIG11c3QgYmUgYW4gb2JqZWN0XCIsIHtcbiAgICAgICAgY29kZTogV2FsbGV0RXJyb3JDb2RlLkludmFsaWRJbnB1dCxcbiAgICAgICAgbWV0aG9kTmFtZTogXCJzaWduVHlwZWREYXRhXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGF0YS52YWx1ZSA9PT0gdm9pZCAwIHx8IGRhdGEudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJJbnZhbGlkIEVJUC03MTIgc3RydWN0dXJlOiBtdXN0IGhhdmUgdmFsdWVcIiwge1xuICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgICBtZXRob2ROYW1lOiBcInNpZ25UeXBlZERhdGFcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIEVJUC03MTIgZG9tYWluIGFnYWluc3QgdGhlIGN1cnJlbnQgbmV0d29ya1xuICAgKiBAcGFyYW0gZG9tYWluIFRoZSBkb21haW4gb2JqZWN0IGZyb20gdHlwZWQgZGF0YVxuICAgKiBAcGFyYW0gY3VycmVudENoYWluSWQgVGhlIGN1cnJlbnQgbmV0d29yaydzIGNoYWluIElEXG4gICAqIEB0aHJvd3MgQWRhcHRlckVycm9yIGlmIGRvbWFpbiBpcyBpbnZhbGlkIG9yIGRvZXNuJ3QgbWF0Y2ggbmV0d29ya1xuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlRG9tYWluKGRvbWFpbiwgY3VycmVudENoYWluSWQpIHtcbiAgICBpZiAoIWRvbWFpbi5jaGFpbklkICYmIGRvbWFpbi5jaGFpbklkICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiRUlQLTcxMiBkb21haW4gbWlzc2luZyBjaGFpbklkXCIsIHtcbiAgICAgICAgY29kZTogV2FsbGV0RXJyb3JDb2RlLkludmFsaWRJbnB1dCxcbiAgICAgICAgbWV0aG9kTmFtZTogXCJzaWduVHlwZWREYXRhXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBkb21haW5DaGFpbklkID0gZG9tYWluLmNoYWluSWQudG9TdHJpbmcoKTtcbiAgICBjb25zdCBuZXR3b3JrQ2hhaW5JZCA9IGN1cnJlbnRDaGFpbklkLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgZG9tYWluQ2hhaW5JZEhleCA9IGRvbWFpbkNoYWluSWQuc3RhcnRzV2l0aChcIjB4XCIpID8gZG9tYWluQ2hhaW5JZCA6IGAweCR7cGFyc2VJbnQoZG9tYWluQ2hhaW5JZCwgMTApLnRvU3RyaW5nKDE2KX1gO1xuICAgIGNvbnN0IG5ldHdvcmtDaGFpbklkSGV4ID0gbmV0d29ya0NoYWluSWQuc3RhcnRzV2l0aChcIjB4XCIpID8gbmV0d29ya0NoYWluSWQgOiBgMHgke3BhcnNlSW50KG5ldHdvcmtDaGFpbklkLCAxMCkudG9TdHJpbmcoMTYpfWA7XG4gICAgaWYgKGRvbWFpbkNoYWluSWRIZXgudG9Mb3dlckNhc2UoKSAhPT0gbmV0d29ya0NoYWluSWRIZXgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihgRUlQLTcxMiBkb21haW4gY2hhaW5JZCAoJHtkb21haW5DaGFpbklkfSkgZG9lc24ndCBtYXRjaCBjdXJyZW50IG5ldHdvcmsgKCR7Y3VycmVudENoYWluSWR9KWAsIHtcbiAgICAgICAgY29kZTogV2FsbGV0RXJyb3JDb2RlLkludmFsaWRJbnB1dCxcbiAgICAgICAgbWV0aG9kTmFtZTogXCJzaWduVHlwZWREYXRhXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICFldGhlcnMuaXNBZGRyZXNzKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCkpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJFSVAtNzEyIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBtdXN0IGJlIGEgdmFsaWQgYWRkcmVzc1wiLCB7XG4gICAgICAgIGNvZGU6IFdhbGxldEVycm9yQ29kZS5JbnZhbGlkSW5wdXQsXG4gICAgICAgIG1ldGhvZE5hbWU6IFwic2lnblR5cGVkRGF0YVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgdHlwZXMgc3RydWN0dXJlIG9mIEVJUC03MTIgdHlwZWQgZGF0YVxuICAgKiBAcGFyYW0gdHlwZXMgVGhlIHR5cGVzIG9iamVjdCBmcm9tIHR5cGVkIGRhdGFcbiAgICogQHRocm93cyBBZGFwdGVyRXJyb3IgaWYgdHlwZXMgc3RydWN0dXJlIGlzIGludmFsaWRcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVR5cGVzKHR5cGVzKSB7XG4gICAgZm9yIChjb25zdCBbdHlwZU5hbWUsIGZpZWxkc10gb2YgT2JqZWN0LmVudHJpZXModHlwZXMpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBFSVAtNzEyIHR5cGUgJyR7dHlwZU5hbWV9JyBtdXN0IGJlIGFuIGFycmF5IG9mIGZpZWxkIGRlZmluaXRpb25zYCwge1xuICAgICAgICAgIGNvZGU6IFdhbGxldEVycm9yQ29kZS5JbnZhbGlkSW5wdXQsXG4gICAgICAgICAgbWV0aG9kTmFtZTogXCJzaWduVHlwZWREYXRhXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICBpZiAoIWZpZWxkLm5hbWUgfHwgIWZpZWxkLnR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBFSVAtNzEyIGZpZWxkIGluICcke3R5cGVOYW1lfScgbWlzc2luZyBuYW1lIG9yIHR5cGVgLCB7XG4gICAgICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgICAgICAgbWV0aG9kTmFtZTogXCJzaWduVHlwZWREYXRhXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9FSVA3MTJWYWxpZGF0b3IuaXNWYWxpZEVJUDcxMlR5cGUoZmllbGQudHlwZSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFtFSVA3MTJWYWxpZGF0b3JdIFdhcm5pbmc6IEVJUC03MTIgZmllbGQgdHlwZSAnJHtmaWVsZC50eXBlfScgbWF5IG5vdCBiZSBzdGFuZGFyZGApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgYSB0eXBlIHN0cmluZyBjb25mb3JtcyB0byBFSVAtNzEyIHN0YW5kYXJkc1xuICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHlwZSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZEVJUDcxMlR5cGUodHlwZSkge1xuICAgIGNvbnN0IGJhc2ljVHlwZXMgPSBbXCJib29sXCIsIFwiYWRkcmVzc1wiLCBcInN0cmluZ1wiLCBcImJ5dGVzXCJdO1xuICAgIGNvbnN0IGR5bmFtaWNUeXBlcyA9IC9eKGJ5dGVzXFxkK3x1aW50XFxkK3xpbnRcXGQrKSQvO1xuICAgIGNvbnN0IGFycmF5VHlwZXMgPSAvXiguKylcXFtcXGQqXFxdJC87XG4gICAgaWYgKGJhc2ljVHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZHluYW1pY1R5cGVzLnRlc3QodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoYXJyYXlUeXBlcy50ZXN0KHR5cGUpKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goYXJyYXlUeXBlcyk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgaWYgKCFiYXNlVHlwZS5pbmNsdWRlcyhcIltcIikpIHtcbiAgICAgICAgICByZXR1cm4gX0VJUDcxMlZhbGlkYXRvci5pc1ZhbGlkRUlQNzEyVHlwZShiYXNlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgY29tcHJlaGVuc2l2ZSBFSVAtNzEyIHZhbGlkYXRpb25cbiAgICogQHBhcmFtIGRhdGEgVGhlIHR5cGVkIGRhdGEgdG8gdmFsaWRhdGVcbiAgICogQHBhcmFtIGN1cnJlbnRDaGFpbklkIFRoZSBjdXJyZW50IG5ldHdvcmsncyBjaGFpbiBJRFxuICAgKiBAdGhyb3dzIEFkYXB0ZXJFcnJvciBpZiBhbnkgdmFsaWRhdGlvbiBmYWlsc1xuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlQWxsKGRhdGEsIGN1cnJlbnRDaGFpbklkKSB7XG4gICAgX0VJUDcxMlZhbGlkYXRvci52YWxpZGF0ZVN0cnVjdHVyZShkYXRhKTtcbiAgICBfRUlQNzEyVmFsaWRhdG9yLnZhbGlkYXRlRG9tYWluKGRhdGEuZG9tYWluLCBjdXJyZW50Q2hhaW5JZCk7XG4gICAgX0VJUDcxMlZhbGlkYXRvci52YWxpZGF0ZVR5cGVzKGRhdGEudHlwZXMpO1xuICB9XG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBpbW1lZGlhdGVseSBhZnRlciBzaWduaW5nIGZvciBhZGRpdGlvbmFsIHNlY3VyaXR5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSB0eXBlZCBkYXRhIHRoYXQgd2FzIHNpZ25lZFxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIFRoZSBzaWduYXR1cmUgdG8gdmVyaWZ5XG4gICAqIEBwYXJhbSBleHBlY3RlZEFkZHJlc3MgVGhlIGV4cGVjdGVkIHNpZ25lciBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHRydWUgaWYgc2lnbmF0dXJlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHN0YXRpYyB2ZXJpZnlTaWduYXR1cmUoZGF0YSwgc2lnbmF0dXJlLCBleHBlY3RlZEFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVjb3ZlcmVkQWRkcmVzcyA9IGV0aGVycy52ZXJpZnlUeXBlZERhdGEoZGF0YS5kb21haW4sIGRhdGEudHlwZXMsIGRhdGEudmFsdWUsIHNpZ25hdHVyZSk7XG4gICAgICByZXR1cm4gcmVjb3ZlcmVkQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBleHBlY3RlZEFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltFSVA3MTJWYWxpZGF0b3JdIFNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgc2lnbmF0dXJlIGZvcm1hdCBmb3IgRUlQLTcxMlxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIFRoZSBzaWduYXR1cmUgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBmb3JtYXQgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRTaWduYXR1cmVGb3JtYXQoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZS5zdGFydHNXaXRoKFwiMHhcIikgJiYgc2lnbmF0dXJlLmxlbmd0aCA9PT0gMTMyO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy93YWxsZXQvZGlzdC9oZWxwZXJzL3VuaXRzLmpzXG5pbXBvcnQgeyBldGhlcnMgYXMgZXRoZXJzMiB9IGZyb20gXCJldGhlcnNcIjtcbmZ1bmN0aW9uIHRvV2VpKHZhbHVlLCBkZWNpbWFscykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgY29uc3QgcyA9IFN0cmluZyh2YWx1ZSkudHJpbSgpO1xuICBpZiAoIXMgfHwgcyA9PT0gXCIwXCIpIHtcbiAgICByZXR1cm4gXCIwXCI7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXRoZXJzMi5wYXJzZVVuaXRzKHMsIGRlY2ltYWxzKS50b1N0cmluZygpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBJbnZhbGlkIHZhbHVlIGZvcm1hdDogJHt2YWx1ZX1gLCB7XG4gICAgICBtZXRob2ROYW1lOiBcInRvV2VpXCIsXG4gICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgY2F1c2U6IGVyclxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiB0b0JpZ0ludCh2YWx1ZSkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgIHJldHVybiBCaWdJbnQodmFsdWUudHJpbSgpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihgSW52YWxpZCBCaWdJbnQgdmFsdWU6ICR7dmFsdWV9YCwge1xuICAgICAgbWV0aG9kTmFtZTogXCJ0b0JpZ0ludFwiLFxuICAgICAgY29kZTogV2FsbGV0RXJyb3JDb2RlLkludmFsaWRJbnB1dCxcbiAgICAgIGNhdXNlOiBlcnJcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy93YWxsZXQvZGlzdC9hZGFwdGVycy9ldGhlcnMvZXRoZXJzV2FsbGV0LmpzXG52YXIgRXZtV2FsbGV0QWRhcHRlciA9IGNsYXNzIF9Fdm1XYWxsZXRBZGFwdGVyIHtcbiAgLy8gTkVXOiBBZGQgbG9jYWwgbmV0d29yayBzdGF0ZVxuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5hbWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInZlcnNpb25cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIndhbGxldFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvdmlkZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbmZpZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2Nvbm5lY3RlZFwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluaXRpYWxpemVkXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGVjaW1hbHNcIiwgMTgpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJldmVudExpc3RlbmVyc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXVsdGlDaGFpblJwY3NcIiwge30pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuZXR3b3JrXCIsIG51bGwpO1xuICAgIHRoaXMubmFtZSA9IGFyZ3MubmFtZTtcbiAgICB0aGlzLnZlcnNpb24gPSBhcmdzLnZlcnNpb247XG4gICAgdGhpcy5jb25maWcgPSBhcmdzO1xuICAgIHRoaXMubXVsdGlDaGFpblJwY3MgPSBhcmdzLm9wdGlvbnMubXVsdGlDaGFpblJwY3MgfHwge307XG4gIH1cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBhbiBpbnN0YW5jZSBvZiBFdm1XYWxsZXRBZGFwdGVyLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShhcmdzKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgX0V2bVdhbGxldEFkYXB0ZXIoYXJncyk7XG4gICAgYXdhaXQgaW5zdGFuY2UuaW5pdGlhbGl6ZSgpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICAvLyAtLS0gQ29yZSBMaWZlY3ljbGUgJiBDb25uZWN0aW9uIE1ldGhvZHMgLS0tXG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBwcml2YXRlS2V5LCBwcm92aWRlcjogcHJvdmlkZXJDb25maWcgfSA9IHRoaXMuY29uZmlnLm9wdGlvbnM7XG4gICAgaWYgKCFwcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwicHJpdmF0ZUtleSBpcyByZXF1aXJlZCBpbiBvcHRpb25zLlwiLCB7XG4gICAgICAgIGNvZGU6IFdhbGxldEVycm9yQ29kZS5NaXNzaW5nQ29uZmlnLFxuICAgICAgICBtZXRob2ROYW1lOiBcImluaXRpYWxpemVcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMud2FsbGV0ID0gbmV3IEV0aGVyc1dhbGxldDIocHJpdmF0ZUtleSk7XG4gICAgaWYgKHByb3ZpZGVyQ29uZmlnKSB7XG4gICAgICBhd2FpdCB0aGlzLnNldFByb3ZpZGVyKHByb3ZpZGVyQ29uZmlnKTtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gdm9pZCAwO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJkaXNjb25uZWN0XCIsIHZvaWQgMCk7XG4gIH1cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZCAmJiAhIXRoaXMucHJvdmlkZXIgJiYgISF0aGlzLndhbGxldDtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVkO1xuICB9XG4gIC8qKlxuICAqIEdldCBBTEwgY29uZmlndXJlZCBSUEMgVVJMcyBmb3IgQUxMIGNoYWluc1xuICAqL1xuICBnZXRBbGxDaGFpblJwY3MoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5tdWx0aUNoYWluUnBjcyB9O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgQUxMIFJQQyBjb25maWd1cmF0aW9ucyBhdCBvbmNlXG4gICAqL1xuICBhc3luYyB1cGRhdGVBbGxDaGFpblJwY3MobXVsdGlDaGFpblJwY3MpIHtcbiAgICBpZiAoIW11bHRpQ2hhaW5ScGNzIHx8IHR5cGVvZiBtdWx0aUNoYWluUnBjcyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIkludmFsaWQgUlBDIGNvbmZpZ3VyYXRpb24gLSBtdXN0IGJlIGFuIG9iamVjdFwiLCB7XG4gICAgICAgIGNvZGU6IFdhbGxldEVycm9yQ29kZS5JbnZhbGlkSW5wdXQsXG4gICAgICAgIG1ldGhvZE5hbWU6IFwidXBkYXRlQWxsQ2hhaW5ScGNzXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtjaGFpbklkLCBycGNVcmxzXSBvZiBPYmplY3QuZW50cmllcyhtdWx0aUNoYWluUnBjcykpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShycGNVcmxzKSkge1xuICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBJbnZhbGlkIFJQQyBVUkxzIGZvciBjaGFpbiAke2NoYWluSWR9IC0gbXVzdCBiZSBhcnJheWAsIHtcbiAgICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgICAgIG1ldGhvZE5hbWU6IFwidXBkYXRlQWxsQ2hhaW5ScGNzXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocnBjVXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihgSW52YWxpZCBSUEMgVVJMcyBmb3IgY2hhaW4gJHtjaGFpbklkfSAtIGFycmF5IGNhbm5vdCBiZSBlbXB0eWAsIHtcbiAgICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgICAgIG1ldGhvZE5hbWU6IFwidXBkYXRlQWxsQ2hhaW5ScGNzXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHVybCBvZiBycGNVcmxzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiIHx8ICF1cmwuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgJiYgIXVybC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBJbnZhbGlkIFJQQyBVUkwgZm9yIGNoYWluICR7Y2hhaW5JZH06ICR7dXJsfSAtIG11c3QgYmUgSFRUUC9IVFRQUyBVUkxgLCB7XG4gICAgICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgICAgICAgbWV0aG9kTmFtZTogXCJ1cGRhdGVBbGxDaGFpblJwY3NcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubXVsdGlDaGFpblJwY3MgPSB7IC4uLm11bHRpQ2hhaW5ScGNzIH07XG4gICAgY29uc29sZS5sb2coYFtFdm1XYWxsZXRBZGFwdGVyXSBVcGRhdGVkIGFsbCBjaGFpbiBSUENzIGZvciAke09iamVjdC5rZXlzKG11bHRpQ2hhaW5ScGNzKS5sZW5ndGh9IGNoYWluc2ApO1xuICB9XG4gIGFzeW5jIHNldFByb3ZpZGVyKGNvbmZpZykge1xuICAgIGlmICghY29uZmlnLmNoYWluSWQpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJjaGFpbklkIGlzIHJlcXVpcmVkIGluIE5ldHdvcmtDb25maWdcIiwge1xuICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgICBtZXRob2ROYW1lOiBcInNldFByb3ZpZGVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjaWQgPSBjb25maWcuY2hhaW5JZDtcbiAgICBjb25zdCBwcmVmZXJyZWQgPSB0aGlzLm11bHRpQ2hhaW5ScGNzW2NpZF0gfHwgdGhpcy5tdWx0aUNoYWluUnBjc1tTdHJpbmcoY2lkKV0gfHwgW107XG4gICAgY29uc3QgbmV0d29ya0hlbHBlciA9IE5ldHdvcmtIZWxwZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICBhd2FpdCBuZXR3b3JrSGVscGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgY29uc3QgbmV0Q29uZiA9IGF3YWl0IG5ldHdvcmtIZWxwZXIuZ2V0TmV0d29ya0NvbmZpZyhjaWQsIHByZWZlcnJlZCwgZmFsc2UpO1xuICAgIGlmICghbmV0Q29uZikge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihgRmFpbGVkIHRvIGNvbm5lY3QgdG8gYW55IHByb3ZpZGVkIFJQQyBVUkwgZm9yIGNoYWluICR7Y2lkfWAsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLkNvbm5lY3Rpb25GYWlsZWQsIG1ldGhvZE5hbWU6IFwic2V0UHJvdmlkZXJcIiB9KTtcbiAgICB9XG4gICAgdGhpcy5uZXR3b3JrID0gbnVsbDtcbiAgICB0aGlzLm5ldHdvcmsgPSBuZXRDb25mO1xuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgSnNvblJwY1Byb3ZpZGVyMihuZXRDb25mLnJwY1VybHNbMF0pO1xuICAgIGlmICh0aGlzLndhbGxldCkge1xuICAgICAgdGhpcy53YWxsZXQgPSB0aGlzLndhbGxldC5jb25uZWN0KHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdEV2ZW50KFdhbGxldEV2ZW50LmNoYWluQ2hhbmdlZCwgbmV0Q29uZi5jaGFpbklkKTtcbiAgfVxuICBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRMaXN0ZW5lcnMuaGFzKGV2ZW50KSkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5zZXQoZXZlbnQsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudCkuYWRkKGNhbGxiYWNrKTtcbiAgfVxuICBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnMuaGFzKGV2ZW50KSkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZXZlbnQpLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIGVtaXRFdmVudChldmVudE5hbWUsIHBheWxvYWQpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLnNpemUgPiAwKSB7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsYmFjayhwYXlsb2FkKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHt0aGlzLm5hbWV9XSBFcnJvciBpbiAke2V2ZW50TmFtZX0gZXZlbnQgaGFuZGxlcjpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvLyAtLS0gV2FsbGV0IEluZm9ybWF0aW9uICYgU3RhdGUgLS0tXG4gIGFzeW5jIGdldEFjY291bnRzKCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWQuXCIsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLldhbGxldE5vdENvbm5lY3RlZCB9KTtcbiAgICB9XG4gICAgY29uc3QgYWNjb3VudHMgPSBbdGhpcy53YWxsZXQuYWRkcmVzc107XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJhY2NvdW50c0NoYW5nZWRcIiwgYWNjb3VudHMpO1xuICAgIHJldHVybiBhY2NvdW50cztcbiAgfVxuICBhc3luYyBnZXROZXR3b3JrKCkge1xuICAgIGlmICghdGhpcy5uZXR3b3JrKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiTm8gbmV0d29yayBjb25maWd1cmVkLlwiLCB7IGNvZGU6IFdhbGxldEVycm9yQ29kZS5XYWxsZXROb3RDb25uZWN0ZWQsIG1ldGhvZE5hbWU6IFwiZ2V0TmV0d29ya1wiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uZXR3b3JrO1xuICB9XG4gIGFzeW5jIGdldEJhbGFuY2UoYWNjb3VudCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiTm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkLCBtZXRob2ROYW1lOiBcImdldEJhbGFuY2VcIiB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGFjY291bnQgfHwgKGF3YWl0IHRoaXMuZ2V0QWNjb3VudHMoKSlbMF07XG4gICAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIk5vIGFjY291bnQgYXZhaWxhYmxlLlwiLCB7IGNvZGU6IFdhbGxldEVycm9yQ29kZS5BY2NvdW50VW5hdmFpbGFibGUsIG1ldGhvZE5hbWU6IFwiZ2V0QmFsYW5jZVwiIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFsYW5jZVdlaSA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UoYWRkcmVzcyk7XG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnID0gYXdhaXQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICB0aGlzLmRlY2ltYWxzID0gbmV0d29ya0NvbmZpZy5kZWNpbWFscyB8fCAxODtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFtb3VudDogYmFsYW5jZVdlaS50b1N0cmluZygpLFxuICAgICAgICBkZWNpbWFsczogdGhpcy5kZWNpbWFscyxcbiAgICAgICAgc3ltYm9sOiBuZXR3b3JrQ29uZmlnLnRpY2tlciB8fCBcIkVUSFwiLFxuICAgICAgICBmb3JtYXR0ZWRBbW91bnQ6IGV0aGVyczMuZm9ybWF0VW5pdHMoYmFsYW5jZVdlaSwgdGhpcy5kZWNpbWFscylcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYEZhaWxlZCB0byBnZXQgYmFsYW5jZTogJHtlcnJvci5tZXNzYWdlfWAsIHsgY2F1c2U6IGVycm9yLCBjb2RlOiBXYWxsZXRFcnJvckNvZGUuTmV0d29ya0Vycm9yLCBtZXRob2ROYW1lOiBcImdldEJhbGFuY2VcIiB9KTtcbiAgICB9XG4gIH1cbiAgLy8gLS0tIFNpZ25pbmcgTWV0aG9kcyAtLS1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWQuXCIsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLldhbGxldE5vdENvbm5lY3RlZCwgbWV0aG9kTmFtZTogXCJzaWduTWVzc2FnZVwiIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICAgIHJldHVybiBhd2FpdCBzaWduZXIuc2lnbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VUZXh0ID0gZXJyb3Iuc2hvcnRNZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKTtcbiAgICAgIGxldCBjb2RlID0gV2FsbGV0RXJyb3JDb2RlLlNpZ25pbmdGYWlsZWQ7XG4gICAgICBpZiAobWVzc2FnZVRleHQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInVzZXIgZGVuaWVkXCIpKVxuICAgICAgICBjb2RlID0gV2FsbGV0RXJyb3JDb2RlLlVzZXJSZWplY3RlZDtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYEZhaWxlZCB0byBzaWduIG1lc3NhZ2U6ICR7bWVzc2FnZVRleHR9YCwgeyBjYXVzZTogZXJyb3IsIGNvZGUsIG1ldGhvZE5hbWU6IFwic2lnbk1lc3NhZ2VcIiB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHR4KSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkLCBtZXRob2ROYW1lOiBcInNpZ25UcmFuc2FjdGlvblwiIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICAgIGNvbnN0IHByZXBhcmVkVHggPSBhd2FpdCB0aGlzLnByZXBhcmVUcmFuc2FjdGlvblJlcXVlc3QodHgpO1xuICAgICAgcmV0dXJuIGF3YWl0IHNpZ25lci5zaWduVHJhbnNhY3Rpb24ocHJlcGFyZWRUeCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5zaG9ydE1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZSB8fCBTdHJpbmcoZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihgRmFpbGVkIHRvIHNpZ24gdHJhbnNhY3Rpb246ICR7bWVzc2FnZX1gLCB7IGNhdXNlOiBlcnJvciwgY29kZTogV2FsbGV0RXJyb3JDb2RlLlNpZ25hdHVyZUZhaWxlZCwgbWV0aG9kTmFtZTogXCJzaWduVHJhbnNhY3Rpb25cIiB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnblR5cGVkRGF0YShkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkLCBtZXRob2ROYW1lOiBcInNpZ25UeXBlZERhdGFcIiB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgIGlmICghbmV0d29yaykge1xuICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiTmV0d29yayBub3QgZm91bmQuXCIsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLk5ldHdvcmtFcnJvciwgbWV0aG9kTmFtZTogXCJzaWduVHlwZWREYXRhXCIgfSk7XG4gICAgICB9XG4gICAgICBFSVA3MTJWYWxpZGF0b3IudmFsaWRhdGVTdHJ1Y3R1cmUoZGF0YSk7XG4gICAgICBFSVA3MTJWYWxpZGF0b3IudmFsaWRhdGVUeXBlcyhkYXRhLnR5cGVzKTtcbiAgICAgIEVJUDcxMlZhbGlkYXRvci52YWxpZGF0ZURvbWFpbihkYXRhLmRvbWFpbiwgbmV0d29yay5jaGFpbklkLnRvU3RyaW5nKCkpO1xuICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduVHlwZWREYXRhKGRhdGEuZG9tYWluLCBkYXRhLnR5cGVzLCBkYXRhLnZhbHVlKTtcbiAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5zaG9ydE1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZSB8fCBTdHJpbmcoZXJyb3IpO1xuICAgICAgbGV0IGNvZGUgPSBXYWxsZXRFcnJvckNvZGUuU2lnbmluZ0ZhaWxlZDtcbiAgICAgIGlmIChtZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ1c2VyIGRlbmllZFwiKSlcbiAgICAgICAgY29kZSA9IFdhbGxldEVycm9yQ29kZS5Vc2VyUmVqZWN0ZWQ7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBGYWlsZWQgdG8gc2lnbiB0eXBlZCBkYXRhOiAke21lc3NhZ2V9YCwgeyBjYXVzZTogZXJyb3IsIGNvZGUsIG1ldGhvZE5hbWU6IFwic2lnblR5cGVkRGF0YVwiIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyB2ZXJpZnlTaWduYXR1cmUobWVzc2FnZSwgc2lnbmF0dXJlLCBhZGRyZXNzKSB7XG4gICAgaWYgKCFldGhlcnMzLmlzQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIkludmFsaWQgYWRkcmVzcyBmb3JtYXQuXCIsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLkludmFsaWRJbnB1dCwgbWV0aG9kTmFtZTogXCJ2ZXJpZnlTaWduYXR1cmVcIiB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBcImRvbWFpblwiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIEVJUDcxMlZhbGlkYXRvci52ZXJpZnlTaWduYXR1cmUobWVzc2FnZSwgc2lnbmF0dXJlLCBhZGRyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlY292ZXJlZEFkZHJlc3MgPSBldGhlcnMzLnZlcmlmeU1lc3NhZ2UobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIHJlY292ZXJlZEFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbJHt0aGlzLm5hbWV9XSBTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIC0tLSBUcmFuc2FjdGlvbiBNZXRob2RzIC0tLVxuICBhc3luYyBnZXROb25jZSh0eXBlID0gXCJwZW5kaW5nXCIpIHtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCB0aGlzLmdldFNpZ25lcigpO1xuICAgIHJldHVybiBzaWduZXIuZ2V0Tm9uY2UodHlwZSk7XG4gIH1cbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgY29uc29sZS5sb2coXCJTRU5ESU5HIFRISVMgVFggRlJPTSBUSEUgQ0xJRU5UIC4uLlwiLCB0eCk7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkLCBtZXRob2ROYW1lOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICAgIGNvbnN0IHR4UmVxdWVzdCA9IGF3YWl0IHRoaXMucHJlcGFyZVRyYW5zYWN0aW9uUmVxdWVzdCh0eCk7XG4gICAgICBjb25zb2xlLmxvZyhcIlNFTkRJTkcgVEhJUyBUWCBGUk9NIHByZXBhcmVUcmFuc2FjdGlvblJlcXVlc3QgLi4uXCIsIHR4UmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHhSZXF1ZXN0KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5oYXNoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3Iuc2hvcnRNZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKTtcbiAgICAgIGxldCBjb2RlID0gV2FsbGV0RXJyb3JDb2RlLlRyYW5zYWN0aW9uRmFpbGVkO1xuICAgICAgaWYgKG1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInVzZXIgZGVuaWVkXCIpKVxuICAgICAgICBjb2RlID0gV2FsbGV0RXJyb3JDb2RlLlVzZXJSZWplY3RlZDtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYEZhaWxlZCB0byBzZW5kIHRyYW5zYWN0aW9uOiAke21lc3NhZ2V9YCwgeyBjYXVzZTogZXJyb3IsIGNvZGUsIG1ldGhvZE5hbWU6IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIldhbGxldCBub3QgY29ubmVjdGVkLlwiLCB7IGNvZGU6IFdhbGxldEVycm9yQ29kZS5XYWxsZXROb3RDb25uZWN0ZWQsIG1ldGhvZE5hbWU6IFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIgfSk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgIHJldHVybiBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3Qob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKVxuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIldhbGxldCBub3QgY29ubmVjdGVkLlwiKTtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMzLkludGVyZmFjZShvcHRpb25zLmFiaSk7XG4gICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy5hcmdzIHx8IFtdKTtcbiAgICBjb25zdCByYXdSZXN1bHQgPSBhd2FpdCBwcm92aWRlci5jYWxsKHtcbiAgICAgIHRvOiBvcHRpb25zLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgICByZXR1cm4gaWZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQob3B0aW9ucy5tZXRob2QsIHJhd1Jlc3VsdCk7XG4gIH1cbiAgYXN5bmMgd3JpdGVDb250cmFjdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkLCBtZXRob2ROYW1lOiBcIndyaXRlQ29udHJhY3RcIiB9KTtcbiAgICB9XG4gICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzMy5JbnRlcmZhY2Uob3B0aW9ucy5hYmkpO1xuICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEob3B0aW9ucy5tZXRob2QsIG9wdGlvbnMuYXJncyB8fCBbXSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICB0bzogb3B0aW9ucy5jb250cmFjdEFkZHJlc3MsXG4gICAgICBkYXRhLFxuICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWU/LnRvU3RyaW5nKCksXG4gICAgICBvcHRpb25zOiBvcHRpb25zLm92ZXJyaWRlc1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuc2VuZFRyYW5zYWN0aW9uKHR4KTtcbiAgfVxuICAvLyAtLS0gR2FzICYgRmVlIE1ldGhvZHMgLS0tXG4gIGFzeW5jIGVzdGltYXRlR2FzKHR4KSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkLCBtZXRob2ROYW1lOiBcImVzdGltYXRlR2FzXCIgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgICBjb25zdCBmcm9tQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgICBjb25zdCB0eFJlcXVlc3QgPSB7XG4gICAgICAgIHRvOiB0eC50byxcbiAgICAgICAgdmFsdWU6IHR4LnZhbHVlID8gdG9XZWkodHgudmFsdWUsIHRoaXMuZGVjaW1hbHMpIDogdm9pZCAwLFxuICAgICAgICBkYXRhOiB0eC5kYXRhID8gdHlwZW9mIHR4LmRhdGEgPT09IFwic3RyaW5nXCIgPyB0eC5kYXRhIDogZXRoZXJzMy5oZXhsaWZ5KHR4LmRhdGEpIDogdm9pZCAwLFxuICAgICAgICBmcm9tOiBmcm9tQWRkcmVzc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdhc0xpbWl0ID0gYXdhaXQgcHJvdmlkZXIuZXN0aW1hdGVHYXModHhSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnYXNMaW1pdCxcbiAgICAgICAgZ2FzUHJpY2U6IGZlZURhdGEuZ2FzUHJpY2U/LnRvU3RyaW5nKCksXG4gICAgICAgIG1heEZlZVBlckdhczogZmVlRGF0YS5tYXhGZWVQZXJHYXM/LnRvU3RyaW5nKCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzPy50b1N0cmluZygpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBGYWlsZWQgdG8gZXN0aW1hdGUgZ2FzOiAke2Vycm9yLm1lc3NhZ2V9YCwge1xuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIGNvZGU6IFdhbGxldEVycm9yQ29kZS5HYXNFc3RpbWF0aW9uRmFpbGVkLFxuICAgICAgICBtZXRob2ROYW1lOiBcImVzdGltYXRlR2FzXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRHYXNQcmljZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIldhbGxldCBub3QgY29ubmVjdGVkLlwiLCB7IGNvZGU6IFdhbGxldEVycm9yQ29kZS5XYWxsZXROb3RDb25uZWN0ZWQsIG1ldGhvZE5hbWU6IFwiZ2V0R2FzUHJpY2VcIiB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmdldEZlZURhdGEoKTtcbiAgICAgIGlmIChmZWVEYXRhLmdhc1ByaWNlKSB7XG4gICAgICAgIHJldHVybiBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgfSBlbHNlIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcykge1xuICAgICAgICByZXR1cm4gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiR2FzIHByaWNlIG5vdCBhdmFpbGFibGUgZnJvbSBhbnkgc291cmNlLlwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihgRmFpbGVkIHRvIGdldCBnYXMgcHJpY2U6ICR7ZXJyb3IubWVzc2FnZX1gLCB7XG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgY29kZTogV2FsbGV0RXJyb3JDb2RlLkdhc0VzdGltYXRpb25GYWlsZWQsXG4gICAgICAgIG1ldGhvZE5hbWU6IFwiZ2V0R2FzUHJpY2VcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIC0tLSBQcm90ZWN0ZWQgSGVscGVyIE1ldGhvZHMgLS0tXG4gIGFzeW5jIGdldFByb3ZpZGVyKCkge1xuICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIlByb3ZpZGVyIG5vdCBzZXQuXCIsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLlByb3ZpZGVyTm90Rm91bmQgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyO1xuICB9XG4gIGFzeW5jIGdldFNpZ25lcigpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSB8fCAhdGhpcy53YWxsZXQpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWxsZXQ7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZVRyYW5zYWN0aW9uUmVxdWVzdCh0eCkge1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgY29uc3QgdHhSZXF1ZXN0ID0ge1xuICAgICAgdG86IHR4LnRvLFxuICAgICAgdmFsdWU6IHR4LnZhbHVlID8gdG9XZWkodHgudmFsdWUsIHRoaXMuZGVjaW1hbHMpIDogdm9pZCAwLFxuICAgICAgZGF0YTogdHguZGF0YSA/IHR5cGVvZiB0eC5kYXRhID09PSBcInN0cmluZ1wiID8gdHguZGF0YSA6IGV0aGVyczMuaGV4bGlmeSh0eC5kYXRhKSA6IHZvaWQgMCxcbiAgICAgIG5vbmNlOiB0eC5vcHRpb25zPy5ub25jZSxcbiAgICAgIGNoYWluSWQ6IHR4Lm9wdGlvbnM/LmNoYWluSWQgPyB0b0JpZ0ludCh0eC5vcHRpb25zLmNoYWluSWQpIDogdm9pZCAwXG4gICAgfTtcbiAgICBpZiAodHgub3B0aW9ucz8uZ2FzTGltaXQpXG4gICAgICB0eFJlcXVlc3QuZ2FzTGltaXQgPSBCaWdJbnQodHgub3B0aW9ucy5nYXNMaW1pdCk7XG4gICAgaWYgKHR4Lm9wdGlvbnM/Lmdhc1ByaWNlKVxuICAgICAgdHhSZXF1ZXN0Lmdhc1ByaWNlID0gQmlnSW50KHR4Lm9wdGlvbnMuZ2FzUHJpY2UpO1xuICAgIGlmICh0eC5vcHRpb25zPy5tYXhGZWVQZXJHYXMpXG4gICAgICB0eFJlcXVlc3QubWF4RmVlUGVyR2FzID0gQmlnSW50KHR4Lm9wdGlvbnMubWF4RmVlUGVyR2FzKTtcbiAgICBpZiAodHgub3B0aW9ucz8ubWF4UHJpb3JpdHlGZWVQZXJHYXMpXG4gICAgICB0eFJlcXVlc3QubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBCaWdJbnQodHgub3B0aW9ucy5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgaWYgKCF0eFJlcXVlc3QuZ2FzTGltaXQpIHtcbiAgICAgIHR4UmVxdWVzdC5nYXNMaW1pdCA9IGF3YWl0IHByb3ZpZGVyLmVzdGltYXRlR2FzKHR4UmVxdWVzdCk7XG4gICAgfVxuICAgIGlmICh0eFJlcXVlc3Qubm9uY2UgPT09IHZvaWQgMCkge1xuICAgICAgdHhSZXF1ZXN0Lm5vbmNlID0gYXdhaXQgc2lnbmVyLmdldE5vbmNlKFwicGVuZGluZ1wiKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXModHhSZXF1ZXN0KS5mb3JFYWNoKChrZXkpID0+IHR4UmVxdWVzdFtrZXldID09PSB2b2lkIDAgJiYgZGVsZXRlIHR4UmVxdWVzdFtrZXldKTtcbiAgICByZXR1cm4gdHhSZXF1ZXN0O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy93YWxsZXQvZGlzdC9hZGFwdGVycy9ldGhlcnMvZXRoZXJzV2FsbGV0LnJlZ2lzdHJhdGlvbi5qc1xuaW1wb3J0IEpvaSBmcm9tIFwiam9pXCI7XG52YXIgZXRoZXJzT3B0aW9uc1NjaGVtYSA9IEpvaS5vYmplY3Qoe1xuICBwcml2YXRlS2V5OiBKb2kuc3RyaW5nKCkucGF0dGVybigvXjB4W2EtZkEtRjAtOV17NjR9JC8pLmRlc2NyaXB0aW9uKFwiUHJpdmF0ZSBrZXkgZm9yIHdhbGxldCAoZ2VuZXJhdGVzIHJhbmRvbSBpZiBub3QgcHJvdmlkZWQpXCIpLFxuICBwcm92aWRlcjogSm9pLm9iamVjdCh7XG4gICAgbmFtZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCkuZGVzY3JpcHRpb24oXCJSZWFsIENoYWluIG5hbWVcIiksXG4gICAgY2hhaW5JZDogSm9pLnN0cmluZygpLnBhdHRlcm4oL14weFswLTlhLWZBLUZdKyQvKS5yZXF1aXJlZCgpLmRlc2NyaXB0aW9uKFwiSGV4IGNoYWluIElEIChlLmcuLCAweGFhMzZhNylcIiksXG4gICAgcnBjVXJsczogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpLnVyaSh7IHNjaGVtZTogW1wiaHR0cHNcIl0gfSkucmVxdWlyZWQoKSkubWluKDEpLnJlcXVpcmVkKCkuZGVzY3JpcHRpb24oXCJBcnJheSBvZiBIVFRQUyBSUEMgVVJMc1wiKSxcbiAgICBkaXNwbGF5TmFtZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCkuZGVzY3JpcHRpb24oXCJXYWxsZXQgZGlzcGxheSBsYWJlbCBmb3IgdGhlIGNoYWluXCIpXG4gIH0pLm9wdGlvbmFsKCkuZGVzY3JpcHRpb24oXCJPcHRpb25hbCBwcm92aWRlciBjb25maWd1cmF0aW9uXCIpLFxuICBtdWx0aUNoYWluUnBjczogSm9pLm9iamVjdCgpLnBhdHRlcm4oSm9pLmFsdGVybmF0aXZlcygpLnRyeShcbiAgICBKb2kuc3RyaW5nKCkucGF0dGVybigvXjB4WzAtOWEtZkEtRl0rJC8pLFxuICAgIC8vIEhleCBjaGFpbiBJRFxuICAgIEpvaS5zdHJpbmcoKS5wYXR0ZXJuKC9eXFxkKyQvKVxuICAgIC8vIERlY2ltYWwgY2hhaW4gSURcbiAgKSwgSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpLnVyaSh7IHNjaGVtZTogW1wiaHR0cHNcIiwgXCJodHRwXCJdIH0pKS5taW4oMSkuZGVzY3JpcHRpb24oXCJBcnJheSBvZiBSUEMgVVJMcyBmb3IgdGhpcyBjaGFpblwiKSkub3B0aW9uYWwoKS5kZXNjcmlwdGlvbihcIk11bHRpLWNoYWluIFJQQyBjb25maWd1cmF0aW9uIC0gbWFwcyBjaGFpbiBJRHMgdG8gUlBDIFVSTCBhcnJheXNcIilcbn0pO1xudmFyIGV0aGVyc1JlcXVpcmVtZW50cyA9IGdldFJlcXVpcmVtZW50cyhldGhlcnNPcHRpb25zU2NoZW1hLCBcImV0aGVyc1wiKTtcbnZhciBldGhlcnNFbnZpcm9ubWVudCA9IGdldEVudmlyb25tZW50cyhcImV0aGVyc1wiLCBbUnVudGltZUVudmlyb25tZW50LlNFUlZFUiwgUnVudGltZUVudmlyb25tZW50LkJST1dTRVJdLCBbXG4gIFwiQnJvd3NlciBlbnZpcm9ubWVudHMgc2hvdWxkIHVzZSBzZWN1cmUga2V5IHNvdXJjZXMgKGhhcmR3YXJlIHdhbGxldHMsIHNlY3VyZSBzdG9yYWdlKVwiLFxuICBcIkNvbnNpZGVyIFdlYjNBdXRoIGFkYXB0ZXIgZm9yIE9BdXRoLWJhc2VkIGJyb3dzZXIgYXV0aGVudGljYXRpb24gZmxvd3NcIlxuXSwgW1xuICBcIlByaXZhdGUga2V5cyBhcmUgcHJvY2Vzc2VkIGR1cmluZyB3YWxsZXQgY3JlYXRpb24gYnV0IG5vdCBzdG9yZWQgcGVyc2lzdGVudGx5XCIsXG4gIFwiU2VydmVyIGVudmlyb25tZW50cyBwcm92aWRlIGJldHRlciBzZWN1cml0eSBmb3Igc2Vuc2l0aXZlIHByaXZhdGUga2V5IG9wZXJhdGlvbnNcIixcbiAgXCJCcm93c2VyIHVzYWdlIHJlcXVpcmVzIHNlY3VyZSBwcml2YXRlIGtleSBoYW5kbGluZyBieSB0aGUgYXBwbGljYXRpb25cIlxuXSk7XG52YXIgZXRoZXJzRmVhdHVyZXMgPSBnZXRGZWF0dXJlcyhFdm1XYWxsZXRBZGFwdGVyKTtcbnZhciBhZGFwdGVyTWV0YWRhdGEgPSB7XG4gIG5hbWU6IFwiZXRoZXJzXCIsXG4gIHZlcnNpb246IFwiMS4wLjBcIixcbiAgbW9kdWxlOiBcIndhbGxldFwiLFxuICBhZGFwdGVyVHlwZTogV2FsbGV0VHlwZS5ldm0sXG4gIGFkYXB0ZXJDbGFzczogRXZtV2FsbGV0QWRhcHRlcixcbiAgY2FwYWJpbGl0aWVzOiBbXG4gICAgQ2FwYWJpbGl0eS5Db3JlV2FsbGV0LFxuICAgIENhcGFiaWxpdHkuRXZlbnRFbWl0dGVyLFxuICAgIENhcGFiaWxpdHkuTWVzc2FnZVNpZ25lcixcbiAgICBDYXBhYmlsaXR5LlRyYW5zYWN0aW9uSGFuZGxlcixcbiAgICBDYXBhYmlsaXR5LlR5cGVkRGF0YVNpZ25lcixcbiAgICBDYXBhYmlsaXR5Lkdhc0VzdGltYXRpb24sXG4gICAgQ2FwYWJpbGl0eS5Ub2tlbk9wZXJhdGlvbnMsXG4gICAgQ2FwYWJpbGl0eS5SUENIYW5kbGVyLFxuICAgIENhcGFiaWxpdHkuVHJhbnNhY3Rpb25TdGF0dXMsXG4gICAgQ2FwYWJpbGl0eS5BZGFwdGVyTGlmZWN5Y2xlXG4gIF0sXG4gIHJlcXVpcmVtZW50czogZXRoZXJzUmVxdWlyZW1lbnRzLFxuICBlbnZpcm9ubWVudDogZXRoZXJzRW52aXJvbm1lbnQsXG4gIGZlYXR1cmVzOiBldGhlcnNGZWF0dXJlc1xufTtcbnJlZ2lzdHJ5LnJlZ2lzdGVyQWRhcHRlcihcIndhbGxldFwiLCBhZGFwdGVyTWV0YWRhdGEpO1xudmFyIGNvbXBhdGliaWxpdHlNYXRyaXggPSBnZXRTdGF0aWNDb21wYXRpYmlsaXR5TWF0cml4KFwid2FsbGV0XCIsIFwiZXRoZXJzXCIsIFwiMS4wLjBcIik7XG5pZiAoY29tcGF0aWJpbGl0eU1hdHJpeCkge1xuICByZWdpc3RyeS5yZWdpc3RlckNvbXBhdGliaWxpdHlNYXRyaXgoXCJ3YWxsZXRcIiwgY29tcGF0aWJpbGl0eU1hdHJpeCk7XG59XG5jb25zb2xlLmxvZyhcIlxcdTI3MDUgRXRoZXJzIHdhbGxldCBhZGFwdGVyIHJlZ2lzdGVyZWQgd2l0aCBzdGF0aWMgY29tcGF0aWJpbGl0eSBtYXRyaXhcIik7XG5jb25zb2xlLmxvZyhcIlxcdXsxRjRDQn0gR2VuZXJhdGVkIHJlcXVpcmVtZW50czpcIiwgZXRoZXJzUmVxdWlyZW1lbnRzKTtcbmNvbnNvbGUubG9nKFwiXFx1ezFGMzBEfSBHZW5lcmF0ZWQgZW52aXJvbm1lbnQ6XCIsIGV0aGVyc0Vudmlyb25tZW50KTtcbmNvbnNvbGUubG9nKFwiXFx1ezFGNTI3fSBHZW5lcmF0ZWQgZmVhdHVyZXM6XCIsIGV0aGVyc0ZlYXR1cmVzLm1hcCgoZikgPT4gZi5uYW1lKSk7XG5cbi8vIHBhY2thZ2VzL3dhbGxldC9kaXN0L2FkYXB0ZXJzL3dlYjNhdXRoL3dlYjNhdXRoV2FsbGV0LmpzXG5pbXBvcnQgeyBXZWIzQXV0aE5vTW9kYWwgfSBmcm9tIFwiQHdlYjNhdXRoL25vLW1vZGFsXCI7XG5pbXBvcnQgeyBXQUxMRVRfQURBUFRFUlMgfSBmcm9tIFwiQHdlYjNhdXRoL2Jhc2VcIjtcbmltcG9ydCB7IEJyb3dzZXJQcm92aWRlciBhcyBCcm93c2VyUHJvdmlkZXIyLCBldGhlcnMgYXMgZXRoZXJzNCB9IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCB7IEF1dGhBZGFwdGVyIH0gZnJvbSBcIkB3ZWIzYXV0aC9hdXRoLWFkYXB0ZXJcIjtcbmltcG9ydCB7IEV0aGVyZXVtUHJpdmF0ZUtleVByb3ZpZGVyIH0gZnJvbSBcIkB3ZWIzYXV0aC9ldGhlcmV1bS1wcm92aWRlclwiO1xudmFyIFdlYjNBdXRoV2FsbGV0QWRhcHRlciA9IGNsYXNzIF9XZWIzQXV0aFdhbGxldEFkYXB0ZXIge1xuICAvLyBORVc6IEFkZCBsb2NhbCBuZXR3b3JrIHN0YXRlXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmFtZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmVyc2lvblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwid2ViM2F1dGhcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbmZpZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5pdGlhbGl6ZWRcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkZWNpbWFsc1wiLCAxOCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImV2ZW50TGlzdGVuZXJzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtdWx0aUNoYWluUnBjc1wiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5ldHdvcmtcIiwgbnVsbCk7XG4gICAgdGhpcy5uYW1lID0gYXJncy5uYW1lO1xuICAgIHRoaXMudmVyc2lvbiA9IGFyZ3MudmVyc2lvbjtcbiAgICB0aGlzLmNvbmZpZyA9IGFyZ3M7XG4gICAgdGhpcy5tdWx0aUNoYWluUnBjcyA9IGFyZ3Mub3B0aW9ucy5tdWx0aUNoYWluUnBjcyB8fCB7fTtcbiAgfVxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGFuZCBpbml0aWFsaXplIGFuIGluc3RhbmNlIG9mIFdlYjNBdXRoV2FsbGV0QWRhcHRlci5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoYXJncykge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IF9XZWIzQXV0aFdhbGxldEFkYXB0ZXIoYXJncyk7XG4gICAgYXdhaXQgaW5zdGFuY2UuaW5pdGlhbGl6ZSgpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICAvLyAtLS0gQ29yZSBMaWZlY3ljbGUgJiBDb25uZWN0aW9uIE1ldGhvZHMgLS0tXG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuY29uZmlnLm9wdGlvbnMud2ViM2F1dGhDb25maWc7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwid2ViM2F1dGhDb25maWcgaXMgbWlzc2luZy5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuTWlzc2luZ0NvbmZpZyB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXlQcm92aWRlciA9IG9wdHMucHJpdmF0ZUtleVByb3ZpZGVyIHx8IG5ldyBFdGhlcmV1bVByaXZhdGVLZXlQcm92aWRlcih7IGNvbmZpZzogeyBjaGFpbkNvbmZpZzogb3B0cy5jaGFpbkNvbmZpZyB9IH0pO1xuICAgICAgdGhpcy53ZWIzYXV0aCA9IG5ldyBXZWIzQXV0aE5vTW9kYWwoe1xuICAgICAgICBjbGllbnRJZDogb3B0cy5jbGllbnRJZCxcbiAgICAgICAgd2ViM0F1dGhOZXR3b3JrOiBvcHRzLndlYjNBdXRoTmV0d29yayxcbiAgICAgICAgY2hhaW5Db25maWc6IG9wdHMuY2hhaW5Db25maWcsXG4gICAgICAgIHByaXZhdGVLZXlQcm92aWRlclxuICAgICAgfSk7XG4gICAgICBjb25zdCBhdXRoQWRhcHRlciA9IG5ldyBBdXRoQWRhcHRlcih7IGFkYXB0ZXJTZXR0aW5nczogeyBsb2dpbkNvbmZpZzogb3B0cy5sb2dpbkNvbmZpZyB9IH0pO1xuICAgICAgdGhpcy53ZWIzYXV0aC5jb25maWd1cmVBZGFwdGVyKGF1dGhBZGFwdGVyKTtcbiAgICAgIGF3YWl0IHRoaXMud2ViM2F1dGguaW5pdCgpO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJXZWIzQXV0aCBpbml0aWFsaXphdGlvbiBmYWlsZWQuXCIsIHsgY2F1c2U6IGVycm9yLCBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW5pdGlhbGl6YXRpb25GYWlsZWQgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMud2ViM2F1dGggJiYgdGhpcy53ZWIzYXV0aC5jb25uZWN0ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMud2ViM2F1dGgubG9nb3V0KCk7XG4gICAgfVxuICAgIHRoaXMud2ViM2F1dGggPSBudWxsO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJkaXNjb25uZWN0XCIsIHZvaWQgMCk7XG4gIH1cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZWQgJiYgISF0aGlzLndlYjNhdXRoPy5jb25uZWN0ZWQ7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplZDtcbiAgfVxuICAvKipcbiAgKiBHZXQgQUxMIGNvbmZpZ3VyZWQgUlBDIFVSTHMgZm9yIEFMTCBjaGFpbnNcbiAgKi9cbiAgZ2V0QWxsQ2hhaW5ScGNzKCkge1xuICAgIHJldHVybiB7IC4uLnRoaXMubXVsdGlDaGFpblJwY3MgfTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIEFMTCBSUEMgY29uZmlndXJhdGlvbnMgYXQgb25jZVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlQWxsQ2hhaW5ScGNzKG11bHRpQ2hhaW5ScGNzKSB7XG4gICAgaWYgKCFtdWx0aUNoYWluUnBjcyB8fCB0eXBlb2YgbXVsdGlDaGFpblJwY3MgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJJbnZhbGlkIFJQQyBjb25maWd1cmF0aW9uIC0gbXVzdCBiZSBhbiBvYmplY3RcIiwge1xuICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuSW52YWxpZElucHV0LFxuICAgICAgICBtZXRob2ROYW1lOiBcInVwZGF0ZUFsbENoYWluUnBjc1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbY2hhaW5JZCwgcnBjVXJsc10gb2YgT2JqZWN0LmVudHJpZXMobXVsdGlDaGFpblJwY3MpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocnBjVXJscykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihgSW52YWxpZCBSUEMgVVJMcyBmb3IgY2hhaW4gJHtjaGFpbklkfSAtIG11c3QgYmUgYXJyYXlgLCB7XG4gICAgICAgICAgY29kZTogV2FsbGV0RXJyb3JDb2RlLkludmFsaWRJbnB1dCxcbiAgICAgICAgICBtZXRob2ROYW1lOiBcInVwZGF0ZUFsbENoYWluUnBjc1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJwY1VybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYEludmFsaWQgUlBDIFVSTHMgZm9yIGNoYWluICR7Y2hhaW5JZH0gLSBhcnJheSBjYW5ub3QgYmUgZW1wdHlgLCB7XG4gICAgICAgICAgY29kZTogV2FsbGV0RXJyb3JDb2RlLkludmFsaWRJbnB1dCxcbiAgICAgICAgICBtZXRob2ROYW1lOiBcInVwZGF0ZUFsbENoYWluUnBjc1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB1cmwgb2YgcnBjVXJscykge1xuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiB8fCAhdXJsLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpICYmICF1cmwuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihgSW52YWxpZCBSUEMgVVJMIGZvciBjaGFpbiAke2NoYWluSWR9OiAke3VybH0gLSBtdXN0IGJlIEhUVFAvSFRUUFMgVVJMYCwge1xuICAgICAgICAgICAgY29kZTogV2FsbGV0RXJyb3JDb2RlLkludmFsaWRJbnB1dCxcbiAgICAgICAgICAgIG1ldGhvZE5hbWU6IFwidXBkYXRlQWxsQ2hhaW5ScGNzXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm11bHRpQ2hhaW5ScGNzID0geyAuLi5tdWx0aUNoYWluUnBjcyB9O1xuICAgIGNvbnNvbGUubG9nKGBbV2ViM0F1dGhXYWxsZXRBZGFwdGVyXSBVcGRhdGVkIGFsbCBjaGFpbiBSUENzIGZvciAke09iamVjdC5rZXlzKG11bHRpQ2hhaW5ScGNzKS5sZW5ndGh9IGNoYWluc2ApO1xuICB9XG4gIGFzeW5jIHNldFByb3ZpZGVyKGNvbmZpZykge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpIHx8ICF0aGlzLndlYjNhdXRoKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiTm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkIH0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDaGFpbklkSGV4ID0gY29uZmlnLmNoYWluSWQuc3RhcnRzV2l0aChcIjB4XCIpID8gY29uZmlnLmNoYWluSWQgOiBgMHgke3BhcnNlSW50KGNvbmZpZy5jaGFpbklkLCAxMCkudG9TdHJpbmcoMTYpfWA7XG4gICAgY29uc3QgY2lkID0gY29uZmlnLmNoYWluSWQ7XG4gICAgY29uc3QgY2lkRGVjaW1hbCA9IHBhcnNlSW50KG5ld0NoYWluSWRIZXgsIDE2KS50b1N0cmluZygpO1xuICAgIGNvbnN0IHByZWZlcnJlZCA9IHRoaXMubXVsdGlDaGFpblJwY3NbY2lkXSB8fCB0aGlzLm11bHRpQ2hhaW5ScGNzW2NpZERlY2ltYWxdIHx8IHRoaXMubXVsdGlDaGFpblJwY3NbbmV3Q2hhaW5JZEhleF0gfHwgW107XG4gICAgY29uc3QgbmV0d29ya0hlbHBlciA9IE5ldHdvcmtIZWxwZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICBhd2FpdCBuZXR3b3JrSGVscGVyLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgbGV0IGZpbmFsQ29uZmlnO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmhhbmNlZENvbmZpZyA9IGF3YWl0IG5ldHdvcmtIZWxwZXIuZ2V0TmV0d29ya0NvbmZpZyhjaWQsIHByZWZlcnJlZCwgZmFsc2UpO1xuICAgICAgZmluYWxDb25maWcgPSBlbmhhbmNlZENvbmZpZyB8fCBjb25maWc7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW1dlYjNBdXRoV2FsbGV0QWRhcHRlcl0gTmV0d29ya0hlbHBlciBmYWlsZWQsIHVzaW5nIG9yaWdpbmFsIGNvbmZpZzpgLCBlcnJvcik7XG4gICAgICBmaW5hbENvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgaWYgKCFmaW5hbENvbmZpZy5ycGNVcmxzIHx8IGZpbmFsQ29uZmlnLnJwY1VybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAocHJlZmVycmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZmluYWxDb25maWcgPSB7IC4uLmZpbmFsQ29uZmlnLCBycGNVcmxzOiBwcmVmZXJyZWQgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYE5vIFJQQyBVUkxzIGF2YWlsYWJsZSBmb3IgY2hhaW4gJHtuZXdDaGFpbklkSGV4fWAsIHtcbiAgICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuQ29ubmVjdGlvbkZhaWxlZCxcbiAgICAgICAgICBtZXRob2ROYW1lOiBcInNldFByb3ZpZGVyXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLndlYjNhdXRoLnN3aXRjaENoYWluKHsgY2hhaW5JZDogbmV3Q2hhaW5JZEhleCB9KTtcbiAgICB9IGNhdGNoIChzd2l0Y2hFcnJvcikge1xuICAgICAgaWYgKHN3aXRjaEVycm9yLmNvZGUgPT09IDQ5MDIgfHwgc3dpdGNoRXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJVbnJlY29nbml6ZWQgY2hhaW4gSURcIikgfHwgc3dpdGNoRXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJDaGFpbiBjb25maWcgaGFzIG5vdCBiZWVuIGFkZGVkXCIpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtXZWIzQXV0aFdhbGxldEFkYXB0ZXJdIEFkZGluZyBjaGFpbiAke25ld0NoYWluSWRIZXh9IHRvIFdlYjNBdXRoYCk7XG4gICAgICAgICAgY29uc3QgY2hhaW5Ub0FkZCA9IHtcbiAgICAgICAgICAgIGNoYWluSWQ6IG5ld0NoYWluSWRIZXgsXG4gICAgICAgICAgICBjaGFpbk5hbWVzcGFjZTogXCJlaXAxNTVcIixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBmaW5hbENvbmZpZy5kaXNwbGF5TmFtZSB8fCBmaW5hbENvbmZpZy5uYW1lLFxuICAgICAgICAgICAgcnBjVGFyZ2V0OiBmaW5hbENvbmZpZy5ycGNVcmxzWzBdLFxuICAgICAgICAgICAgLy8g4pyFIFVzZSB0aGUgcHJvcGVyIFJQQyBVUkxcbiAgICAgICAgICAgIGJsb2NrRXhwbG9yZXJVcmw6IGZpbmFsQ29uZmlnLmJsb2NrRXhwbG9yZXJVcmwsXG4gICAgICAgICAgICB0aWNrZXI6IGZpbmFsQ29uZmlnLnRpY2tlciB8fCBcIkVUSFwiLFxuICAgICAgICAgICAgdGlja2VyTmFtZTogZmluYWxDb25maWcudGlja2VyTmFtZSB8fCBcIkV0aGVyZXVtXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGF3YWl0IHRoaXMud2ViM2F1dGguYWRkQ2hhaW4oY2hhaW5Ub0FkZCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtXZWIzQXV0aFdhbGxldEFkYXB0ZXJdIFxcdTI3MDUgU3VjY2Vzc2Z1bGx5IGFkZGVkIGNoYWluICR7bmV3Q2hhaW5JZEhleH1gKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLndlYjNhdXRoLnN3aXRjaENoYWluKHsgY2hhaW5JZDogbmV3Q2hhaW5JZEhleCB9KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1dlYjNBdXRoV2FsbGV0QWRhcHRlcl0gXFx1MjcwNSBTdWNjZXNzZnVsbHkgc3dpdGNoZWQgdG8gY2hhaW4gJHtuZXdDaGFpbklkSGV4fWApO1xuICAgICAgICB9IGNhdGNoIChhZGRFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYEZhaWxlZCB0byBhZGQgb3Igc3dpdGNoIHRvIGNoYWluICR7bmV3Q2hhaW5JZEhleH06ICR7YWRkRXJyb3IubWVzc2FnZX1gLCB7XG4gICAgICAgICAgICBjYXVzZTogYWRkRXJyb3IsXG4gICAgICAgICAgICBjb2RlOiBXYWxsZXRFcnJvckNvZGUuQ29ubmVjdGlvbkZhaWxlZCxcbiAgICAgICAgICAgIG1ldGhvZE5hbWU6IFwic2V0UHJvdmlkZXJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBGYWlsZWQgdG8gc3dpdGNoIGNoYWluICR7bmV3Q2hhaW5JZEhleH06ICR7c3dpdGNoRXJyb3IubWVzc2FnZX1gLCB7XG4gICAgICAgICAgY2F1c2U6IHN3aXRjaEVycm9yLFxuICAgICAgICAgIGNvZGU6IFdhbGxldEVycm9yQ29kZS5Db25uZWN0aW9uRmFpbGVkLFxuICAgICAgICAgIG1ldGhvZE5hbWU6IFwic2V0UHJvdmlkZXJcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5uZXR3b3JrID0gbnVsbDtcbiAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgdGhpcy5uZXR3b3JrID0gbmV0d29yaztcbiAgICB0aGlzLmRlY2ltYWxzID0gbmV0d29yay5kZWNpbWFscyB8fCAxODtcbiAgICB0aGlzLmVtaXRFdmVudChcImNoYWluQ2hhbmdlZFwiLCBuZXR3b3JrLmNoYWluSWQpO1xuICB9XG4gIC8vIC0tLSBFdmVudCBIYW5kbGluZyAtLS1cbiAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyhldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2V0KGV2ZW50LCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZXZlbnQpLmFkZChjYWxsYmFjayk7XG4gIH1cbiAgb2ZmKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyhldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50KS5kZWxldGUoY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBlbWl0RXZlbnQoZXZlbnROYW1lLCBwYXlsb2FkKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICBpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5zaXplID4gMCkge1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbGJhY2socGF5bG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7dGhpcy5uYW1lfV0gRXJyb3IgaW4gJHtldmVudE5hbWV9IGV2ZW50IGhhbmRsZXI6YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy8gLS0tIFdhbGxldCBJbmZvcm1hdGlvbiAmIFN0YXRlIC0tLVxuICBhc3luYyBnZXRBY2NvdW50cygpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgY29uc3QgbG9naW5Qcm92aWRlciA9IE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLm9wdGlvbnMud2ViM2F1dGhDb25maWcubG9naW5Db25maWcpWzBdO1xuICAgICAgaWYgKCFsb2dpblByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJObyBsb2dpbiBwcm92aWRlcnMgY29uZmlndXJlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuTWlzc2luZ0NvbmZpZyB9KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMud2ViM2F1dGg/LmNvbm5lY3RUbyhXQUxMRVRfQURBUFRFUlMuQVVUSCwgeyBsb2dpblByb3ZpZGVyIH0pO1xuICAgICAgaWYgKCF0aGlzLndlYjNhdXRoPy5jb25uZWN0ZWQgfHwgIXRoaXMud2ViM2F1dGgucHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIFdlYjNBdXRoLlwiLCB7IGNvZGU6IFdhbGxldEVycm9yQ29kZS5Db25uZWN0aW9uRmFpbGVkIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgdGhpcy5uZXR3b3JrID0gbmV0d29yaztcbiAgICAgIHRoaXMuZW1pdEV2ZW50KFwiY29ubmVjdFwiLCB7IGNoYWluSWQ6IG5ldHdvcmsuY2hhaW5JZCB9KTtcbiAgICB9XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLndlYjNhdXRoPy5wcm92aWRlcj8ucmVxdWVzdCh7IG1ldGhvZDogXCJldGhfYWNjb3VudHNcIiB9KTtcbiAgICB0aGlzLmVtaXRFdmVudChcImFjY291bnRzQ2hhbmdlZFwiLCBhY2NvdW50cyk7XG4gICAgcmV0dXJuIGFjY291bnRzO1xuICB9XG4gIGFzeW5jIGdldE5ldHdvcmsoKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMud2ViM2F1dGg/LnByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiTm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZXR3b3JrKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXR3b3JrO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBgMHgke25ldHdvcmsuY2hhaW5JZC50b1N0cmluZygxNil9YDtcbiAgICBjb25zdCBuZXR3b3JrSGVscGVyID0gTmV0d29ya0hlbHBlci5nZXRJbnN0YW5jZSgpO1xuICAgIGF3YWl0IG5ldHdvcmtIZWxwZXIuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBjb25maWcgPSBhd2FpdCBuZXR3b3JrSGVscGVyLmdldE5ldHdvcmtDb25maWcoY2hhaW5JZCk7XG4gICAgY29uc3QgZmluYWxDb25maWcgPSBjb25maWcgPz8ge1xuICAgICAgY2hhaW5JZCxcbiAgICAgIG5hbWU6IG5ldHdvcmsubmFtZSxcbiAgICAgIGRpc3BsYXlOYW1lOiBuZXR3b3JrLm5hbWUsXG4gICAgICBycGNVcmxzOiBbcHJvdmlkZXI/LmNvbm5lY3Rpb24/LnVybCB8fCBcIlwiXS5maWx0ZXIoQm9vbGVhbiksXG4gICAgICBkZWNpbWFsczogMTgsXG4gICAgICB0aWNrZXI6IFwiRVRIXCIsXG4gICAgICB0aWNrZXJOYW1lOiBcIkV0aGVyZXVtXCJcbiAgICB9O1xuICAgIHRoaXMubmV0d29yayA9IGZpbmFsQ29uZmlnO1xuICAgIHJldHVybiBmaW5hbENvbmZpZztcbiAgfVxuICBhc3luYyBnZXRCYWxhbmNlKGFjY291bnQpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIk5vdCBjb25uZWN0ZWQuXCIsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLldhbGxldE5vdENvbm5lY3RlZCwgbWV0aG9kTmFtZTogXCJnZXRCYWxhbmNlXCIgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBhY2NvdW50IHx8IChhd2FpdCB0aGlzLmdldEFjY291bnRzKCkpWzBdO1xuICAgICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJObyBhY2NvdW50IGF2YWlsYWJsZS5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuQWNjb3VudFVuYXZhaWxhYmxlLCBtZXRob2ROYW1lOiBcImdldEJhbGFuY2VcIiB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhbGFuY2VXZWkgPSBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKGFkZHJlc3MpO1xuICAgICAgY29uc3QgbmV0d29ya0NvbmZpZyA9IGF3YWl0IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgdGhpcy5kZWNpbWFscyA9IG5ldHdvcmtDb25maWcuZGVjaW1hbHMgfHwgMTg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbW91bnQ6IGJhbGFuY2VXZWkudG9TdHJpbmcoKSxcbiAgICAgICAgZGVjaW1hbHM6IHRoaXMuZGVjaW1hbHMsXG4gICAgICAgIHN5bWJvbDogbmV0d29ya0NvbmZpZy50aWNrZXIgfHwgXCJFVEhcIixcbiAgICAgICAgZm9ybWF0dGVkQW1vdW50OiBldGhlcnM0LmZvcm1hdFVuaXRzKGJhbGFuY2VXZWksIHRoaXMuZGVjaW1hbHMpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBGYWlsZWQgdG8gZ2V0IGJhbGFuY2U6ICR7ZXJyb3IubWVzc2FnZX1gLCB7IGNhdXNlOiBlcnJvciwgY29kZTogV2FsbGV0RXJyb3JDb2RlLk5ldHdvcmtFcnJvciwgbWV0aG9kTmFtZTogXCJnZXRCYWxhbmNlXCIgfSk7XG4gICAgfVxuICB9XG4gIC8vIC0tLSBTaWduaW5nIE1ldGhvZHMgLS0tXG4gIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIldhbGxldCBub3QgY29ubmVjdGVkLlwiLCB7IGNvZGU6IFdhbGxldEVycm9yQ29kZS5XYWxsZXROb3RDb25uZWN0ZWQsIG1ldGhvZE5hbWU6IFwic2lnbk1lc3NhZ2VcIiB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgICByZXR1cm4gYXdhaXQgc2lnbmVyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBtZXNzYWdlVGV4dCA9IGVycm9yLnNob3J0TWVzc2FnZSB8fCBlcnJvci5tZXNzYWdlIHx8IFN0cmluZyhlcnJvcik7XG4gICAgICBsZXQgY29kZSA9IFdhbGxldEVycm9yQ29kZS5TaWduaW5nRmFpbGVkO1xuICAgICAgaWYgKG1lc3NhZ2VUZXh0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ1c2VyIGRlbmllZFwiKSlcbiAgICAgICAgY29kZSA9IFdhbGxldEVycm9yQ29kZS5Vc2VyUmVqZWN0ZWQ7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBGYWlsZWQgdG8gc2lnbiBtZXNzYWdlOiAke21lc3NhZ2VUZXh0fWAsIHsgY2F1c2U6IGVycm9yLCBjb2RlLCBtZXRob2ROYW1lOiBcInNpZ25NZXNzYWdlXCIgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWQuXCIsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLldhbGxldE5vdENvbm5lY3RlZCwgbWV0aG9kTmFtZTogXCJzaWduVHJhbnNhY3Rpb25cIiB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgICBjb25zdCBwcmVwYXJlZFR4ID0gYXdhaXQgdGhpcy5wcmVwYXJlVHJhbnNhY3Rpb25SZXF1ZXN0KHR4KTtcbiAgICAgIHJldHVybiBhd2FpdCBzaWduZXIuc2lnblRyYW5zYWN0aW9uKHByZXBhcmVkVHgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3Iuc2hvcnRNZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYEZhaWxlZCB0byBzaWduIHRyYW5zYWN0aW9uOiAke21lc3NhZ2V9YCwgeyBjYXVzZTogZXJyb3IsIGNvZGU6IFdhbGxldEVycm9yQ29kZS5TaWduYXR1cmVGYWlsZWQsIG1ldGhvZE5hbWU6IFwic2lnblRyYW5zYWN0aW9uXCIgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNpZ25UeXBlZERhdGEoZGF0YSkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiV2FsbGV0IG5vdCBjb25uZWN0ZWQuXCIsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLldhbGxldE5vdENvbm5lY3RlZCwgbWV0aG9kTmFtZTogXCJzaWduVHlwZWREYXRhXCIgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBFSVA3MTJWYWxpZGF0b3IudmFsaWRhdGVTdHJ1Y3R1cmUoZGF0YSk7XG4gICAgICBFSVA3MTJWYWxpZGF0b3IudmFsaWRhdGVUeXBlcyhkYXRhLnR5cGVzKTtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgIEVJUDcxMlZhbGlkYXRvci52YWxpZGF0ZURvbWFpbihkYXRhLmRvbWFpbiwgbmV0d29yay5jaGFpbklkLnRvU3RyaW5nKCkpO1xuICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduVHlwZWREYXRhKGRhdGEuZG9tYWluLCBkYXRhLnR5cGVzLCBkYXRhLnZhbHVlKTtcbiAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFkYXB0ZXJFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5zaG9ydE1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZSB8fCBTdHJpbmcoZXJyb3IpO1xuICAgICAgbGV0IGNvZGUgPSBXYWxsZXRFcnJvckNvZGUuU2lnbmluZ0ZhaWxlZDtcbiAgICAgIGlmIChtZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ1c2VyIGRlbmllZFwiKSlcbiAgICAgICAgY29kZSA9IFdhbGxldEVycm9yQ29kZS5Vc2VyUmVqZWN0ZWQ7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBGYWlsZWQgdG8gc2lnbiB0eXBlZCBkYXRhOiAke21lc3NhZ2V9YCwgeyBjYXVzZTogZXJyb3IsIGNvZGUsIG1ldGhvZE5hbWU6IFwic2lnblR5cGVkRGF0YVwiIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyB2ZXJpZnlTaWduYXR1cmUobWVzc2FnZSwgc2lnbmF0dXJlLCBhZGRyZXNzKSB7XG4gICAgaWYgKCFldGhlcnM0LmlzQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIkludmFsaWQgYWRkcmVzcyBmb3JtYXQuXCIsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLkludmFsaWRJbnB1dCwgbWV0aG9kTmFtZTogXCJ2ZXJpZnlTaWduYXR1cmVcIiB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBcImRvbWFpblwiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIEVJUDcxMlZhbGlkYXRvci52ZXJpZnlTaWduYXR1cmUobWVzc2FnZSwgc2lnbmF0dXJlLCBhZGRyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlY292ZXJlZEFkZHJlc3MgPSBldGhlcnM0LnZlcmlmeU1lc3NhZ2UobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIHJlY292ZXJlZEFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbJHt0aGlzLm5hbWV9XSBTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIC0tLSBUcmFuc2FjdGlvbiBNZXRob2RzIC0tLVxuICBhc3luYyBnZXROb25jZSh0eXBlID0gXCJwZW5kaW5nXCIpIHtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCB0aGlzLmdldFNpZ25lcigpO1xuICAgIHJldHVybiBzaWduZXIuZ2V0Tm9uY2UodHlwZSk7XG4gIH1cbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgY29uc29sZS5sb2coXCJTRU5ESU5HIFRISVMgVFggRlJPTSBUSEUgQ0xJRU5UIC4uLlwiLCB0eCk7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkLCBtZXRob2ROYW1lOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICAgIGNvbnN0IHR4UmVxdWVzdCA9IGF3YWl0IHRoaXMucHJlcGFyZVRyYW5zYWN0aW9uUmVxdWVzdCh0eCk7XG4gICAgICBjb25zb2xlLmxvZyhcIlNFTkRJTkcgVEhJUyBUWCBGUk9NIHByZXBhcmVUcmFuc2FjdGlvblJlcXVlc3QgLi4uXCIsIHR4UmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHhSZXF1ZXN0KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5oYXNoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3Iuc2hvcnRNZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKTtcbiAgICAgIGxldCBjb2RlID0gV2FsbGV0RXJyb3JDb2RlLlRyYW5zYWN0aW9uRmFpbGVkO1xuICAgICAgaWYgKG1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInVzZXIgZGVuaWVkXCIpKVxuICAgICAgICBjb2RlID0gV2FsbGV0RXJyb3JDb2RlLlVzZXJSZWplY3RlZDtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYEZhaWxlZCB0byBzZW5kIHRyYW5zYWN0aW9uOiAke21lc3NhZ2V9YCwgeyBjYXVzZTogZXJyb3IsIGNvZGUsIG1ldGhvZE5hbWU6IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIldhbGxldCBub3QgY29ubmVjdGVkLlwiLCB7IGNvZGU6IFdhbGxldEVycm9yQ29kZS5XYWxsZXROb3RDb25uZWN0ZWQsIG1ldGhvZE5hbWU6IFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIgfSk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgIHJldHVybiBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3Qob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKVxuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIldhbGxldCBub3QgY29ubmVjdGVkLlwiKTtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnM0LkludGVyZmFjZShvcHRpb25zLmFiaSk7XG4gICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy5hcmdzIHx8IFtdKTtcbiAgICBjb25zdCByYXdSZXN1bHQgPSBhd2FpdCBwcm92aWRlci5jYWxsKHtcbiAgICAgIHRvOiBvcHRpb25zLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgICByZXR1cm4gaWZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQob3B0aW9ucy5tZXRob2QsIHJhd1Jlc3VsdCk7XG4gIH1cbiAgYXN5bmMgd3JpdGVDb250cmFjdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkLCBtZXRob2ROYW1lOiBcIndyaXRlQ29udHJhY3RcIiB9KTtcbiAgICB9XG4gICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzNC5JbnRlcmZhY2Uob3B0aW9ucy5hYmkpO1xuICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEob3B0aW9ucy5tZXRob2QsIG9wdGlvbnMuYXJncyB8fCBbXSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICB0bzogb3B0aW9ucy5jb250cmFjdEFkZHJlc3MsXG4gICAgICBkYXRhLFxuICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWU/LnRvU3RyaW5nKCksXG4gICAgICBvcHRpb25zOiBvcHRpb25zLm92ZXJyaWRlc1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuc2VuZFRyYW5zYWN0aW9uKHR4KTtcbiAgfVxuICAvLyAtLS0gR2FzICYgRmVlIE1ldGhvZHMgLS0tXG4gIGFzeW5jIGVzdGltYXRlR2FzKHR4KSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJXYWxsZXQgbm90IGNvbm5lY3RlZC5cIiwgeyBjb2RlOiBXYWxsZXRFcnJvckNvZGUuV2FsbGV0Tm90Q29ubmVjdGVkLCBtZXRob2ROYW1lOiBcImVzdGltYXRlR2FzXCIgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgICBjb25zdCBmcm9tQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgICBjb25zdCB0eFJlcXVlc3QgPSB7XG4gICAgICAgIHRvOiB0eC50byxcbiAgICAgICAgdmFsdWU6IHR4LnZhbHVlID8gdG9XZWkodHgudmFsdWUsIHRoaXMuZGVjaW1hbHMpIDogdm9pZCAwLFxuICAgICAgICBkYXRhOiB0eC5kYXRhID8gdHlwZW9mIHR4LmRhdGEgPT09IFwic3RyaW5nXCIgPyB0eC5kYXRhIDogZXRoZXJzNC5oZXhsaWZ5KHR4LmRhdGEpIDogdm9pZCAwLFxuICAgICAgICBmcm9tOiBmcm9tQWRkcmVzc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdhc0xpbWl0ID0gYXdhaXQgcHJvdmlkZXIuZXN0aW1hdGVHYXModHhSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnYXNMaW1pdCxcbiAgICAgICAgZ2FzUHJpY2U6IGZlZURhdGEuZ2FzUHJpY2U/LnRvU3RyaW5nKCksXG4gICAgICAgIG1heEZlZVBlckdhczogZmVlRGF0YS5tYXhGZWVQZXJHYXM/LnRvU3RyaW5nKCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzPy50b1N0cmluZygpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBGYWlsZWQgdG8gZXN0aW1hdGUgZ2FzOiAke2Vycm9yLm1lc3NhZ2V9YCwge1xuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIGNvZGU6IFdhbGxldEVycm9yQ29kZS5HYXNFc3RpbWF0aW9uRmFpbGVkLFxuICAgICAgICBtZXRob2ROYW1lOiBcImVzdGltYXRlR2FzXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRHYXNQcmljZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIldhbGxldCBub3QgY29ubmVjdGVkLlwiLCB7IGNvZGU6IFdhbGxldEVycm9yQ29kZS5XYWxsZXROb3RDb25uZWN0ZWQsIG1ldGhvZE5hbWU6IFwiZ2V0R2FzUHJpY2VcIiB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmdldEZlZURhdGEoKTtcbiAgICAgIGlmIChmZWVEYXRhLmdhc1ByaWNlKSB7XG4gICAgICAgIHJldHVybiBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgfSBlbHNlIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcykge1xuICAgICAgICByZXR1cm4gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKFwiR2FzIHByaWNlIG5vdCBhdmFpbGFibGUgZnJvbSBhbnkgc291cmNlLlwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihgRmFpbGVkIHRvIGdldCBnYXMgcHJpY2U6ICR7ZXJyb3IubWVzc2FnZX1gLCB7XG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgY29kZTogV2FsbGV0RXJyb3JDb2RlLkdhc0VzdGltYXRpb25GYWlsZWQsXG4gICAgICAgIG1ldGhvZE5hbWU6IFwiZ2V0R2FzUHJpY2VcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIC0tLSBQcm90ZWN0ZWQgSGVscGVyIE1ldGhvZHMgLS0tXG4gIGFzeW5jIGdldFByb3ZpZGVyKCkge1xuICAgIGlmICghdGhpcy53ZWIzYXV0aD8ucHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoXCJQcm92aWRlciBub3QgYXZhaWxhYmxlIGZyb20gV2ViM0F1dGguXCIsIHsgY29kZTogV2FsbGV0RXJyb3JDb2RlLlByb3ZpZGVyTm90Rm91bmQgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnJvd3NlclByb3ZpZGVyMih0aGlzLndlYjNhdXRoLnByb3ZpZGVyKTtcbiAgfVxuICBhc3luYyBnZXRTaWduZXIoKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzKCk7XG4gICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihcIk5vIGFjY291bnRzIGF2YWlsYWJsZSB0byBjcmVhdGUgc2lnbmVyLlwiLCB7IGNvZGU6IFdhbGxldEVycm9yQ29kZS5BY2NvdW50VW5hdmFpbGFibGUgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlci5nZXRTaWduZXIoYWNjb3VudHNbMF0pO1xuICB9XG4gIGFzeW5jIHByZXBhcmVUcmFuc2FjdGlvblJlcXVlc3QodHgpIHtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCB0aGlzLmdldFNpZ25lcigpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgIGNvbnN0IHR4UmVxdWVzdCA9IHtcbiAgICAgIHRvOiB0eC50byxcbiAgICAgIHZhbHVlOiB0eC52YWx1ZSA/IHRvV2VpKHR4LnZhbHVlLCB0aGlzLmRlY2ltYWxzKSA6IHZvaWQgMCxcbiAgICAgIGRhdGE6IHR4LmRhdGEgPyB0eXBlb2YgdHguZGF0YSA9PT0gXCJzdHJpbmdcIiA/IHR4LmRhdGEgOiBldGhlcnM0LmhleGxpZnkodHguZGF0YSkgOiB2b2lkIDAsXG4gICAgICBub25jZTogdHgub3B0aW9ucz8ubm9uY2UsXG4gICAgICBjaGFpbklkOiB0eC5vcHRpb25zPy5jaGFpbklkID8gdG9CaWdJbnQodHgub3B0aW9ucy5jaGFpbklkKSA6IHZvaWQgMFxuICAgIH07XG4gICAgaWYgKHR4Lm9wdGlvbnM/Lmdhc0xpbWl0KVxuICAgICAgdHhSZXF1ZXN0Lmdhc0xpbWl0ID0gQmlnSW50KHR4Lm9wdGlvbnMuZ2FzTGltaXQpO1xuICAgIGlmICh0eC5vcHRpb25zPy5nYXNQcmljZSlcbiAgICAgIHR4UmVxdWVzdC5nYXNQcmljZSA9IEJpZ0ludCh0eC5vcHRpb25zLmdhc1ByaWNlKTtcbiAgICBpZiAodHgub3B0aW9ucz8ubWF4RmVlUGVyR2FzKVxuICAgICAgdHhSZXF1ZXN0Lm1heEZlZVBlckdhcyA9IEJpZ0ludCh0eC5vcHRpb25zLm1heEZlZVBlckdhcyk7XG4gICAgaWYgKHR4Lm9wdGlvbnM/Lm1heFByaW9yaXR5RmVlUGVyR2FzKVxuICAgICAgdHhSZXF1ZXN0Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnSW50KHR4Lm9wdGlvbnMubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGlmICghdHhSZXF1ZXN0Lmdhc0xpbWl0KSB7XG4gICAgICB0eFJlcXVlc3QuZ2FzTGltaXQgPSBhd2FpdCBwcm92aWRlci5lc3RpbWF0ZUdhcyh0eFJlcXVlc3QpO1xuICAgIH1cbiAgICBpZiAodHhSZXF1ZXN0Lm5vbmNlID09PSB2b2lkIDApIHtcbiAgICAgIHR4UmVxdWVzdC5ub25jZSA9IGF3YWl0IHNpZ25lci5nZXROb25jZShcInBlbmRpbmdcIik7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHR4UmVxdWVzdCkuZm9yRWFjaCgoa2V5KSA9PiB0eFJlcXVlc3Rba2V5XSA9PT0gdm9pZCAwICYmIGRlbGV0ZSB0eFJlcXVlc3Rba2V5XSk7XG4gICAgcmV0dXJuIHR4UmVxdWVzdDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvd2FsbGV0L2Rpc3QvYWRhcHRlcnMvd2ViM2F1dGgvd2ViM2F1dGhXYWxsZXQucmVnaXN0cmF0aW9uLmpzXG5pbXBvcnQgSm9pMiBmcm9tIFwiam9pXCI7XG52YXIgd2ViM0F1dGhPcHRpb25zU2NoZW1hID0gSm9pMi5vYmplY3Qoe1xuICB3ZWIzYXV0aENvbmZpZzogSm9pMi5vYmplY3Qoe1xuICAgIGNsaWVudElkOiBKb2kyLnN0cmluZygpLnJlcXVpcmVkKCkuZGVzY3JpcHRpb24oXCJZb3VyIFdlYjNBdXRoIENsaWVudCBJRFwiKSxcbiAgICB3ZWIzQXV0aE5ldHdvcms6IEpvaTIuc3RyaW5nKCkudmFsaWQoXCJzYXBwaGlyZV9tYWlubmV0XCIsIFwic2FwcGhpcmVfZGV2bmV0XCIsIFwidGVzdG5ldFwiKS5yZXF1aXJlZCgpLmRlc2NyaXB0aW9uKFwiV2ViM0F1dGggTmV0d29yayBlbnZpcm9ubWVudFwiKSxcbiAgICBjaGFpbkNvbmZpZzogSm9pMi5vYmplY3Qoe1xuICAgICAgY2hhaW5OYW1lc3BhY2U6IEpvaTIuc3RyaW5nKCkuZGVmYXVsdChcImVpcDE1NVwiKSxcbiAgICAgIGNoYWluSWQ6IEpvaTIuc3RyaW5nKCkucmVxdWlyZWQoKS5kZXNjcmlwdGlvbihcIkJsb2NrY2hhaW4gY2hhaW4gSUQgKGhleGFkZWNpbWFsKVwiKSxcbiAgICAgIHJwY1RhcmdldDogSm9pMi5zdHJpbmcoKS51cmkoKS5yZXF1aXJlZCgpLmRlc2NyaXB0aW9uKFwiUlBDIGVuZHBvaW50IFVSTFwiKSxcbiAgICAgIGRpc3BsYXlOYW1lOiBKb2kyLnN0cmluZygpLnJlcXVpcmVkKCkuZGVzY3JpcHRpb24oXCJOZXR3b3JrIGRpc3BsYXkgbmFtZVwiKSxcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6IEpvaTIuc3RyaW5nKCkudXJpKCkucmVxdWlyZWQoKS5kZXNjcmlwdGlvbihcIkJsb2NrIGV4cGxvcmVyIFVSTFwiKSxcbiAgICAgIHRpY2tlcjogSm9pMi5zdHJpbmcoKS5yZXF1aXJlZCgpLmRlc2NyaXB0aW9uKFwiTmF0aXZlIHRva2VuIHRpY2tlciAoZS5nLiwgRVRIKVwiKSxcbiAgICAgIHRpY2tlck5hbWU6IEpvaTIuc3RyaW5nKCkucmVxdWlyZWQoKS5kZXNjcmlwdGlvbihcIk5hdGl2ZSB0b2tlbiBuYW1lIChlLmcuLCBFdGhlcmV1bSlcIilcbiAgICB9KS5yZXF1aXJlZCgpLmRlc2NyaXB0aW9uKFwiQmxvY2tjaGFpbiBjb25maWd1cmF0aW9uXCIpLFxuICAgIGxvZ2luQ29uZmlnOiBKb2kyLm9iamVjdCgpLnJlcXVpcmVkKCkuZGVzY3JpcHRpb24oXCJPQXV0aCBwcm92aWRlciBjb25maWd1cmF0aW9uXCIpLFxuICAgIHByaXZhdGVLZXlQcm92aWRlcjogSm9pMi5hbnkoKS5vcHRpb25hbCgpLmRlc2NyaXB0aW9uKFwiT3B0aW9uYWwgcHJpdmF0ZSBrZXkgcHJvdmlkZXJcIilcbiAgfSkucmVxdWlyZWQoKS5kZXNjcmlwdGlvbihcIldlYjNBdXRoIGNvbmZpZ3VyYXRpb24gb2JqZWN0XCIpLFxuICAvLyDinIUgTkVXOiBBZGQgbXVsdGlDaGFpblJwY3Mgb3B0aW9uIChzYW1lIGFzIGV0aGVycylcbiAgbXVsdGlDaGFpblJwY3M6IEpvaTIub2JqZWN0KCkucGF0dGVybihKb2kyLmFsdGVybmF0aXZlcygpLnRyeShcbiAgICBKb2kyLnN0cmluZygpLnBhdHRlcm4oL14weFswLTlhLWZBLUZdKyQvKSxcbiAgICAvLyBIZXggY2hhaW4gSURcbiAgICBKb2kyLnN0cmluZygpLnBhdHRlcm4oL15cXGQrJC8pXG4gICAgLy8gRGVjaW1hbCBjaGFpbiBJRFxuICApLCBKb2kyLmFycmF5KCkuaXRlbXMoSm9pMi5zdHJpbmcoKS51cmkoeyBzY2hlbWU6IFtcImh0dHBzXCIsIFwiaHR0cFwiXSB9KSkubWluKDEpLmRlc2NyaXB0aW9uKFwiQXJyYXkgb2YgUlBDIFVSTHMgZm9yIHRoaXMgY2hhaW5cIikpLm9wdGlvbmFsKCkuZGVzY3JpcHRpb24oXCJNdWx0aS1jaGFpbiBSUEMgY29uZmlndXJhdGlvbiAtIG1hcHMgY2hhaW4gSURzIHRvIFJQQyBVUkwgYXJyYXlzXCIpXG59KTtcbnZhciB3ZWIzYXV0aFJlcXVpcmVtZW50cyA9IGdldFJlcXVpcmVtZW50cyh3ZWIzQXV0aE9wdGlvbnNTY2hlbWEsIFwid2ViM2F1dGhcIik7XG52YXIgd2ViM2F1dGhFbnZpcm9ubWVudCA9IGdldEVudmlyb25tZW50cyhcbiAgXCJ3ZWIzYXV0aFwiLFxuICBbUnVudGltZUVudmlyb25tZW50LkJST1dTRVJdLFxuICAvLyBCcm93c2VyIG9ubHlcbiAgW1xuICAgIFwiUmVxdWlyZXMgYnJvd3NlciBlbnZpcm9ubWVudCB3aXRoIFdlYjNBdXRoIFNES1wiLFxuICAgIFwiQ2Fubm90IGJlIHVzZWQgaW4gTm9kZS5qcyBzZXJ2ZXIgZW52aXJvbm1lbnRzXCIsXG4gICAgXCJSZXF1aXJlcyB1c2VyIGludGVyYWN0aW9uIGZvciBPQXV0aCBmbG93c1wiXG4gIF0sXG4gIFtcbiAgICBcIldlYjNBdXRoIGhhbmRsZXMgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiBzZWN1cmVseVwiLFxuICAgIFwiT0F1dGgtYmFzZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXMgYmV0dGVyIFVYXCIsXG4gICAgXCJQcml2YXRlIGtleXMgcmVjb25zdHJ1Y3RlZCBpbiBtZW1vcnkgb25seVwiXG4gIF1cbik7XG52YXIgd2ViM2F1dGhGZWF0dXJlcyA9IGdldEZlYXR1cmVzKFdlYjNBdXRoV2FsbGV0QWRhcHRlcik7XG52YXIgYWRhcHRlck1ldGFkYXRhMiA9IHtcbiAgbmFtZTogXCJ3ZWIzYXV0aFwiLFxuICB2ZXJzaW9uOiBcIjEuMC4wXCIsXG4gIG1vZHVsZTogXCJ3YWxsZXRcIixcbiAgYWRhcHRlclR5cGU6IFdhbGxldFR5cGUud2ViM2F1dGgsXG4gIGFkYXB0ZXJDbGFzczogV2ViM0F1dGhXYWxsZXRBZGFwdGVyLFxuICAvKiog4pyFIEFERDogRGVmaW5lIHRoZSBjYXBhYmlsaXRpZXMgdGhpcyBhZGFwdGVyIGltcGxlbWVudHMuICovXG4gIGNhcGFiaWxpdGllczogW1xuICAgIENhcGFiaWxpdHkuQ29yZVdhbGxldCxcbiAgICBDYXBhYmlsaXR5LkV2ZW50RW1pdHRlcixcbiAgICBDYXBhYmlsaXR5Lk1lc3NhZ2VTaWduZXIsXG4gICAgQ2FwYWJpbGl0eS5UcmFuc2FjdGlvbkhhbmRsZXIsXG4gICAgQ2FwYWJpbGl0eS5UeXBlZERhdGFTaWduZXIsXG4gICAgQ2FwYWJpbGl0eS5HYXNFc3RpbWF0aW9uLFxuICAgIENhcGFiaWxpdHkuVG9rZW5PcGVyYXRpb25zLFxuICAgIENhcGFiaWxpdHkuUlBDSGFuZGxlcixcbiAgICBDYXBhYmlsaXR5LlRyYW5zYWN0aW9uU3RhdHVzLFxuICAgIENhcGFiaWxpdHkuQWRhcHRlckxpZmVjeWNsZVxuICBdLFxuICByZXF1aXJlbWVudHM6IHdlYjNhdXRoUmVxdWlyZW1lbnRzLFxuICBlbnZpcm9ubWVudDogd2ViM2F1dGhFbnZpcm9ubWVudCxcbiAgZmVhdHVyZXM6IHdlYjNhdXRoRmVhdHVyZXNcbn07XG5yZWdpc3RyeS5yZWdpc3RlckFkYXB0ZXIoXCJ3YWxsZXRcIiwgYWRhcHRlck1ldGFkYXRhMik7XG52YXIgY29tcGF0aWJpbGl0eU1hdHJpeDIgPSBnZXRTdGF0aWNDb21wYXRpYmlsaXR5TWF0cml4KFwid2FsbGV0XCIsIFwid2ViM2F1dGhcIiwgXCIxLjAuMFwiKTtcbmlmIChjb21wYXRpYmlsaXR5TWF0cml4Mikge1xuICByZWdpc3RyeS5yZWdpc3RlckNvbXBhdGliaWxpdHlNYXRyaXgoXCJ3YWxsZXRcIiwgY29tcGF0aWJpbGl0eU1hdHJpeDIpO1xufVxuY29uc29sZS5sb2coXCJcXHUyNzA1IFdlYjNBdXRoIHdhbGxldCBhZGFwdGVyIHJlZ2lzdGVyZWQgd2l0aCBzdGF0aWMgY29tcGF0aWJpbGl0eSBtYXRyaXhcIik7XG5jb25zb2xlLmxvZyhcIlxcdXsxRjRDQn0gR2VuZXJhdGVkIHJlcXVpcmVtZW50czpcIiwgd2ViM2F1dGhSZXF1aXJlbWVudHMpO1xuY29uc29sZS5sb2coXCJcXHV7MUYzMER9IEdlbmVyYXRlZCBlbnZpcm9ubWVudDpcIiwgd2ViM2F1dGhFbnZpcm9ubWVudCk7XG5jb25zb2xlLmxvZyhcIlxcdXsxRjUyN30gR2VuZXJhdGVkIGZlYXR1cmVzOlwiLCB3ZWIzYXV0aEZlYXR1cmVzLm1hcCgoZikgPT4gZi5uYW1lKSk7XG5cbi8vIHBhY2thZ2VzL3dhbGxldC9kaXN0L2luZGV4LmpzXG5yZWdpc3RyeS5yZWdpc3Rlck1vZHVsZSh7IG5hbWU6IFwid2FsbGV0XCIsIHZlcnNpb246IHBhY2thZ2VfZGVmYXVsdC52ZXJzaW9uIH0pO1xucmVnaXN0cnkucmVnaXN0ZXJJbnRlcmZhY2VTaGFwZShcIklFVk1XYWxsZXRcIiwgW1xuICBDYXBhYmlsaXR5LkNvcmVXYWxsZXQsXG4gIENhcGFiaWxpdHkuRXZlbnRFbWl0dGVyLFxuICBDYXBhYmlsaXR5Lk1lc3NhZ2VTaWduZXIsXG4gIENhcGFiaWxpdHkuVHJhbnNhY3Rpb25IYW5kbGVyLFxuICBDYXBhYmlsaXR5LlR5cGVkRGF0YVNpZ25lcixcbiAgQ2FwYWJpbGl0eS5HYXNFc3RpbWF0aW9uLFxuICBDYXBhYmlsaXR5LlRva2VuT3BlcmF0aW9ucyxcbiAgQ2FwYWJpbGl0eS5SUENIYW5kbGVyLFxuICBDYXBhYmlsaXR5LlRyYW5zYWN0aW9uU3RhdHVzXG5dKTtcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdhbGxldChwYXJhbXMpIHtcbiAgY29uc3QgeyBuYW1lLCB2ZXJzaW9uIH0gPSBwYXJhbXM7XG4gIHRyeSB7XG4gICAgY29uc3QgYWRhcHRlckluZm8gPSByZWdpc3RyeS5nZXRBZGFwdGVyKE1zM01vZHVsZXMud2FsbGV0LCBuYW1lLCB2ZXJzaW9uKTtcbiAgICBpZiAoIWFkYXB0ZXJJbmZvKSB7XG4gICAgICBjb25zdCBhdmFpbGFibGVWZXJzaW9ucyA9IHJlZ2lzdHJ5LmdldEFkYXB0ZXJWZXJzaW9ucyhNczNNb2R1bGVzLndhbGxldCwgbmFtZSk7XG4gICAgICBjb25zdCB2ZXJzaW9uc1RleHQgPSBhdmFpbGFibGVWZXJzaW9ucy5sZW5ndGggPiAwID8gYCBBdmFpbGFibGUgdmVyc2lvbnM6ICR7YXZhaWxhYmxlVmVyc2lvbnMuam9pbihcIiwgXCIpfWAgOiBcIlwiO1xuICAgICAgdGhyb3cgbmV3IEFkYXB0ZXJFcnJvcihgQWRhcHRlciAnJHtuYW1lfScgdmVyc2lvbiAnJHt2ZXJzaW9ufScgbm90IGZvdW5kIGZvciB3YWxsZXQgbW9kdWxlLiR7dmVyc2lvbnNUZXh0fWApO1xuICAgIH1cbiAgICBpZiAoYWRhcHRlckluZm8uZW52aXJvbm1lbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGFkYXB0ZXJJbmZvLmVudmlyb25tZW50KTtcbiAgICAgIHZhbGlkYXRlRW52aXJvbm1lbnQobmFtZSwgYWRhcHRlckluZm8uZW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0b3JBcmdzID0ge1xuICAgICAgbW9kdWxlTmFtZTogTXMzTW9kdWxlcy53YWxsZXQsXG4gICAgICBuYW1lLFxuICAgICAgdmVyc2lvbixcbiAgICAgIC8vIOKchSBBZGQgdmVyc2lvblxuICAgICAgcGFyYW1zLFxuICAgICAgYWRhcHRlckluZm8sXG4gICAgICByZWdpc3RyeSxcbiAgICAgIGZhY3RvcnlNZXRob2ROYW1lOiBcImNyZWF0ZVdhbGxldFwiXG4gICAgfTtcbiAgICB2YWxpZGF0ZUFkYXB0ZXJQYXJhbWV0ZXJzKHZhbGlkYXRvckFyZ3MpO1xuICAgIGNvbnN0IEFkYXB0ZXJDbGFzcyA9IGFkYXB0ZXJJbmZvLmFkYXB0ZXJDbGFzcztcbiAgICBpZiAoIUFkYXB0ZXJDbGFzcyB8fCB0eXBlb2YgQWRhcHRlckNsYXNzLmNyZWF0ZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKGBBZGFwdGVyIGNsYXNzIG9yIGl0cyBzdGF0aWMgJ2NyZWF0ZScgbWV0aG9kIGlzIGludmFsaWQgZm9yICcke25hbWV9Jy5gKTtcbiAgICB9XG4gICAgY29uc3QgYWRhcHRlciA9IGF3YWl0IEFkYXB0ZXJDbGFzcy5jcmVhdGUoe1xuICAgICAgbmFtZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBvcHRpb25zOiBwYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICAgIGlmICghYWRhcHRlcikge1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRXJyb3JIYW5kbGluZ1Byb3h5KFxuICAgICAgYWRhcHRlcixcbiAgICAgIGFkYXB0ZXJJbmZvLmNhcGFiaWxpdGllcyxcbiAgICAgIC8vIFBhc3MgdGhlIGNhcGFiaWxpdGllc1xuICAgICAgYWRhcHRlckluZm8uZXJyb3JNYXAgfHwge30sXG4gICAgICB2b2lkIDAsXG4gICAgICBgV2FsbGV0QWRhcHRlcigke25hbWV9KWBcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFkYXB0ZXJFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoYEFkYXB0ZXIgJyR7bmFtZX0nIGZhaWxlZCB0byBiZSBjcmVhdGVkOiAke2Vycm9yfWApO1xuICB9XG59XG5leHBvcnQge1xuICBBZGFwdGVyRXJyb3IsXG4gIE5ldHdvcmtIZWxwZXIsXG4gIE5vbmNlVHlwZSxcbiAgUHJpdmF0ZUtleUhlbHBlcixcbiAgUnVudGltZUVudmlyb25tZW50LFxuICBXYWxsZXRFcnJvckNvZGUsXG4gIFdhbGxldEV2ZW50LFxuICBXYWxsZXRUeXBlLFxuICBjcmVhdGVXYWxsZXQsXG4gIHJlZ2lzdHJ5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@m3s/wallet/dist/index.esm.js\n");

/***/ })

};
;